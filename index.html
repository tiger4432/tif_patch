<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
      }
      #left {
        width: 260px;
        padding: 10px;
        background: #eee;
        overflow-y: auto;
      }
      #center {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #333;
      }
      #right {
        width: 320px;
        overflow-y: auto;
        background: #111;
        color: #fff;
        padding: 10px;
      }
      canvas {
        max-width: 100%;
        height: auto;
        cursor: grab;
      }
      canvas.dragging {
        cursor: grabbing;
      }
      .patch {
        margin-bottom: 10px;
      }
      textarea {
        width: 100%;
        height: 80px;
      }
      .refMode {
        background: #ff8;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        height: auto;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .mode-on {
        background-color: #28a745; /* Ï¥àÎ°ùÏÉâ */
        color: white;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <label
        >Multi-page TIFF
        <input id="tiffFile" type="file" accept=".tif,.tiff" /> </label
      ><br /><br />

      <label>Chip CSV (ÌååÏùº ÎòêÎäî ÏóëÏÖÄÎ≥µÎ∂ô)</label>
      <input id="csvFile" type="file" accept=".csv" /><br />
      <textarea
        id="csvPaste"
        placeholder="ÏóëÏÖÄÏóêÏÑú Î≥µÏÇ¨ ÌõÑ Î∂ôÏó¨ÎÑ£Í∏∞ (x,y,type)"
      ></textarea
      ><br /><br />

      <label
        >Page:
        <select id="pageSelect"></select> </label
      ><br /><br />

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br /><br />

      <h3>Reference</h3>
      Í∏∞Ï§Ä X <input id="refX" type="number" value="0" /><br />
      Í∏∞Ï§Ä Y <input id="refY" type="number" value="0" /><br />
      <button id="setRefBtn">Set Reference</button><br /><br />

      <h3>Enhance</h3>
      Contrast Œ± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Œ≤ <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <h3>Patches</h3>
      <div id="voidControls">
        <button id="toggleVoidMode">Mark Void</button>
        <button id="toggleDeleteMode">Delete Void</button>
        <select id="voidTypeSelect">
          <option value="void">void</option>
          <option value="crack">crack</option>
          <option value="particle">particle</option>
        </select>
        <button id="downloadVoids">Download Voids JSON</button>
      </div>
      <div id="patchNav" style="margin-bottom: 10px">
        <button id="prevPage">‚óÄ Prev</button>
        <span id="pageInfo"></span>
        <button id="nextPage">Next ‚ñ∂</button>
      </div>
      <div id="patches"></div>
    </div>

    <script type="module">
      import UTIF from "https://cdn.skypack.dev/utif";

      const waferCanvas = document.getElementById("wafer");
      const waferCtx = waferCanvas.getContext("2d");

      const pageSelect = document.getElementById("pageSelect");
      let pages = [];
      let pageIndex = 0;
      let origin = { x: 50, y: 50 };
      let csvRows = [];
      let refGrid = { x: 0, y: 0 }; // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Í∏∞Ï§Ä grid index
      let refMode = false;
      let currentScale = 1;
      let chipPoints = []; // üîµ ÌååÎûÄÏ†ê Ï¢åÌëú Ï†ÄÏû•
      let voidMarkMode = false;
      let voidRecords = []; // [{patchLabel, type, centerX, centerY, radiusX, radiusY}]
      let deleteVoidMode = false;

      const markBtn = document.getElementById("toggleVoidMode");
      const deleteBtn = document.getElementById("toggleDeleteMode");

      document.getElementById("toggleVoidMode").onclick = () => {
        voidMarkMode = !voidMarkMode;
        markBtn.classList.toggle("mode-on", voidMarkMode); // ONÏù¥Î©¥ Ï¥àÎ°ùÏÉâ
        alert(voidMarkMode ? "Void marking ON" : "Void marking OFF");
      };

      document.getElementById("toggleDeleteMode").onclick = () => {
        deleteVoidMode = !deleteVoidMode;
        deleteBtn.classList.toggle("mode-on", deleteVoidMode);
        alert(deleteVoidMode ? "Delete mode ON" : "Delete mode OFF");
      };
      // === UI ÏóòÎ¶¨Î®ºÌä∏ ===
      const tiffInput = document.getElementById("tiffFile");
      const csvInput = document.getElementById("csvFile");
      const csvPaste = document.getElementById("csvPaste");
      const colsInput = document.getElementById("cols");
      const rowsInput = document.getElementById("rows");
      const cellWInput = document.getElementById("cellW");
      const cellHInput = document.getElementById("cellH");
      const alphaInput = document.getElementById("alpha");
      const betaInput = document.getElementById("beta");
      const extractBtn = document.getElementById("extractBtn");
      const patchesDiv = document.getElementById("patches");
      const refXInput = document.getElementById("refX");
      const refYInput = document.getElementById("refY");
      const setRefBtn = document.getElementById("setRefBtn");

      // ===== TIFF Î°úÎìú =====
      async function loadTiff(file) {
        const buf = await file.arrayBuffer();
        const ifds = UTIF.decode(buf);
        ifds.forEach((ifd) => UTIF.decodeImage(buf, ifd));
        pages = ifds.map((ifd) => {
          const rgba = UTIF.toRGBA8(ifd);
          const c = document.createElement("canvas");
          c.width = ifd.width;
          c.height = ifd.height;
          c.getContext("2d").putImageData(
            new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height),
            0,
            0
          );
          return c;
        });

        // ÌéòÏù¥ÏßÄ ÏÑ†ÌÉù UI Í∞±Ïã†
        pageSelect.innerHTML = pages
          .map((_, i) => `<option value=\"${i}\">Page ${i + 1}</option>`)
          .join("");
        pageIndex = 0;
        drawPage();
      }

      function drawPage() {
        const src = pages[pageIndex];
        if (!src) return; // ÌòπÏãúÎùºÎèÑ undefinedÏùº Í≤ΩÏö∞ ÎåÄÎπÑ

        const MAX_SIZE = 1024; // Î∏åÎùºÏö∞Ï†Ä ÏïàÏ†Ñ Î≤îÏúÑ
        const scale = Math.min(1, MAX_SIZE / Math.max(src.width, src.height));
        const drawW = Math.round(src.width * scale);
        const drawH = Math.round(src.height * scale);

        waferCanvas.width = drawW;
        waferCanvas.height = drawH;
        waferCtx.drawImage(src, 0, 0, drawW, drawH);

        // Í∑∏Î¶¨Îìú ÏúÑÏπò/ÌÅ¨Í∏∞ Ïä§ÏºÄÏùºÎèÑ Í∞ôÏù¥ Ï†ÅÏö©
        currentScale = scale;
        drawGrid();
      }

      pageSelect.addEventListener("change", (e) => {
        pageIndex = e.target.value;
        drawPage();
      });

      function parseBondingMap(text) {
        const lines = text.trimEnd().split(/\r?\n/);
        if (lines.length < 2) return [];

        // Ï≤´ Ìñâ: X Ìó§Îçî (Îπà Î¨∏ÏûêÏó¥ÎèÑ Ïú†ÏßÄ)
        const xHeaders = lines[0]
          .split("\t")
          .slice(1)
          .map((h) => h.trim())
          .map((h) => parseInt(h, 10));

        const out = [];
        for (let r = 1; r < lines.length; r++) {
          // Ìñâ Ï†ÑÏ≤¥Î•º ÌÉ≠ Í∏∞Ï§ÄÏúºÎ°ú Í∑∏ÎåÄÎ°ú split ‚Üí ÎÅùÏùò Îπà Ïπ∏ÎèÑ Ïú†ÏßÄ
          const cells = lines[r].split("\t");
          if (cells.length < 2) continue;

          const y = parseInt((cells[0] || "").trim(), 10);
          if (isNaN(y)) continue;

          // xHeaders Í∏∏Ïù¥Ïóê ÎßûÍ≤å ÏàúÌöå
          for (let c = 1; c <= xHeaders.length; c++) {
            const val = (cells[c] || "").trim();
            if (!val) continue;
            const x = xHeaders[c - 1];
            if (!isNaN(x)) out.push({ x, y, type: val });
          }
        }
        console.log(out);
        return out;
      }

      function drawGrid() {
        if (!pages.length) return;
        const cols = +colsInput.value;
        const rows = +rowsInput.value;
        const cellW = +cellWInput.value * currentScale;
        const cellH = +cellHInput.value * currentScale;

        waferCtx.strokeStyle = "lime";
        for (let i = 0; i <= cols; i++) {
          const x = origin.x + i * cellW;
          waferCtx.beginPath();
          waferCtx.moveTo(x, origin.y);
          waferCtx.lineTo(x, origin.y + rows * cellH);
          waferCtx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          const y = origin.y + j * cellH;
          waferCtx.beginPath();
          waferCtx.moveTo(origin.x, y);
          waferCtx.lineTo(origin.x + cols * cellW, y);
          waferCtx.stroke();
        }

        // üîµ CSV Ï¢åÌëú Í∏∞Ï§ÄÏúºÎ°ú ÌååÎûÄ Ï†ê ÌëúÏãú
        waferCtx.fillStyle = "deepskyblue";
        chipPoints.forEach((pt) => {
          const px = origin.x + (pt.x + refGrid.x + 0.5) * cellW;
          const py = origin.y + (pt.y + refGrid.y + 0.5) * cellH;
          waferCtx.beginPath();
          waferCtx.arc(px, py, Math.max(3, cellW * 0.05), 0, 2 * Math.PI);
          waferCtx.fill();
        });

        // üî¥ Í∏∞Ï§ÄÏ†ê(Reference) Îπ®Í∞Ñ Ï†ê
        waferCtx.fillStyle = "red";
        const refPixelX = origin.x + refGrid.x * cellW + cellW / 2;
        const refPixelY = origin.y + refGrid.y * cellH + cellH / 2;
        waferCtx.beginPath();
        waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
        waferCtx.fill();
      }

      // CSV/ÏóëÏÖÄ ÌååÏã± (ÌÉ≠¬∑ÏΩ§Îßà ÏßÄÏõê)
      function parseCSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split(/[\t,]+/).map((h) => h.toLowerCase());
        const xi = header.indexOf("x"),
          yi = header.indexOf("y"),
          ti = header.indexOf("type");
        if (xi === -1 || yi === -1) {
          alert("x,y Ìó§ÎçîÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
          return [];
        }
        const out = [];
        lines.slice(1).forEach((l) => {
          if (!l.trim()) return;
          const c = l.split(/[\t,]+/);
          const x = parseFloat(c[xi]);
          const y = parseFloat(c[yi]);
          if (isNaN(x) || isNaN(y)) return;
          out.push({ x, y, type: ti >= 0 && c[ti] ? c[ti] : "" });
        });
        return out;
      }

      // Î∞ùÍ∏∞/ÎåÄÎπÑ
      function adjust(ctx) {
        const img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const a = +alphaInput.value,
          b = +betaInput.value;
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = Math.min(255, Math.max(0, d[i] * a + b));
          d[i + 1] = Math.min(255, Math.max(0, d[i + 1] * a + b));
          d[i + 2] = Math.min(255, Math.max(0, d[i + 2] * a + b));
        }
        ctx.putImageData(img, 0, 0);
      }

      function enhanceToTarget(
        ctx,
        targetMean = 0.5,
        targetStd = 0.2,
        pad = 10
      ) {
        const { width, height } = ctx.canvas;
        const imgData = ctx.getImageData(0, 0, width, height);
        const d = imgData.data;

        // ROI : padding ÏïàÏ™Ω
        const roiPixels = [];
        for (let y = pad; y < height - pad; y++) {
          for (let x = pad; x < width - pad; x++) {
            const idx = (y * width + x) * 4;
            // grayscale = average RGB
            const g = (d[idx] + d[idx + 1] + d[idx + 2]) / (3 * 255);
            roiPixels.push(g);
          }
        }
        const mean = roiPixels.reduce((a, b) => a + b, 0) / roiPixels.length;
        const std =
          Math.sqrt(
            roiPixels.reduce((a, b) => a + (b - mean) ** 2, 0) /
              roiPixels.length
          ) || 1e-6;

        // Î≥¥Ï†ï: (v - mean)/std -> target
        const scale = targetStd / std;
        const offset = targetMean - mean * scale;

        for (let i = 0; i < d.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            let v = d[i + c] / 255;
            v = v * scale + offset;
            v = Math.min(1, Math.max(0, v));
            d[i + c] = v * 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      const voidColors = {
        void: "cyan",
        crack: "magenta",
        particle: "lime",
        default: "yellow", // ÎØ∏ÏßÄÏ†ï ÌÉÄÏûÖ
      };
      function attachVoidEvents(canvas, patchLabel, imageData) {
        const ctx = canvas.getContext("2d");

        canvas.addEventListener("mousedown", (e) => {
          if (!voidMarkMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const startX = (e.clientX - rect.left) * scaleX;
          const startY = (e.clientY - rect.top) * scaleY;

          const dragHandler = (me) => {
            const curX = (me.clientX - rect.left) * scaleX;
            const curY = (me.clientY - rect.top) * scaleY;
            // ÌÉÄÏûÖÎ≥Ñ ÏÉâÏÉÅ Îßµ

            ctx.putImageData(imageData, 0, 0);
            const selType =
              document.getElementById("voidTypeSelect").value || "default";
            ctx.strokeStyle = voidColors[selType] || voidColors.default;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(
              (startX + curX) / 2,
              (startY + curY) / 2,
              Math.abs(curX - startX) / 2,
              Math.abs(curY - startY) / 2,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          };

          const upHandler = (ue) => {
            document.removeEventListener("mousemove", dragHandler);
            document.removeEventListener("mouseup", upHandler);
            const endX = (ue.clientX - rect.left) * scaleX;
            const endY = (ue.clientY - rect.top) * scaleY;

            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            const radiusX = Math.abs(endX - startX) / 2;
            const radiusY = Math.abs(endY - startY) / 2;

            const type =
              document.getElementById("voidTypeSelect").value || "void";
            voidRecords.push({
              patchLabel,
              type,
              centerX,
              centerY,
              radiusX,
              radiusY,
            });

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
          };

          document.addEventListener("mousemove", dragHandler);
          document.addEventListener("mouseup", upHandler);
        });

        canvas.addEventListener("click", (e) => {
          if (!deleteVoidMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // ÌÅ¥Î¶≠Ìïú Ï†êÏùÑ Ìè¨Ìï®ÌïòÎäî Î≥¥Ïù¥Îìú Ï∞æÍ∏∞
          let removed = false;
          voidRecords = voidRecords.filter((v) => {
            if (v.patchLabel !== patchLabel) return true;
            // ÌÉÄÏõê ÏïàÏóê Îì§Ïñ¥Í∞ÄÎ©¥ ÏÇ≠Ï†ú
            const dx = (x - v.centerX) / v.radiusX;
            const dy = (y - v.centerY) / v.radiusY;
            const inside = dx * dx + dy * dy <= 1;
            if (inside && !removed) {
              removed = true;
              return false; // ÏÇ≠Ï†ú
            }
            return true;
          });

          if (removed) {
            ctx.putImageData(imageData, 0, 0); // ÏõêÎ≥∏ Î≥µÏõê
            drawAllVoids(ctx, patchLabel); // ÎÇ®ÏùÄ Î≥¥Ïù¥Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
          }
        });
      }

      // ÌäπÏ†ï Ìå®ÏπòÏóê Ï†ÄÏû•Îêú Î™®Îì† Î≥¥Ïù¥Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
      function drawAllVoids(ctx, patchLabel) {
        ctx.lineWidth = 2;
        voidRecords
          .filter((v) => v.patchLabel === patchLabel)
          .forEach((v) => {
            ctx.beginPath();
            const color = voidColors[v.type] || voidColors.default;
            ctx.strokeStyle = color;
            ctx.ellipse(
              v.centerX,
              v.centerY,
              v.radiusX,
              v.radiusY,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          });
      }

      // === Ïù¥Î≤§Ìä∏ ===

      tiffInput.onchange = (e) => {
        if (e.target.files[0]) loadTiff(e.target.files[0]);
      };

      // Í∑∏Î¶¨Îìú ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú ÌéòÏù¥ÏßÄ Í∞±Ïã†
      [colsInput, rowsInput, cellWInput, cellHInput].forEach((el) => {
        el.removeEventListener("input", drawPage); // ÌòπÏãú Ï§ëÎ≥µ Î∞©ÏßÄ
        el.addEventListener("input", () => {
          drawPage(); // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ïú†ÏßÄ
        });
      });

      // CSV ÌååÏùº ÏóÖÎ°úÎìú
      csvInput.onchange = async (e) => {
        if (e.target.files[0]) {
          csvRows = parseBondingMap(await e.target.files[0].text());
          chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
          drawPage(); // CSV Î°úÎìú ÌõÑ Î∞îÎ°ú Í∑∏Î¶¨ÎìúÏôÄ Ï†ê Í∞±Ïã†
        }
      };

      // ÏóëÏÖÄ Î≥µÎ∂ô
      csvPaste.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        csvRows = parseBondingMap(text);
        chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
        alert(`Î≥µÎ∂ôÌïú ${csvRows.length}Í∞úÏùò chip Ï¢åÌëú Î°úÎìú ÏôÑÎ£å`);
        drawPage();
      });
      // ÎìúÎûòÍ∑∏Î°ú origin Ïù¥Îèô
      let dragging = false;
      let start = { x: 0, y: 0 };
      waferCanvas.addEventListener("mousedown", (e) => {
        if (refMode) return; // Ï∞∏Ï°∞Î™®ÎìúÏùº ÎïåÎäî ÎìúÎûòÍ∑∏Í∏àÏßÄ
        dragging = true;
        waferCanvas.classList.add("dragging");
        start.x = e.clientX;
        start.y = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        waferCanvas.classList.remove("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        origin.x += e.clientX - start.x;
        origin.y += e.clientY - start.y;
        start.x = e.clientX;
        start.y = e.clientY;
        drawPage();
      });

      // üü• Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï Î™®Îìú
      setRefBtn.onclick = () => {
        refMode = !refMode;
        setRefBtn.classList.toggle("refMode", refMode);
        setRefBtn.textContent = refMode ? "Click Grid to Set" : "Set Reference";
      };

      // Í∑∏Î¶¨Îìú ÌÅ¥Î¶≠ ‚Üí Ï∞∏Ï°∞ ÏÑ§Ï†ï
      waferCanvas.addEventListener("click", (e) => {
        if (!refMode) return;
        const rect = waferCanvas.getBoundingClientRect();
        const clickX =
          ((e.clientX - rect.left) * waferCanvas.width) / rect.width;
        const clickY =
          ((e.clientY - rect.top) * waferCanvas.height) / rect.height;
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const gx = Math.floor((clickX - origin.x / currentScale) / cellW);
        const gy = Math.floor((clickY - origin.y / currentScale) / cellH);
        refGrid = { x: gx, y: gy };
        refXInput.value = gx;
        refYInput.value = gy;
        refMode = false;
        setRefBtn.classList.remove("refMode");
        setRefBtn.textContent = "Set Reference";
        drawPage();
      });

      const targetMeanInput = document.getElementById("targetMean");
      const targetStdInput = document.getElementById("targetStd");
      const padPxInput = document.getElementById("padPx");

      let allPatchPages = []; // Ï¢åÌëúÎ≥Ñ ÌéòÏù¥ÏßÄ (Í∞Å ÌéòÏù¥ÏßÄ = {coord, layers:[canvas‚Ä¶]})
      let currentPatchPage = 0;

      // Í∏∞Ï°¥ extractBtn.onclick ÍµêÏ≤¥
      extractBtn.onclick = () => {
        if (!pages.length || !csvRows.length) return;

        allPatchPages = [];
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const tMean = parseFloat(targetMeanInput.value);
        const tStd = parseFloat(targetStdInput.value);
        const pad = parseInt(padPxInput.value, 10);
        window.allPatchCanvases = [];

        csvRows.forEach((r) => {
          const pageData = { coord: `(${r.x},${r.y})`, layers: [] };

          pages.forEach((src, pageIdx) => {
            const gx = origin.x / currentScale + (r.x + refGrid.x) * cellW;
            const gy = origin.y / currentScale + (r.y + refGrid.y) * cellH;

            const titleH = 40;
            const c = document.createElement("canvas");
            c.width = cellW;
            c.height = cellH + titleH;
            const ctx = c.getContext("2d");

            // ÌÉÄÏù¥ÌãÄ
            const label = `X${String(r.x).padStart(2, "0")}_Y${String(
              r.y
            ).padStart(2, "0")}_L${String(pageIdx + 1).padStart(2, "0")}_LEG:${
              r.type || "NA"
            }`;
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cellW, titleH);
            ctx.fillStyle = "#fff";
            ctx.font = "20px sans-serif";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 6, titleH / 2);

            // Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
            ctx.drawImage(src, gx, gy, cellW, cellH, 0, titleH, cellW, cellH);
            const originalImageData = ctx.getImageData(0, 0, c.width, c.height);

            // ÎßàÌÇπ Ïù¥Î≤§Ìä∏ Î∂ÄÏ∞©
            attachVoidEvents(c, label, originalImageData);

            // Î∞ùÍ∏∞/ÎåÄÎπÑ Î≥¥Ï†ï (ROI Í∏∞Î∞ò)
            const subImg = ctx.getImageData(0, titleH, cellW, cellH);
            const tmp = document.createElement("canvas");
            tmp.width = cellW;
            tmp.height = cellH;
            tmp.getContext("2d").putImageData(subImg, 0, 0);
            enhanceToTarget(tmp.getContext("2d"), tMean, tStd, pad);
            ctx.putImageData(
              tmp.getContext("2d").getImageData(0, 0, cellW, cellH),
              0,
              titleH
            );

            // Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            pageData.layers.push({
              canvas: c,
              label,
              type: r.type || "NA",
              layer: pageIdx + 1,
              imageData: originalImageData, // ‚òÖ Ï∂îÍ∞Ä
            });
            const typeFolder = r.type
              ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
              : "NA";
            window.allPatchCanvases.push({
              canvas: c,
              layer: pageIdx + 1,
              label,
              type: typeFolder,
            });
          });

          allPatchPages.push(pageData);
        });

        currentPatchPage = 0;
        showPatchPage(0);
      };
      // ÌéòÏù¥ÏßÄ ÌëúÏãú Ìï®Ïàò
      function showPatchPage(idx) {
        if (!allPatchPages.length) return;
        if (idx < 0) idx = 0;
        if (idx >= allPatchPages.length) idx = allPatchPages.length - 1;
        currentPatchPage = idx;

        const page = allPatchPages[idx];
        const patchesDiv = document.getElementById("patches");
        patchesDiv.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "coord-card";
        wrap.innerHTML = `<h3 style="color:white">Chip ${page.coord}</h3>`;

        const layersWrap = document.createElement("div");
        layersWrap.className = "layers-wrap";
        page.layers.forEach((l) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.innerHTML = `<div class="layer-label">${l.label}</div>`;
          item.appendChild(l.canvas);
          layersWrap.appendChild(item);
        });
        wrap.appendChild(layersWrap);
        patchesDiv.appendChild(wrap);

        document.getElementById("pageInfo").textContent = `Page ${
          currentPatchPage + 1
        } / ${allPatchPages.length}`;
      }

      // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î≤ÑÌäº
      document.getElementById("prevPage").onclick = () =>
        showPatchPage(currentPatchPage - 1);
      document.getElementById("nextPage").onclick = () =>
        showPatchPage(currentPatchPage + 1);

      document.getElementById("downloadVoids").onclick = () => {
        if (!voidRecords.length) {
          alert("No voids recorded.");
          return;
        }
        const blob = new Blob([JSON.stringify(voidRecords, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "void_records.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      // Ïà´ÏûêÌÇ§ ‚Üí ÌÉÄÏûÖ
      const voidKeyMap = {
        1: "void",
        2: "crack",
        3: "particle",
      };
      const typeSelect = document.getElementById("voidTypeSelect");

      // Ïà´Ïûê ÌÇ§ ÎàåÎ†ÄÏùÑ Îïå ÌÉÄÏûÖ Î≥ÄÍ≤Ω
      document.addEventListener("keydown", (e) => {
        if (!voidMarkMode) return; // ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎßå
        const newType = voidKeyMap[e.key];
        if (newType) {
          typeSelect.value = newType; // ÎìúÎ°≠Îã§Ïö¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
          console.log(`Void type set to: ${newType}`);
        }
      });
    </script>
  </body>
</html>
