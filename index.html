<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
      }
      #left {
        width: 260px;
        padding: 10px;
        background: #eee;
        overflow-y: auto;
      }
      #center {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #333;
      }
      #right {
        width: 320px;
        overflow-y: auto;
        background: #111;
        color: #fff;
        padding: 10px;
      }
      canvas {
        max-width: 100%;
        height: auto;
        cursor: grab;
      }
      canvas.dragging {
        cursor: grabbing;
      }
      .patch {
        margin-bottom: 10px;
      }
      textarea {
        width: 100%;
        height: 80px;
      }
      .refMode {
        background: #ff8;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        height: auto;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .mode-on {
        background-color: #28a745; /* ì´ˆë¡ìƒ‰ */
        color: white;
        font-weight: bold;
      }

      #topControls {
        position: sticky;
        top: 0; /* í™”ë©´ ìµœìƒë‹¨ ê³ ì • */
        z-index: 1000; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œ */
        background: #222; /* ë°°ê²½ìƒ‰, ìŠ¤í¬ë¡¤ ì‹œ ë‚´ìš©ì´ ë¹„ì¹˜ì§€ ì•Šê²Œ */
        padding: 10px;
      }

      #voidControls {
        padding: 10px;
        display: flex;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <label
        >Multi-page TIFF
        <input id="tiffFile" type="file" accept=".tif,.tiff" /> </label
      ><br /><br />

      <label>Chip CSV (íŒŒì¼ ë˜ëŠ” ì—‘ì…€ë³µë¶™)</label>
      <input id="csvFile" type="file" accept=".csv" /><br />
      <textarea
        id="csvPaste"
        placeholder="ì—‘ì…€ì—ì„œ ë³µì‚¬ í›„ ë¶™ì—¬ë„£ê¸° (x,y,type)"
      ></textarea
      ><br /><br />

      <label
        >Page:
        <select id="pageSelect"></select> </label
      ><br /><br />

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br /><br />

      <h3>Reference</h3>
      ê¸°ì¤€ X <input id="refX" type="number" value="0" /><br />
      ê¸°ì¤€ Y <input id="refY" type="number" value="0" /><br />
      <button id="setRefBtn">Set Reference</button><br /><br />

      <h3>Enhance</h3>
      Contrast Î± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Î² <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <h3>Patches</h3>
      <div id="topControls">
        <div id="voidControls">
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <option value="void">void</option>
            <option value="crack">crack</option>
            <option value="particle">particle</option>
          </select>
          <button id="downloadVoids">Download Voids JSON</button>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">â—€ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next â–¶</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>

    <script type="module">
      import UTIF from "https://cdn.skypack.dev/utif";

      const waferCanvas = document.getElementById("wafer");
      const waferCtx = waferCanvas.getContext("2d");

      const pageSelect = document.getElementById("pageSelect");
      let pages = [];
      let pageIndex = 0;
      let origin = { x: 50, y: 50 };
      let csvRows = [];
      let refGrid = { x: 0, y: 0 }; // ì‚¬ìš©ìê°€ ì§€ì •í•œ ê¸°ì¤€ grid index
      let refMode = false;
      let currentScale = 1;
      let chipPoints = []; // ğŸ”µ íŒŒë€ì  ì¢Œí‘œ ì €ì¥
      let voidMarkMode = false;
      let voidRecords = []; // [{patchLabel, type, centerX, centerY, radiusX, radiusY}]
      let deleteVoidMode = false;
      let selectedVoid = null;
      let resizeMode = false;

      const markBtn = document.getElementById("toggleVoidMode");
      const deleteBtn = document.getElementById("toggleDeleteMode");

      document.getElementById("toggleVoidMode").onclick = () => {
        voidMarkMode = !voidMarkMode;
        markBtn.classList.toggle("mode-on", voidMarkMode); // ONì´ë©´ ì´ˆë¡ìƒ‰
      };

      document.getElementById("toggleDeleteMode").onclick = () => {
        deleteVoidMode = !deleteVoidMode;
        deleteBtn.classList.toggle("mode-on", deleteVoidMode);
      };
      // === UI ì—˜ë¦¬ë¨¼íŠ¸ ===
      const tiffInput = document.getElementById("tiffFile");
      const csvInput = document.getElementById("csvFile");
      const csvPaste = document.getElementById("csvPaste");
      const colsInput = document.getElementById("cols");
      const rowsInput = document.getElementById("rows");
      const cellWInput = document.getElementById("cellW");
      const cellHInput = document.getElementById("cellH");
      const alphaInput = document.getElementById("alpha");
      const betaInput = document.getElementById("beta");
      const extractBtn = document.getElementById("extractBtn");
      const patchesDiv = document.getElementById("patches");
      const refXInput = document.getElementById("refX");
      const refYInput = document.getElementById("refY");
      const setRefBtn = document.getElementById("setRefBtn");

      // ===== TIFF ë¡œë“œ =====
      async function loadTiff(file) {
        const buf = await file.arrayBuffer();
        const ifds = UTIF.decode(buf);
        ifds.forEach((ifd) => UTIF.decodeImage(buf, ifd));
        pages = ifds.map((ifd) => {
          const rgba = UTIF.toRGBA8(ifd);
          const c = document.createElement("canvas");
          c.width = ifd.width;
          c.height = ifd.height;
          c.getContext("2d").putImageData(
            new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height),
            0,
            0
          );
          return c;
        });

        // í˜ì´ì§€ ì„ íƒ UI ê°±ì‹ 
        pageSelect.innerHTML = pages
          .map((_, i) => `<option value=\"${i}\">Page ${i + 1}</option>`)
          .join("");
        pageIndex = 0;
        drawPage();
      }

      function drawPage() {
        const src = pages[pageIndex];
        if (!src) return; // í˜¹ì‹œë¼ë„ undefinedì¼ ê²½ìš° ëŒ€ë¹„

        const MAX_SIZE = 1024; // ë¸Œë¼ìš°ì € ì•ˆì „ ë²”ìœ„
        const scale = Math.min(1, MAX_SIZE / Math.max(src.width, src.height));
        const drawW = Math.round(src.width * scale);
        const drawH = Math.round(src.height * scale);

        waferCanvas.width = drawW;
        waferCanvas.height = drawH;
        waferCtx.drawImage(src, 0, 0, drawW, drawH);

        // ê·¸ë¦¬ë“œ ìœ„ì¹˜/í¬ê¸° ìŠ¤ì¼€ì¼ë„ ê°™ì´ ì ìš©
        currentScale = scale;
        drawGrid();
      }

      pageSelect.addEventListener("change", (e) => {
        pageIndex = e.target.value;
        drawPage();
      });

      function parseBondingMap(text) {
        const lines = text.trimEnd().split(/\r?\n/);
        if (lines.length < 2) return [];

        // ì²« í–‰: X í—¤ë” (ë¹ˆ ë¬¸ìì—´ë„ ìœ ì§€)
        const xHeaders = lines[0]
          .split("\t")
          .slice(1)
          .map((h) => h.trim())
          .map((h) => parseInt(h, 10));

        const out = [];
        for (let r = 1; r < lines.length; r++) {
          // í–‰ ì „ì²´ë¥¼ íƒ­ ê¸°ì¤€ìœ¼ë¡œ ê·¸ëŒ€ë¡œ split â†’ ëì˜ ë¹ˆ ì¹¸ë„ ìœ ì§€
          const cells = lines[r].split("\t");
          if (cells.length < 2) continue;

          const y = parseInt((cells[0] || "").trim(), 10);
          if (isNaN(y)) continue;

          // xHeaders ê¸¸ì´ì— ë§ê²Œ ìˆœíšŒ
          for (let c = 1; c <= xHeaders.length; c++) {
            const val = (cells[c] || "").trim();
            if (!val) continue;
            const x = xHeaders[c - 1];
            if (!isNaN(x)) out.push({ x, y, type: val });
          }
        }
        console.log(out);
        return out;
      }

      function drawGrid() {
        if (!pages.length) return;
        const cols = +colsInput.value;
        const rows = +rowsInput.value;
        const cellW = +cellWInput.value * currentScale;
        const cellH = +cellHInput.value * currentScale;

        waferCtx.strokeStyle = "lime";
        for (let i = 0; i <= cols; i++) {
          const x = origin.x + i * cellW;
          waferCtx.beginPath();
          waferCtx.moveTo(x, origin.y);
          waferCtx.lineTo(x, origin.y + rows * cellH);
          waferCtx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          const y = origin.y + j * cellH;
          waferCtx.beginPath();
          waferCtx.moveTo(origin.x, y);
          waferCtx.lineTo(origin.x + cols * cellW, y);
          waferCtx.stroke();
        }

        // ğŸ”µ CSV ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ íŒŒë€ ì  í‘œì‹œ
        waferCtx.fillStyle = "deepskyblue";
        chipPoints.forEach((pt) => {
          const px = origin.x + (pt.x + refGrid.x + 0.5) * cellW;
          const py = origin.y + (pt.y + refGrid.y + 0.5) * cellH;
          waferCtx.beginPath();
          waferCtx.arc(px, py, Math.max(3, cellW * 0.05), 0, 2 * Math.PI);
          waferCtx.fill();
        });

        // ğŸ”´ ê¸°ì¤€ì (Reference) ë¹¨ê°„ ì 
        waferCtx.fillStyle = "red";
        const refPixelX = origin.x + refGrid.x * cellW + cellW / 2;
        const refPixelY = origin.y + refGrid.y * cellH + cellH / 2;
        waferCtx.beginPath();
        waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
        waferCtx.fill();
      }

      // CSV/ì—‘ì…€ íŒŒì‹± (íƒ­Â·ì½¤ë§ˆ ì§€ì›)
      function parseCSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split(/[\t,]+/).map((h) => h.toLowerCase());
        const xi = header.indexOf("x"),
          yi = header.indexOf("y"),
          ti = header.indexOf("type");
        if (xi === -1 || yi === -1) {
          alert("x,y í—¤ë”ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
          return [];
        }
        const out = [];
        lines.slice(1).forEach((l) => {
          if (!l.trim()) return;
          const c = l.split(/[\t,]+/);
          const x = parseFloat(c[xi]);
          const y = parseFloat(c[yi]);
          if (isNaN(x) || isNaN(y)) return;
          out.push({ x, y, type: ti >= 0 && c[ti] ? c[ti] : "" });
        });
        return out;
      }

      // ë°ê¸°/ëŒ€ë¹„
      function adjust(ctx) {
        const img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const a = +alphaInput.value,
          b = +betaInput.value;
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = Math.min(255, Math.max(0, d[i] * a + b));
          d[i + 1] = Math.min(255, Math.max(0, d[i + 1] * a + b));
          d[i + 2] = Math.min(255, Math.max(0, d[i + 2] * a + b));
        }
        ctx.putImageData(img, 0, 0);
      }

      function enhanceToTarget(
        ctx,
        targetMean = 0.5,
        targetStd = 0.2,
        pad = 10
      ) {
        const { width, height } = ctx.canvas;
        const imgData = ctx.getImageData(0, 0, width, height);
        const d = imgData.data;

        // ROI : padding ì•ˆìª½
        const roiPixels = [];
        for (let y = pad; y < height - pad; y++) {
          for (let x = pad; x < width - pad; x++) {
            const idx = (y * width + x) * 4;
            // grayscale = average RGB
            const g = (d[idx] + d[idx + 1] + d[idx + 2]) / (3 * 255);
            roiPixels.push(g);
          }
        }
        const mean = roiPixels.reduce((a, b) => a + b, 0) / roiPixels.length;
        const std =
          Math.sqrt(
            roiPixels.reduce((a, b) => a + (b - mean) ** 2, 0) /
              roiPixels.length
          ) || 1e-6;

        // ë³´ì •: (v - mean)/std -> target
        const scale = targetStd / std;
        const offset = targetMean - mean * scale;

        for (let i = 0; i < d.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            let v = d[i + c] / 255;
            v = v * scale + offset;
            v = Math.min(1, Math.max(0, v));
            d[i + c] = v * 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      const voidColors = {
        void: "cyan",
        crack: "magenta",
        particle: "lime",
        default: "yellow", // ë¯¸ì§€ì • íƒ€ì…
      };
      function attachVoidEvents(canvas, patchLabel, imageData) {
        const ctx = canvas.getContext("2d");

        canvas.addEventListener("mousedown", (e) => {
          if (!voidMarkMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const startX = (e.clientX - rect.left) * scaleX;
          const startY = (e.clientY - rect.top) * scaleY;

          const dragHandler = (me) => {
            const curX = (me.clientX - rect.left) * scaleX;
            const curY = (me.clientY - rect.top) * scaleY;
            // íƒ€ì…ë³„ ìƒ‰ìƒ ë§µ

            ctx.putImageData(imageData, 0, 0);
            const selType =
              document.getElementById("voidTypeSelect").value || "default";
            ctx.strokeStyle = voidColors[selType] || voidColors.default;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(
              (startX + curX) / 2,
              (startY + curY) / 2,
              Math.abs(curX - startX) / 2,
              Math.abs(curY - startY) / 2,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          };

          const upHandler = (ue) => {
            document.removeEventListener("mousemove", dragHandler);
            document.removeEventListener("mouseup", upHandler);
            const endX = (ue.clientX - rect.left) * scaleX;
            const endY = (ue.clientY - rect.top) * scaleY;

            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            const radiusX = Math.abs(endX - startX) / 2;
            const radiusY = Math.abs(endY - startY) / 2;

            const type =
              document.getElementById("voidTypeSelect").value || "void";
            voidRecords.push({
              patchLabel,
              type,
              centerX,
              centerY,
              radiusX,
              radiusY,
            });

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
          };

          document.addEventListener("mousemove", dragHandler);
          document.addEventListener("mouseup", upHandler);
        });

        canvas.addEventListener("click", (e) => {
          if (!deleteVoidMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // í´ë¦­í•œ ì ì„ í¬í•¨í•˜ëŠ” ë³´ì´ë“œ ì°¾ê¸°
          let removed = false;
          voidRecords = voidRecords.filter((v) => {
            if (v.patchLabel !== patchLabel) return true;
            // íƒ€ì› ì•ˆì— ë“¤ì–´ê°€ë©´ ì‚­ì œ
            const dx = (x - v.centerX) / v.radiusX;
            const dy = (y - v.centerY) / v.radiusY;
            const inside = dx * dx + dy * dy <= 1;
            if (inside && !removed) {
              removed = true;
              return false; // ì‚­ì œ
            }
            return true;
          });

          if (removed) {
            ctx.putImageData(imageData, 0, 0); // ì›ë³¸ ë³µì›
            drawAllVoids(ctx, patchLabel); // ë‚¨ì€ ë³´ì´ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
          }
        });

        canvas.addEventListener("mousedown", (e) => {
          if (voidMarkMode || deleteVoidMode) return;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          selectedVoid = voidRecords.find(
            (v) =>
              v.patchLabel === patchLabel &&
              (() => {
                const dx = x - v.centerX;
                const dy = y - v.centerY;
                const angle = Math.atan2(dy, dx);
                const rB =
                  (v.radiusX * v.radiusY) /
                  Math.sqrt(
                    (v.radiusY * Math.cos(angle)) ** 2 +
                      (v.radiusX * Math.sin(angle)) ** 2
                  );
                const dist = Math.hypot(dx, dy);
                return dist <= rB + 8; // 8px ì˜¤ì°¨ í—ˆìš©
              })()
          );

          if (!selectedVoid) return;

          // ì´ë™/ë¦¬ì‚¬ì´ì¦ˆ êµ¬ë¶„
          const dx = x - selectedVoid.centerX;
          const dy = y - selectedVoid.centerY;
          const angle = Math.atan2(dy, dx);
          const rB =
            (selectedVoid.radiusX * selectedVoid.radiusY) /
            Math.sqrt(
              (selectedVoid.radiusY * Math.cos(angle)) ** 2 +
                (selectedVoid.radiusX * Math.sin(angle)) ** 2
            );
          const dist = Math.hypot(dx, dy);
          const tol = 8;

          resizeMode = Math.abs(dist - rB) <= tol;

          const offsetX = x - selectedVoid.centerX;
          const offsetY = y - selectedVoid.centerY;

          const moveHandler = (me) => {
            const mx = (me.clientX - rect.left) * scaleX;
            const my = (me.clientY - rect.top) * scaleY;

            if (resizeMode) {
              // Shift ëˆ„ë¥´ë©´ ë¹„ìœ¨ ìœ ì§€
              const dx = Math.abs(mx - selectedVoid.centerX);
              const dy = Math.abs(my - selectedVoid.centerY);
              if (me.shiftKey) {
                const r = Math.max(dx, dy);
                selectedVoid.radiusX = selectedVoid.radiusY = r;
              } else {
                selectedVoid.radiusX = dx;
                selectedVoid.radiusY = dy;
              }
            } else {
              // ì´ë™
              selectedVoid.centerX = mx - offsetX;
              selectedVoid.centerY = my - offsetY;
            }

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
          };

          const upHandler = () => {
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
            selectedVoid = null;
          };

          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
        });
      }

      // íŠ¹ì • íŒ¨ì¹˜ì— ì €ì¥ëœ ëª¨ë“  ë³´ì´ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      function drawAllVoids(ctx, patchLabel) {
        ctx.lineWidth = 2;
        voidRecords
          .filter((v) => v.patchLabel === patchLabel)
          .forEach((v) => {
            ctx.beginPath();
            const color = voidColors[v.type] || voidColors.default;
            ctx.strokeStyle = color;
            ctx.ellipse(
              v.centerX,
              v.centerY,
              v.radiusX,
              v.radiusY,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          });
      }

      // === ì´ë²¤íŠ¸ ===

      tiffInput.onchange = (e) => {
        if (e.target.files[0]) loadTiff(e.target.files[0]);
      };

      // ê·¸ë¦¬ë“œ í¬ê¸° ë³€ê²½ ì‹œ í˜ì´ì§€ ê°±ì‹ 
      [colsInput, rowsInput, cellWInput, cellHInput].forEach((el) => {
        el.removeEventListener("input", drawPage); // í˜¹ì‹œ ì¤‘ë³µ ë°©ì§€
        el.addEventListener("input", () => {
          drawPage(); // í˜ì´ì§€ë„¤ì´ì…˜ ìœ ì§€
        });
      });

      // CSV íŒŒì¼ ì—…ë¡œë“œ
      csvInput.onchange = async (e) => {
        if (e.target.files[0]) {
          csvRows = parseBondingMap(await e.target.files[0].text());
          chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
          drawPage(); // CSV ë¡œë“œ í›„ ë°”ë¡œ ê·¸ë¦¬ë“œì™€ ì  ê°±ì‹ 
        }
      };

      // ì—‘ì…€ ë³µë¶™
      csvPaste.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        csvRows = parseBondingMap(text);
        chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
        alert(`ë³µë¶™í•œ ${csvRows.length}ê°œì˜ chip ì¢Œí‘œ ë¡œë“œ ì™„ë£Œ`);
        drawPage();
      });
      // ë“œë˜ê·¸ë¡œ origin ì´ë™
      let dragging = false;
      let start = { x: 0, y: 0 };
      waferCanvas.addEventListener("mousedown", (e) => {
        if (refMode) return; // ì°¸ì¡°ëª¨ë“œì¼ ë•ŒëŠ” ë“œë˜ê·¸ê¸ˆì§€
        dragging = true;
        waferCanvas.classList.add("dragging");
        start.x = e.clientX;
        start.y = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        waferCanvas.classList.remove("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        origin.x += e.clientX - start.x;
        origin.y += e.clientY - start.y;
        start.x = e.clientX;
        start.y = e.clientY;
        drawPage();
      });

      // ğŸŸ¥ ê¸°ì¤€ì  ì„¤ì • ëª¨ë“œ
      setRefBtn.onclick = () => {
        refMode = !refMode;
        setRefBtn.classList.toggle("refMode", refMode);
        setRefBtn.textContent = refMode ? "Click Grid to Set" : "Set Reference";
      };

      // ê·¸ë¦¬ë“œ í´ë¦­ â†’ ì°¸ì¡° ì„¤ì •
      waferCanvas.addEventListener("click", (e) => {
        if (!refMode) return;
        const rect = waferCanvas.getBoundingClientRect();
        const clickX =
          ((e.clientX - rect.left) * waferCanvas.width) / rect.width;
        const clickY =
          ((e.clientY - rect.top) * waferCanvas.height) / rect.height;
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const gx = Math.floor((clickX - origin.x / currentScale) / cellW);
        const gy = Math.floor((clickY - origin.y / currentScale) / cellH);
        refGrid = { x: gx, y: gy };
        refXInput.value = gx;
        refYInput.value = gy;
        refMode = false;
        setRefBtn.classList.remove("refMode");
        setRefBtn.textContent = "Set Reference";
        drawPage();
      });

      const targetMeanInput = document.getElementById("targetMean");
      const targetStdInput = document.getElementById("targetStd");
      const padPxInput = document.getElementById("padPx");

      let allPatchPages = []; // ì¢Œí‘œë³„ í˜ì´ì§€ (ê° í˜ì´ì§€ = {coord, layers:[canvasâ€¦]})
      let currentPatchPage = 0;

      // ê¸°ì¡´ extractBtn.onclick êµì²´
      extractBtn.onclick = () => {
        if (!pages.length || !csvRows.length) return;

        allPatchPages = [];
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const tMean = parseFloat(targetMeanInput.value);
        const tStd = parseFloat(targetStdInput.value);
        const pad = parseInt(padPxInput.value, 10);
        window.allPatchCanvases = [];

        csvRows.forEach((r) => {
          const pageData = { coord: `(${r.x},${r.y})`, layers: [] };

          pages.forEach((src, pageIdx) => {
            const gx = origin.x / currentScale + (r.x + refGrid.x) * cellW;
            const gy = origin.y / currentScale + (r.y + refGrid.y) * cellH;

            const titleH = 40;
            const c = document.createElement("canvas");
            c.width = cellW;
            c.height = cellH + titleH;
            const ctx = c.getContext("2d");

            // íƒ€ì´í‹€
            const label = `X${String(r.x).padStart(2, "0")}_Y${String(
              r.y
            ).padStart(2, "0")}_L${String(pageIdx + 1).padStart(2, "0")}_LEG:${
              r.type || "NA"
            }`;
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cellW, titleH);
            ctx.fillStyle = "#fff";
            ctx.font = "20px sans-serif";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 6, titleH / 2);

            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            ctx.drawImage(src, gx, gy, cellW, cellH, 0, titleH, cellW, cellH);
            const originalImageData = ctx.getImageData(0, 0, c.width, c.height);

            // ë§ˆí‚¹ ì´ë²¤íŠ¸ ë¶€ì°©
            attachVoidEvents(c, label, originalImageData);

            // ë°ê¸°/ëŒ€ë¹„ ë³´ì • (ROI ê¸°ë°˜)
            const subImg = ctx.getImageData(0, titleH, cellW, cellH);
            const tmp = document.createElement("canvas");
            tmp.width = cellW;
            tmp.height = cellH;
            tmp.getContext("2d").putImageData(subImg, 0, 0);
            enhanceToTarget(tmp.getContext("2d"), tMean, tStd, pad);
            ctx.putImageData(
              tmp.getContext("2d").getImageData(0, 0, cellW, cellH),
              0,
              titleH
            );

            // ë°ì´í„° ìˆ˜ì§‘
            pageData.layers.push({
              canvas: c,
              label,
              type: r.type || "NA",
              layer: pageIdx + 1,
              imageData: originalImageData, // â˜… ì¶”ê°€
            });
            const typeFolder = r.type
              ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
              : "NA";
            window.allPatchCanvases.push({
              canvas: c,
              layer: pageIdx + 1,
              label,
              type: typeFolder,
            });
          });

          allPatchPages.push(pageData);
        });

        currentPatchPage = 0;
        showPatchPage(0);
      };

      document.getElementById("downloadZipBtn").onclick = () => {
        if (!window.allPatchCanvases || !window.allPatchCanvases.length) {
          alert("ë¨¼ì € Extract Patchesë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.");
          return;
        }

        const zip = new JSZip();

        window.allPatchCanvases.forEach((p) => {
          const folderPath = `split/${p.type}/layer_${String(p.layer).padStart(
            2,
            "0"
          )}`;
          const folder = zip.folder(folderPath);
          const dataURL = p.canvas.toDataURL("image/png").split(",")[1]; // base64
          folder.file(`${p.label}.png`, dataURL, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then((content) => {
          saveAs(content, "wafer_patches_by_type.zip");
        });
      };

      // í˜ì´ì§€ í‘œì‹œ í•¨ìˆ˜
      function showPatchPage(idx) {
        if (!allPatchPages.length) return;
        if (idx < 0) idx = 0;
        if (idx >= allPatchPages.length) idx = allPatchPages.length - 1;
        currentPatchPage = idx;

        const page = allPatchPages[idx];
        const patchesDiv = document.getElementById("patches");
        patchesDiv.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "coord-card";
        wrap.innerHTML = `<h3 style="color:white">Chip ${page.coord}</h3>`;

        const layersWrap = document.createElement("div");
        layersWrap.className = "layers-wrap";
        page.layers.forEach((l) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.innerHTML = `<div class="layer-label">${l.label}</div>`;
          item.appendChild(l.canvas);
          layersWrap.appendChild(item);
        });
        wrap.appendChild(layersWrap);
        patchesDiv.appendChild(wrap);

        document.getElementById("pageInfo").textContent = `Page ${
          currentPatchPage + 1
        } / ${allPatchPages.length}`;
      }

      // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
      document.getElementById("prevPage").onclick = () =>
        showPatchPage(currentPatchPage - 1);
      document.getElementById("nextPage").onclick = () =>
        showPatchPage(currentPatchPage + 1);

      document.getElementById("downloadVoids").onclick = () => {
        if (!voidRecords.length) {
          alert("No voids recorded.");
          return;
        }
        const blob = new Blob([JSON.stringify(voidRecords, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "void_records.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      // ìˆ«ìí‚¤ â†’ íƒ€ì…
      const voidKeyMap = {
        1: "void",
        2: "crack",
        3: "particle",
      };
      const typeSelect = document.getElementById("voidTypeSelect");

      // ìˆ«ì í‚¤ ëˆŒë €ì„ ë•Œ íƒ€ì… ë³€ê²½
      document.addEventListener("keydown", (e) => {
        if (!voidMarkMode) return; // ë§ˆí‚¹ ëª¨ë“œì¼ ë•Œë§Œ
        const newType = voidKeyMap[e.key];
        if (newType) {
          typeSelect.value = newType; // ë“œë¡­ë‹¤ìš´ë„ ì—…ë°ì´íŠ¸
          console.log(`Void type set to: ${newType}`);
        }
      });
    </script>
  </body>
</html>
