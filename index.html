<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
      }
      #left {
        width: 260px;
        padding: 10px;
        background: #eee;
        overflow-y: auto;
      }
      #center {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #333;
      }
      #right {
        width: 320px;
        overflow-y: auto;
        background: #111;
        color: #fff;
        padding: 10px;
      }
      canvas {
        max-width: 100%;
        height: auto;
        cursor: grab;
      }
      canvas.dragging {
        cursor: grabbing;
      }
      .patch {
        margin-bottom: 10px;
      }
      textarea {
        width: 100%;
        height: 80px;
      }
      .refMode {
        background: #ff8;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        height: auto;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        border: 1px solid #555;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <label
        >Multi-page TIFF
        <input id="tiffFile" type="file" accept=".tif,.tiff" /> </label
      ><br /><br />

      <label>Chip CSV (파일 또는 엑셀복붙)</label>
      <input id="csvFile" type="file" accept=".csv" /><br />
      <textarea
        id="csvPaste"
        placeholder="엑셀에서 복사 후 붙여넣기 (x,y,type)"
      ></textarea
      ><br /><br />

      <label
        >Page:
        <select id="pageSelect"></select> </label
      ><br /><br />

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br /><br />

      <h3>Reference</h3>
      기준 X <input id="refX" type="number" value="0" /><br />
      기준 Y <input id="refY" type="number" value="0" /><br />
      <button id="setRefBtn">Set Reference</button><br /><br />

      <h3>Enhance</h3>
      Contrast α <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness β <input id="beta" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <h3>Patches</h3>
      <div id="patches"></div>
    </div>

    <script type="module">
      import UTIF from "https://cdn.skypack.dev/utif";

      const waferCanvas = document.getElementById("wafer");
      const waferCtx = waferCanvas.getContext("2d");

      const pageSelect = document.getElementById("pageSelect");
      let pages = [];
      let pageIndex = 0;
      let origin = { x: 50, y: 50 };
      let csvRows = [];
      let refGrid = { x: 0, y: 0 }; // 사용자가 지정한 기준 grid index
      let refMode = false;
      let currentScale = 1;

      // === UI 엘리먼트 ===
      const tiffInput = document.getElementById("tiffFile");
      const csvInput = document.getElementById("csvFile");
      const csvPaste = document.getElementById("csvPaste");
      const colsInput = document.getElementById("cols");
      const rowsInput = document.getElementById("rows");
      const cellWInput = document.getElementById("cellW");
      const cellHInput = document.getElementById("cellH");
      const alphaInput = document.getElementById("alpha");
      const betaInput = document.getElementById("beta");
      const extractBtn = document.getElementById("extractBtn");
      const patchesDiv = document.getElementById("patches");
      const refXInput = document.getElementById("refX");
      const refYInput = document.getElementById("refY");
      const setRefBtn = document.getElementById("setRefBtn");

      // ===== TIFF 로드 =====
      async function loadTiff(file) {
        const buf = await file.arrayBuffer();
        const ifds = UTIF.decode(buf);
        ifds.forEach((ifd) => UTIF.decodeImage(buf, ifd));
        pages = ifds.map((ifd) => {
          const rgba = UTIF.toRGBA8(ifd);
          const c = document.createElement("canvas");
          c.width = ifd.width;
          c.height = ifd.height;
          c.getContext("2d").putImageData(
            new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height),
            0,
            0
          );
          return c;
        });

        // 페이지 선택 UI 갱신
        pageSelect.innerHTML = pages
          .map((_, i) => `<option value=\"${i}\">Page ${i + 1}</option>`)
          .join("");
        pageIndex = 0;
        drawPage();
      }

      function drawPage() {
        const src = pages[pageIndex];
        if (!src) return; // 혹시라도 undefined일 경우 대비

        const MAX_SIZE = 512; // 브라우저 안전 범위
        const scale = Math.min(1, MAX_SIZE / Math.max(src.width, src.height));
        const drawW = Math.round(src.width * scale);
        const drawH = Math.round(src.height * scale);

        waferCanvas.width = drawW;
        waferCanvas.height = drawH;
        waferCtx.drawImage(src, 0, 0, drawW, drawH);

        // 그리드 위치/크기 스케일도 같이 적용
        currentScale = scale;
        drawGrid();
      }

      pageSelect.addEventListener("change", (e) => {
        pageIndex = e.target.value;
        drawPage();
      });

      function drawGrid() {
        if (!pages.length) return;
        const scale = currentScale || 1;
        const cols = +colsInput.value;
        const rows = +rowsInput.value;
        const cellW = +cellWInput.value * scale;
        const cellH = +cellHInput.value * scale;
        waferCtx.strokeStyle = "lime";
        for (let i = 0; i <= cols; i++) {
          const x = origin.x + i * cellW;
          waferCtx.beginPath();
          waferCtx.moveTo(x, origin.y);
          waferCtx.lineTo(x, origin.y + rows * cellH);
          waferCtx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          const y = origin.y + j * cellH;
          waferCtx.beginPath();
          waferCtx.moveTo(origin.x, y);
          waferCtx.lineTo(origin.x + cols * cellW, y);
          waferCtx.stroke();
        }
        // 기준점 시각화
        waferCtx.fillStyle = "red";
        const refPixelX = origin.x + refGrid.x * cellW + cellW / 2;
        const refPixelY = origin.y + refGrid.y * cellH + cellH / 2;
        waferCtx.beginPath();
        waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
        waferCtx.fill();
      }

      // CSV/엑셀 파싱 (탭·콤마 지원)
      function parseCSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split(/[\t,]+/).map((h) => h.toLowerCase());
        const xi = header.indexOf("x"),
          yi = header.indexOf("y"),
          ti = header.indexOf("type");
        if (xi === -1 || yi === -1) {
          alert("x,y 헤더가 필요합니다.");
          return [];
        }
        const out = [];
        lines.slice(1).forEach((l) => {
          if (!l.trim()) return;
          const c = l.split(/[\t,]+/);
          const x = parseFloat(c[xi]);
          const y = parseFloat(c[yi]);
          if (isNaN(x) || isNaN(y)) return;
          out.push({ x, y, type: ti >= 0 && c[ti] ? c[ti] : "" });
        });
        return out;
      }

      // 밝기/대비
      function adjust(ctx) {
        const img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const a = +alphaInput.value,
          b = +betaInput.value;
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = Math.min(255, Math.max(0, d[i] * a + b));
          d[i + 1] = Math.min(255, Math.max(0, d[i + 1] * a + b));
          d[i + 2] = Math.min(255, Math.max(0, d[i + 2] * a + b));
        }
        ctx.putImageData(img, 0, 0);
      }

      // === 이벤트 ===
      tiffInput.onchange = (e) => {
        if (e.target.files[0]) loadTiff(e.target.files[0]);
      };
      csvInput.onchange = async (e) => {
        if (e.target.files[0])
          csvRows = parseCSV(await e.target.files[0].text());
      };
      csvPaste.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        csvRows = parseCSV(text);
        alert(`복붙한 ${csvRows.length}개의 chip 좌표 로드 완료`);
      });
      [colsInput, rowsInput, cellWInput, cellHInput].forEach((el) =>
        el.addEventListener("input", drawPage)
      );

      // 드래그로 origin 이동
      let dragging = false;
      let start = { x: 0, y: 0 };
      waferCanvas.addEventListener("mousedown", (e) => {
        if (refMode) return; // 참조모드일 때는 드래그금지
        dragging = true;
        waferCanvas.classList.add("dragging");
        start.x = e.clientX;
        start.y = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        waferCanvas.classList.remove("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        origin.x += e.clientX - start.x;
        origin.y += e.clientY - start.y;
        start.x = e.clientX;
        start.y = e.clientY;
        drawPage();
      });

      // 🟥 기준점 설정 모드
      setRefBtn.onclick = () => {
        refMode = !refMode;
        setRefBtn.classList.toggle("refMode", refMode);
        setRefBtn.textContent = refMode ? "Click Grid to Set" : "Set Reference";
      };

      // 그리드 클릭 → 참조 설정
      waferCanvas.addEventListener("click", (e) => {
        if (!refMode) return;
        const rect = waferCanvas.getBoundingClientRect();
        const clickX =
          ((e.clientX - rect.left) * waferCanvas.width) / rect.width;
        const clickY =
          ((e.clientY - rect.top) * waferCanvas.height) / rect.height;
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const gx = Math.floor((clickX - origin.x) / cellW);
        const gy = Math.floor((clickY - origin.y) / cellH);
        refGrid = { x: gx, y: gy };
        refXInput.value = gx;
        refYInput.value = gy;
        refMode = false;
        setRefBtn.classList.remove("refMode");
        setRefBtn.textContent = "Set Reference";
        drawPage();
      });

      extractBtn.onclick = () => {
        if (!pages.length || !csvRows.length) return;

        patchesDiv.innerHTML = "";
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        window.allPatchCanvases = []; // ZIP 저장용

        csvRows.forEach((r) => {
          const coordWrap = document.createElement("div");
          coordWrap.className = "coord-card";
          coordWrap.innerHTML = `<h4 class="coord-title">Chip (${r.x}, ${r.y})</h4>`;
          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          pages.forEach((src, pageIdx) => {
            const gx = origin.x + (r.x + refGrid.x) * cellW;
            const gy = origin.y + (r.y + refGrid.y) * cellH;

            // ---- 타이틀용 캔버스 (위쪽 30px 여백) ----
            const titleH = 30;
            const c = document.createElement("canvas");
            c.width = cellW;
            c.height = cellH + titleH;
            const ctx = c.getContext("2d");

            // 상단 배경(타이틀 바) 칠하기
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cellW, titleH);

            // 타이틀 텍스트
            const label = `X${String(r.x).padStart(2, "0")}_Y${String(
              r.y
            ).padStart(2, "0")}_L${String(pageIdx + 1).padStart(2, "0")}`;
            ctx.fillStyle = "#fff";
            ctx.font = "20px sans-serif";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 6, titleH / 2);

            // 실제 패치 이미지를 타이틀 아래에 그리기
            ctx.drawImage(src, gx, gy, cellW, cellH, 0, titleH, cellW, cellH);
            adjust(ctx); // 밝기/대비 조정 전체에 적용

            // ---- 브라우저 뷰어에 추가 ----
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label">${label}</div>`;
            item.appendChild(c);
            layersWrap.appendChild(item);

            // ZIP 저장용
            window.allPatchCanvases.push({
              canvas: c,
              layer: pageIdx + 1,
              label,
            });
          });

          coordWrap.appendChild(layersWrap);
          patchesDiv.appendChild(coordWrap);
        });
      };

      document.getElementById("downloadZipBtn").onclick = () => {
        if (!window.allPatchCanvases || !window.allPatchCanvases.length) {
          alert("먼저 Extract Patches를 실행하세요.");
          return;
        }

        const zip = new JSZip();

        window.allPatchCanvases.forEach((p) => {
          // 레이어별 폴더
          const folder = zip.folder(
            `layer_${String(p.layer).padStart(2, "0")}`
          );
          const dataURL = p.canvas.toDataURL("image/png").split(",")[1]; // base64
          folder.file(`${p.label}.png`, dataURL, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then((content) => {
          saveAs(content, "wafer_patches.zip");
        });
      };
    </script>
  </body>
</html>
