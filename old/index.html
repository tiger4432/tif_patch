<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
      }
      #left {
        width: 260px;
        padding: 10px;
        background: #eee;
        overflow-y: auto;
      }
      #center {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #333;
      }
      #right {
        width: 320px;
        overflow-y: auto;
        background: #111;
        color: #fff;
        padding: 10px;
      }
      canvas {
        max-width: 100%;
        height: auto;
        cursor: grab;
      }
      canvas.dragging {
        cursor: grabbing;
      }
      .patch {
        margin-bottom: 10px;
      }
      textarea {
        width: 100%;
        height: 80px;
      }
      .refMode {
        background: #ff8;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        height: auto;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .mode-on {
        background-color: #28a745; /* ì´ˆë¡ìƒ‰ */
        color: white;
        font-weight: bold;
      }

      #topControls {
        position: sticky;
        top: 0; /* í™”ë©´ ìµœìƒë‹¨ ê³ ì • */
        z-index: 1000; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œ */
        background: #222; /* ë°°ê²½ìƒ‰, ìŠ¤í¬ë¡¤ ì‹œ ë‚´ìš©ì´ ë¹„ì¹˜ì§€ ì•Šê²Œ */
        padding: 10px;
      }

      #voidControls {
        padding: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      
      #voidControls button {
        padding: 6px 12px;
        border: 1px solid #555;
        background: #333;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      #voidControls button:hover {
        background: #444;
        border-color: #666;
      }
      
      #voidControls select {
        padding: 6px;
        background: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <label
        >Multi-page TIFF
        <input id="tiffFile" type="file" accept=".tif,.tiff" /> </label
      ><br /><br />

      <label>Chip CSV (íŒŒì¼ ë˜ëŠ” ì—‘ì…€ë³µë¶™)</label>
      <input id="csvFile" type="file" accept=".csv" /><br />
      <textarea
        id="csvPaste"
        placeholder="ì—‘ì…€ì—ì„œ ë³µì‚¬ í›„ ë¶™ì—¬ë„£ê¸° (x,y,type)"
      ></textarea
      ><br /><br />

      <label
        >Page:
        <select id="pageSelect"></select> </label
      ><br /><br />

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br /><br />

      <h3>Reference</h3>
      ê¸°ì¤€ X <input id="refX" type="number" value="0" /><br />
      ê¸°ì¤€ Y <input id="refY" type="number" value="0" /><br />
      <button id="setRefBtn">Set Reference</button><br /><br />

      <h3>Enhance</h3>
      Contrast Î± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Î² <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
      <button id="debugBtn">Debug Check</button>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <h3>Patches</h3>
      <div id="topControls">
        <div id="voidControls">
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <option value="void">void</option>
            <option value="crack">crack</option>
            <option value="particle">particle</option>
          </select>
          <button id="toggleSyncMode">Sync Layers</button>
          <button id="mergeVoids">Merge All</button>
          <button id="downloadVoids">Download Voids JSON</button>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">â—€ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next â–¶</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>

    <script type="module">
      import UTIF from "https://cdn.skypack.dev/utif";

      const waferCanvas = document.getElementById("wafer");
      const waferCtx = waferCanvas.getContext("2d");

      const pageSelect = document.getElementById("pageSelect");
      let pages = [];
      let pageIndex = 0;
      let origin = { x: 50, y: 50 };
      let csvRows = [];
      let refGrid = { x: 0, y: 0 }; // ì‚¬ìš©ìê°€ ì§€ì •í•œ ê¸°ì¤€ grid index
      let refMode = false;
      let currentScale = 1;
      let chipPoints = []; // ğŸ”µ íŒŒë€ì  ì¢Œí‘œ ì €ì¥
      let voidMarkMode = false;
      let voidRecords = []; // [{patchLabel, chipCoord, layer, type, centerX, centerY, radiusX, radiusY, id}]
      let deleteVoidMode = false;
      let selectedVoid = null;
      let resizeMode = false;
      let voidSyncMode = true; // ë ˆì´ì–´ ê°„ ë³´ì´ë“œ ë™ê¸°í™” ëª¨ë“œ
      let voidIdCounter = 0;
      let syncThrottleTimer = null; // ë™ê¸°í™” throttlingìš© íƒ€ì´ë¨¸
      let voidGroupCounter = 0; // ë³´ì´ë“œ ê·¸ë£¹ ID ì¹´ìš´í„°

      const markBtn = document.getElementById("toggleVoidMode");
      const deleteBtn = document.getElementById("toggleDeleteMode");

      document.getElementById("toggleVoidMode").onclick = () => {
        voidMarkMode = !voidMarkMode;
        markBtn.classList.toggle("mode-on", voidMarkMode); // ONì´ë©´ ì´ˆë¡ìƒ‰
      };

      document.getElementById("toggleDeleteMode").onclick = () => {
        deleteVoidMode = !deleteVoidMode;
        deleteBtn.classList.toggle("mode-on", deleteVoidMode);
      };

      // ë ˆì´ì–´ ë™ê¸°í™” ëª¨ë“œ í† ê¸€
      const syncBtn = document.getElementById("toggleSyncMode");
      syncBtn.classList.toggle("mode-on", voidSyncMode);
      document.getElementById("toggleSyncMode").onclick = () => {
        voidSyncMode = !voidSyncMode;
        syncBtn.classList.toggle("mode-on", voidSyncMode);
        // í˜„ì¬ ë³´ì´ëŠ” íŒ¨ì¹˜ë“¤ì„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        refreshCurrentPatches();
      };

      // ì¹©ë³„ ë³´ì´ë“œ ë¨¸ì§€
      document.getElementById("mergeVoids").onclick = () => {
        mergeChipVoids();
        alert("All chip voids have been merged across layers!");
        refreshCurrentPatches();
      };

      // ë””ë²„ê·¸ ì²´í¬ ë²„íŠ¼
      document.getElementById("debugBtn").onclick = () => {
        console.log("=== DEBUG CHECK ===");
        console.log("Pages loaded:", pages.length);
        console.log("CSV rows:", csvRows.length);
        console.log("CSV data sample:", csvRows.slice(0, 5));
        console.log("Chip points:", chipPoints.slice(0, 5));
        console.log("Reference grid:", refGrid);
        console.log("Current scale:", currentScale);
        console.log("Origin:", origin);
        
        alert(`Debug Info:
Pages: ${pages.length}
CSV Rows: ${csvRows.length}
Chip Points: ${chipPoints.length}
Check console for details.`);
      };
      // === UI ì—˜ë¦¬ë¨¼íŠ¸ ===
      const tiffInput = document.getElementById("tiffFile");
      const csvInput = document.getElementById("csvFile");
      const csvPaste = document.getElementById("csvPaste");
      const colsInput = document.getElementById("cols");
      const rowsInput = document.getElementById("rows");
      const cellWInput = document.getElementById("cellW");
      const cellHInput = document.getElementById("cellH");
      const alphaInput = document.getElementById("alpha");
      const betaInput = document.getElementById("beta");
      const extractBtn = document.getElementById("extractBtn");
      const patchesDiv = document.getElementById("patches");
      const refXInput = document.getElementById("refX");
      const refYInput = document.getElementById("refY");
      const setRefBtn = document.getElementById("setRefBtn");

      // ===== TIFF ë¡œë“œ =====
      async function loadTiff(file) {
        console.log("Loading TIFF file:", file.name);
        try {
          const buf = await file.arrayBuffer();
          console.log("TIFF buffer size:", buf.byteLength);
          const ifds = UTIF.decode(buf);
          console.log("TIFF pages found:", ifds.length);
          ifds.forEach((ifd) => UTIF.decodeImage(buf, ifd));
          pages = ifds.map((ifd) => {
          const rgba = UTIF.toRGBA8(ifd);
          const c = document.createElement("canvas");
          c.width = ifd.width;
          c.height = ifd.height;
          c.getContext("2d").putImageData(
            new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height),
            0,
            0
          );
          return c;
        });

        // í˜ì´ì§€ ì„ íƒ UI ê°±ì‹ 
        pageSelect.innerHTML = pages
          .map((_, i) => `<option value=\"${i}\">Page ${i + 1}</option>`)
          .join("");
        pageIndex = 0;
        console.log("TIFF loaded successfully, pages:", pages.length);
        drawPage();
        } catch (error) {
          console.error("TIFF loading failed:", error);
          alert("TIFF íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: " + error.message);
        }
      }

      function drawPage() {
        const src = pages[pageIndex];
        if (!src) return; // í˜¹ì‹œë¼ë„ undefinedì¼ ê²½ìš° ëŒ€ë¹„

        const MAX_SIZE = 1024; // ë¸Œë¼ìš°ì € ì•ˆì „ ë²”ìœ„
        const scale = Math.min(1, MAX_SIZE / Math.max(src.width, src.height));
        const drawW = Math.round(src.width * scale);
        const drawH = Math.round(src.height * scale);

        waferCanvas.width = drawW;
        waferCanvas.height = drawH;
        waferCtx.drawImage(src, 0, 0, drawW, drawH);

        // ê·¸ë¦¬ë“œ ìœ„ì¹˜/í¬ê¸° ìŠ¤ì¼€ì¼ë„ ê°™ì´ ì ìš©
        currentScale = scale;
        drawGrid();
      }

      pageSelect.addEventListener("change", (e) => {
        pageIndex = e.target.value;
        drawPage();
      });

      function parseBondingMap(text) {
        console.log("Parsing bonding map, text length:", text.length);
        console.log("Text preview:", text.substring(0, 200));
        
        const lines = text.trimEnd().split(/\r?\n/);
        console.log("Lines found:", lines.length);
        
        if (lines.length < 2) {
          console.log("Not enough lines for bonding map");
          return [];
        }

        // ì²« í–‰: X í—¤ë” (ë¹ˆ ë¬¸ìì—´ë„ ìœ ì§€)
        const xHeaders = lines[0]
          .split("\t")
          .slice(1)
          .map((h) => h.trim())
          .map((h) => parseInt(h, 10));
        console.log("X headers:", xHeaders);

        const out = [];
        for (let r = 1; r < lines.length; r++) {
          // í–‰ ì „ì²´ë¥¼ íƒ­ ê¸°ì¤€ìœ¼ë¡œ ê·¸ëŒ€ë¡œ split â†’ ëì˜ ë¹ˆ ì¹¸ë„ ìœ ì§€
          const cells = lines[r].split("\t");
          if (cells.length < 2) continue;

          const y = parseInt((cells[0] || "").trim(), 10);
          if (isNaN(y)) continue;

          // xHeaders ê¸¸ì´ì— ë§ê²Œ ìˆœíšŒ
          for (let c = 1; c <= xHeaders.length; c++) {
            const val = (cells[c] || "").trim();
            if (!val) continue;
            const x = xHeaders[c - 1];
            if (!isNaN(x)) out.push({ x, y, type: val });
          }
        }
        console.log("Parsed bonding map result:", out);
        console.log("Total coordinates found:", out.length);
        return out;
      }

      function drawGrid() {
        if (!pages.length) return;
        const cols = +colsInput.value;
        const rows = +rowsInput.value;
        const cellW = +cellWInput.value * currentScale;
        const cellH = +cellHInput.value * currentScale;

        waferCtx.strokeStyle = "lime";
        for (let i = 0; i <= cols; i++) {
          const x = origin.x + i * cellW;
          waferCtx.beginPath();
          waferCtx.moveTo(x, origin.y);
          waferCtx.lineTo(x, origin.y + rows * cellH);
          waferCtx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          const y = origin.y + j * cellH;
          waferCtx.beginPath();
          waferCtx.moveTo(origin.x, y);
          waferCtx.lineTo(origin.x + cols * cellW, y);
          waferCtx.stroke();
        }

        // ğŸ”µ CSV ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ íŒŒë€ ì  í‘œì‹œ
        waferCtx.fillStyle = "deepskyblue";
        chipPoints.forEach((pt) => {
          const px = origin.x + (pt.x + refGrid.x + 0.5) * cellW;
          const py = origin.y + (pt.y + refGrid.y + 0.5) * cellH;
          waferCtx.beginPath();
          waferCtx.arc(px, py, Math.max(3, cellW * 0.05), 0, 2 * Math.PI);
          waferCtx.fill();
        });

        // ğŸ”´ ê¸°ì¤€ì (Reference) ë¹¨ê°„ ì 
        waferCtx.fillStyle = "red";
        const refPixelX = origin.x + refGrid.x * cellW + cellW / 2;
        const refPixelY = origin.y + refGrid.y * cellH + cellH / 2;
        waferCtx.beginPath();
        waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
        waferCtx.fill();
      }

      // CSV/ì—‘ì…€ íŒŒì‹± (íƒ­Â·ì½¤ë§ˆ ì§€ì›)
      function parseCSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split(/[\t,]+/).map((h) => h.toLowerCase());
        const xi = header.indexOf("x"),
          yi = header.indexOf("y"),
          ti = header.indexOf("type");
        if (xi === -1 || yi === -1) {
          alert("x,y í—¤ë”ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
          return [];
        }
        const out = [];
        lines.slice(1).forEach((l) => {
          if (!l.trim()) return;
          const c = l.split(/[\t,]+/);
          const x = parseFloat(c[xi]);
          const y = parseFloat(c[yi]);
          if (isNaN(x) || isNaN(y)) return;
          out.push({ x, y, type: ti >= 0 && c[ti] ? c[ti] : "" });
        });
        return out;
      }

      // ë°ê¸°/ëŒ€ë¹„
      function adjust(ctx) {
        const img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const a = +alphaInput.value,
          b = +betaInput.value;
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = Math.min(255, Math.max(0, d[i] * a + b));
          d[i + 1] = Math.min(255, Math.max(0, d[i + 1] * a + b));
          d[i + 2] = Math.min(255, Math.max(0, d[i + 2] * a + b));
        }
        ctx.putImageData(img, 0, 0);
      }

      function enhanceToTarget(
        ctx,
        targetMean = 0.5,
        targetStd = 0.2,
        pad = 10
      ) {
        const { width, height } = ctx.canvas;
        const imgData = ctx.getImageData(0, 0, width, height);
        const d = imgData.data;

        // ROI : padding ì•ˆìª½
        const roiPixels = [];
        for (let y = pad; y < height - pad; y++) {
          for (let x = pad; x < width - pad; x++) {
            const idx = (y * width + x) * 4;
            // grayscale = average RGB
            const g = (d[idx] + d[idx + 1] + d[idx + 2]) / (3 * 255);
            roiPixels.push(g);
          }
        }
        const mean = roiPixels.reduce((a, b) => a + b, 0) / roiPixels.length;
        const std =
          Math.sqrt(
            roiPixels.reduce((a, b) => a + (b - mean) ** 2, 0) /
              roiPixels.length
          ) || 1e-6;

        // ë³´ì •: (v - mean)/std -> target
        const scale = targetStd / std;
        const offset = targetMean - mean * scale;

        for (let i = 0; i < d.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            let v = d[i + c] / 255;
            v = v * scale + offset;
            v = Math.min(1, Math.max(0, v));
            d[i + c] = v * 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      const voidColors = {
        void: "cyan",
        crack: "magenta",
        particle: "lime",
        default: "yellow", // ë¯¸ì§€ì • íƒ€ì…
      };
      function attachVoidEvents(canvas, patchLabel, imageData) {
        const ctx = canvas.getContext("2d");

        canvas.addEventListener("mousedown", (e) => {
          if (!voidMarkMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const startX = (e.clientX - rect.left) * scaleX;
          const startY = (e.clientY - rect.top) * scaleY;

          const dragHandler = (me) => {
            const curX = (me.clientX - rect.left) * scaleX;
            const curY = (me.clientY - rect.top) * scaleY;
            // íƒ€ì…ë³„ ìƒ‰ìƒ ë§µ

            ctx.putImageData(imageData, 0, 0);
            const selType =
              document.getElementById("voidTypeSelect").value || "default";
            ctx.strokeStyle = voidColors[selType] || voidColors.default;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(
              (startX + curX) / 2,
              (startY + curY) / 2,
              Math.abs(curX - startX) / 2,
              Math.abs(curY - startY) / 2,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          };

          const upHandler = (ue) => {
            document.removeEventListener("mousemove", dragHandler);
            document.removeEventListener("mouseup", upHandler);
            const endX = (ue.clientX - rect.left) * scaleX;
            const endY = (ue.clientY - rect.top) * scaleY;

            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            const radiusX = Math.abs(endX - startX) / 2;
            const radiusY = Math.abs(endY - startY) / 2;

            const type =
              document.getElementById("voidTypeSelect").value || "void";
            
            // íŒ¨ì¹˜ ë¼ë²¨ì—ì„œ ì¹© ì¢Œí‘œì™€ ë ˆì´ì–´ ì •ë³´ ì¶”ì¶œ
            const { chipCoord, layer } = parsePatchLabel(patchLabel);
            
            const groupId = ++voidGroupCounter;
            const newVoid = {
              id: ++voidIdCounter,
              groupId: groupId,
              patchLabel,
              chipCoord,
              layer,
              type,
              centerX,
              centerY,
              radiusX,
              radiusY,
            };
            
            voidRecords.push(newVoid);

            // ë™ê¸°í™” ëª¨ë“œê°€ ì¼œì ¸ìˆìœ¼ë©´ ê°™ì€ ì¹©ì˜ ë‹¤ë¥¸ ë ˆì´ì–´ì—ë„ ë³´ì´ë“œ í‘œì‹œ
            if (voidSyncMode) {
              syncVoidToAllLayers(newVoid);
            }

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
          };

          document.addEventListener("mousemove", dragHandler);
          document.addEventListener("mouseup", upHandler);
        });

        canvas.addEventListener("click", (e) => {
          if (!deleteVoidMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // í´ë¦­í•œ ì ì„ í¬í•¨í•˜ëŠ” ë³´ì´ë“œ ì°¾ê¸°
          let removed = false;
          voidRecords = voidRecords.filter((v) => {
            if (v.patchLabel !== patchLabel) return true;
            // íƒ€ì› ì•ˆì— ë“¤ì–´ê°€ë©´ ì‚­ì œ
            const dx = (x - v.centerX) / v.radiusX;
            const dy = (y - v.centerY) / v.radiusY;
            const inside = dx * dx + dy * dy <= 1;
            if (inside && !removed) {
              removed = true;
              return false; // ì‚­ì œ
            }
            return true;
          });

          if (removed) {
            ctx.putImageData(imageData, 0, 0); // ì›ë³¸ ë³µì›
            drawAllVoids(ctx, patchLabel); // ë‚¨ì€ ë³´ì´ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            
            // ë™ê¸°í™” ëª¨ë“œì¼ ë•Œ ë‹¤ë¥¸ ë ˆì´ì–´ë“¤ë„ ìƒˆë¡œê³ ì¹¨
            if (voidSyncMode) {
              refreshCurrentPatches();
            }
          }
        });

        canvas.addEventListener("mousedown", (e) => {
          if (voidMarkMode || deleteVoidMode) return;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          selectedVoid = voidRecords.find(
            (v) =>
              v.patchLabel === patchLabel &&
              (() => {
                const dx = x - v.centerX;
                const dy = y - v.centerY;
                const angle = Math.atan2(dy, dx);
                const rB =
                  (v.radiusX * v.radiusY) /
                  Math.sqrt(
                    (v.radiusY * Math.cos(angle)) ** 2 +
                      (v.radiusX * Math.sin(angle)) ** 2
                  );
                const dist = Math.hypot(dx, dy);
                return dist <= rB + 8; // 8px ì˜¤ì°¨ í—ˆìš©
              })()
          );

          if (!selectedVoid) return;

          // ì´ë™/ë¦¬ì‚¬ì´ì¦ˆ êµ¬ë¶„
          const dx = x - selectedVoid.centerX;
          const dy = y - selectedVoid.centerY;
          const angle = Math.atan2(dy, dx);
          const rB =
            (selectedVoid.radiusX * selectedVoid.radiusY) /
            Math.sqrt(
              (selectedVoid.radiusY * Math.cos(angle)) ** 2 +
                (selectedVoid.radiusX * Math.sin(angle)) ** 2
            );
          const dist = Math.hypot(dx, dy);
          const tol = 8;

          resizeMode = Math.abs(dist - rB) <= tol;

          const offsetX = x - selectedVoid.centerX;
          const offsetY = y - selectedVoid.centerY;

          const moveHandler = (me) => {
            const mx = (me.clientX - rect.left) * scaleX;
            const my = (me.clientY - rect.top) * scaleY;

            if (resizeMode) {
              // Shift ëˆ„ë¥´ë©´ ë¹„ìœ¨ ìœ ì§€
              const dx = Math.abs(mx - selectedVoid.centerX);
              const dy = Math.abs(my - selectedVoid.centerY);
              if (me.shiftKey) {
                const r = Math.max(dx, dy);
                selectedVoid.radiusX = selectedVoid.radiusY = r;
              } else {
                selectedVoid.radiusX = dx;
                selectedVoid.radiusY = dy;
              }
            } else {
              // ì´ë™
              selectedVoid.centerX = mx - offsetX;
              selectedVoid.centerY = my - offsetY;
            }

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
            
            // ì‹¤ì‹œê°„ ë™ê¸°í™” (throttled)
            throttledSyncRefresh();
          };

          const upHandler = () => {
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
            
            // void ì´ë™/í¬ê¸° ì¡°ì ˆ ì™„ë£Œ í›„ ë‹¤ë¥¸ ë ˆì´ì–´ì˜ ë™ì¼í•œ ë³´ì´ë“œ ì—…ë°ì´íŠ¸
            if (voidSyncMode && selectedVoid) {
              updateSyncedVoids(selectedVoid);
              refreshCurrentPatches();
            }
            
            selectedVoid = null;
          };

          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
        });
      }

      // íŠ¹ì • íŒ¨ì¹˜ì— ì €ì¥ëœ ëª¨ë“  ë³´ì´ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      function drawAllVoids(ctx, patchLabel) {
        ctx.lineWidth = 2;
        
        // í˜„ì¬ íŒ¨ì¹˜ì˜ ì¹© ì¢Œí‘œ ë° ë ˆì´ì–´ ì •ë³´ ì¶”ì¶œ
        const { chipCoord, layer } = parsePatchLabel(patchLabel);
        
        // í˜„ì¬ ë ˆì´ì–´ì˜ ë³´ì´ë“œ (ì‹¤ì„ )
        voidRecords
          .filter((v) => v.patchLabel === patchLabel)
          .forEach((v) => {
            ctx.beginPath();
            const color = voidColors[v.type] || voidColors.default;
            ctx.strokeStyle = color;
            ctx.setLineDash([]); // ì‹¤ì„ 
            ctx.ellipse(
              v.centerX,
              v.centerY,
              v.radiusX,
              v.radiusY,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          });

        // ë™ê¸°í™” ëª¨ë“œì¼ ë•Œ ë‹¤ë¥¸ ë ˆì´ì–´ì˜ ë³´ì´ë“œ (ì ì„ )
        if (voidSyncMode) {
          const otherLayerVoids = voidRecords.filter((v) => v.chipCoord === chipCoord && v.layer !== layer);
          
          otherLayerVoids.forEach((v) => {
              ctx.beginPath();
              const color = voidColors[v.type] || voidColors.default;
              ctx.strokeStyle = color;
              ctx.globalAlpha = 0.5; // ë°˜íˆ¬ëª…
              ctx.setLineDash([5, 5]); // ì ì„ 
              ctx.ellipse(
                v.centerX,
                v.centerY,
                v.radiusX,
                v.radiusY,
                0,
                0,
                2 * Math.PI
              );
              ctx.stroke();
              ctx.globalAlpha = 1.0; // íˆ¬ëª…ë„ ë³µì›
              ctx.setLineDash([]); // ì„  ìŠ¤íƒ€ì¼ ë³µì›
            });
        }
      }

      // íŒ¨ì¹˜ ë¼ë²¨ì—ì„œ ì¹© ì¢Œí‘œì™€ ë ˆì´ì–´ ì¶”ì¶œ
      function parsePatchLabel(patchLabel) {
        // ì˜ˆ: "XN05_Y07_L03_LEG:good" -> chipCoord: "(-5,7)", layer: 3
        // ì˜ˆ: "X05_YN07_L03_LEG:good" -> chipCoord: "(5,-7)", layer: 3
        const match = patchLabel.match(/X(N?)(\d+)_Y(N?)(\d+)_L(\d+)/);
        if (match) {
          const xNegative = match[1] === 'N';
          const xValue = parseInt(match[2], 10);
          const yNegative = match[3] === 'N';
          const yValue = parseInt(match[4], 10);
          const layer = parseInt(match[5], 10);
          
          const actualX = xNegative ? -xValue : xValue;
          const actualY = yNegative ? -yValue : yValue;
          
          return { 
            chipCoord: `(${actualX},${actualY})`, 
            layer: layer 
          };
        }
        return { chipCoord: "unknown", layer: 1 };
      }

      // ê°™ì€ ì¹©ì˜ ëª¨ë“  ë ˆì´ì–´ì— ë³´ì´ë“œ ë™ê¸°í™”
      function syncVoidToAllLayers(newVoid) {
        if (!newVoid || !voidSyncMode) return;
        
        // í˜„ì¬ ë³´ì´ëŠ” ì¹©ì˜ ëª¨ë“  ë ˆì´ì–´ì— ë™ì¼í•œ ë³´ì´ë“œ ìƒì„±
        if (allPatchPages.length > 0 && currentPatchPage < allPatchPages.length) {
          const currentPage = allPatchPages[currentPatchPage];
          const currentChipCoord = currentPage.coord;
          
          // ê°™ì€ ì¹©ì˜ ë‹¤ë¥¸ ë ˆì´ì–´ë“¤ì— ë³´ì´ë“œ ì¶”ê°€
          currentPage.layers.forEach(layerInfo => {
            if (layerInfo.label === newVoid.patchLabel) return; // ì›ë³¸ ë ˆì´ì–´ëŠ” ì œì™¸
            
            // ì´ë¯¸ ê°™ì€ ê·¸ë£¹ì˜ ë³´ì´ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
            const existingVoid = voidRecords.find(v => 
              v.patchLabel === layerInfo.label && 
              v.groupId === newVoid.groupId
            );
            
            if (!existingVoid) {
              // ìƒˆë¡œìš´ ì—°ê²°ëœ ë³´ì´ë“œ ìƒì„±
              const { chipCoord, layer } = parsePatchLabel(layerInfo.label);
              const syncedVoid = {
                id: ++voidIdCounter,
                groupId: newVoid.groupId, // ê°™ì€ ê·¸ë£¹ ID ì‚¬ìš©
                patchLabel: layerInfo.label,
                chipCoord: chipCoord,
                layer: layer,
                type: newVoid.type,
                centerX: newVoid.centerX,
                centerY: newVoid.centerY,
                radiusX: newVoid.radiusX,
                radiusY: newVoid.radiusY,
              };
              
              voidRecords.push(syncedVoid);
            }
          });
        }
        
        // í˜„ì¬ í˜ì´ì§€ì˜ ëª¨ë“  íŒ¨ì¹˜ë“¤ì„ ìƒˆë¡œê³ ì¹¨
        refreshCurrentPatches();
      }

      // í˜„ì¬ ë³´ì´ëŠ” íŒ¨ì¹˜ë“¤ì„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      function refreshCurrentPatches() {
        if (!allPatchPages.length || currentPatchPage >= allPatchPages.length) return;
        
        const currentPage = allPatchPages[currentPatchPage];
        currentPage.layers.forEach(layerInfo => {
          const ctx = layerInfo.canvas.getContext('2d');
          ctx.putImageData(layerInfo.imageData, 0, 0);
          drawAllVoids(ctx, layerInfo.label);
        });
      }

      // ë™ê¸°í™”ë¥¼ throttlingí•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
      function throttledSyncRefresh() {
        if (!voidSyncMode) return;
        
        if (syncThrottleTimer) {
          clearTimeout(syncThrottleTimer);
        }
        
        syncThrottleTimer = setTimeout(() => {
          refreshCurrentPatches();
          syncThrottleTimer = null;
        }, 100); // 100ms throttling
      }

      // ì´ë™/í¬ê¸° ì¡°ì ˆëœ voidë¥¼ ê°™ì€ ê·¸ë£¹ì˜ ë‹¤ë¥¸ ë ˆì´ì–´ ë³´ì´ë“œë“¤ê³¼ ë™ê¸°í™”
      function updateSyncedVoids(movedVoid) {
        if (!movedVoid || !voidSyncMode) return;
        
        // ê°™ì€ ê·¸ë£¹ IDë¥¼ ê°€ì§„ ëª¨ë“  ë³´ì´ë“œë“¤ì„ ì—…ë°ì´íŠ¸
        if (movedVoid.groupId) {
          voidRecords.forEach(v => {
            if (v.id === movedVoid.id) return; // ìê¸° ìì‹ ì€ ì œì™¸
            if (v.groupId === movedVoid.groupId) {
              // ê°™ì€ ê·¸ë£¹ì˜ ë³´ì´ë“œë“¤ì€ ìœ„ì¹˜ì™€ í¬ê¸° ë™ê¸°í™”
              v.centerX = movedVoid.centerX;
              v.centerY = movedVoid.centerY;
              v.radiusX = movedVoid.radiusX;
              v.radiusY = movedVoid.radiusY;
            }
          });
        } else {
          // groupIdê°€ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ë°©ì‹ ì‚¬ìš© (ê±°ë¦¬ ê¸°ë°˜)
          const { chipCoord } = parsePatchLabel(movedVoid.patchLabel);
          
          voidRecords.forEach(v => {
            if (v.id === movedVoid.id) return;
            if (v.chipCoord !== chipCoord) return;
            if (v.type !== movedVoid.type) return;
            
            const distanceThreshold = 30;
            const originalDistance = Math.sqrt(
              Math.pow(v.centerX - movedVoid.centerX, 2) + 
              Math.pow(v.centerY - movedVoid.centerY, 2)
            );
            
            if (originalDistance < distanceThreshold) {
              v.centerX = movedVoid.centerX;
              v.centerY = movedVoid.centerY;
              v.radiusX = movedVoid.radiusX;
              v.radiusY = movedVoid.radiusY;
            }
          });
        }
      }

      // ì¹©ë³„ ë³´ì´ë“œ ë¨¸ì§€ (ëª¨ë“  ë ˆì´ì–´ì˜ ë³´ì´ë“œë¥¼ ê° ë ˆì´ì–´ì— ë³µì‚¬)
      function mergeChipVoids() {
        // ì¹©ë³„ë¡œ ê·¸ë£¹í•‘
        const voidsByChip = {};
        voidRecords.forEach(v => {
          if (!voidsByChip[v.chipCoord]) {
            voidsByChip[v.chipCoord] = [];
          }
          voidsByChip[v.chipCoord].push(v);
        });

        // ê° ì¹©ì— ëŒ€í•´ ëª¨ë“  ë ˆì´ì–´ì— ëª¨ë“  ë³´ì´ë“œ ë³µì‚¬
        Object.keys(voidsByChip).forEach(chipCoord => {
          const chipVoids = voidsByChip[chipCoord];
          const uniqueVoids = removeDuplicateVoids(chipVoids);
          
          // í•´ë‹¹ ì¹©ì˜ ëª¨ë“  ë ˆì´ì–´ì— ë³´ì´ë“œ ì¶”ê°€
          const chipLayers = getChipLayers(chipCoord);
          chipLayers.forEach(layer => {
            uniqueVoids.forEach(originalVoid => {
              const existingVoid = voidRecords.find(v => 
                v.chipCoord === chipCoord && 
                v.layer === layer &&
                Math.abs(v.centerX - originalVoid.centerX) < 5 &&
                Math.abs(v.centerY - originalVoid.centerY) < 5 &&
                v.type === originalVoid.type
              );
              
              if (!existingVoid) {
                const newPatchLabel = generatePatchLabel(chipCoord, layer);
                voidRecords.push({
                  id: ++voidIdCounter,
                  patchLabel: newPatchLabel,
                  chipCoord: chipCoord,
                  layer: layer,
                  type: originalVoid.type,
                  centerX: originalVoid.centerX,
                  centerY: originalVoid.centerY,
                  radiusX: originalVoid.radiusX,
                  radiusY: originalVoid.radiusY,
                });
              }
            });
          });
        });
      }

      // ì¤‘ë³µ ë³´ì´ë“œ ì œê±°
      function removeDuplicateVoids(voids) {
        const unique = [];
        const tolerance = 10; // í”½ì…€ í—ˆìš© ì˜¤ì°¨
        
        voids.forEach(v => {
          const isDuplicate = unique.some(u => 
            Math.abs(u.centerX - v.centerX) < tolerance &&
            Math.abs(u.centerY - v.centerY) < tolerance &&
            u.type === v.type
          );
          
          if (!isDuplicate) {
            unique.push(v);
          }
        });
        
        return unique;
      }

      // íŠ¹ì • ì¹©ì˜ ëª¨ë“  ë ˆì´ì–´ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
      function getChipLayers(chipCoord) {
        const layers = new Set();
        voidRecords.forEach(v => {
          if (v.chipCoord === chipCoord) {
            layers.add(v.layer);
          }
        });
        
        // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  í˜ì´ì§€ ë ˆì´ì–´ í¬í•¨
        for (let i = 1; i <= pages.length; i++) {
          layers.add(i);
        }
        
        return Array.from(layers);
      }

      // íŒ¨ì¹˜ ë¼ë²¨ ìƒì„±
      function generatePatchLabel(chipCoord, layer) {
        const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
        if (match) {
          const x = parseInt(match[1], 10);
          const y = parseInt(match[2], 10);
          
          const padCoord = (coord) => {
            if (coord < 0) {
              return `N${String(Math.abs(coord)).padStart(2, "0")}`;
            }
            return `${String(coord).padStart(2, "0")}`;
          };
          
          return `X${padCoord(x)}_Y${padCoord(y)}_L${String(layer).padStart(2, '0')}_LEG:merged`;
        }
        return `merged_${chipCoord}_L${layer}`;
      }

      // === ì´ë²¤íŠ¸ ===

      tiffInput.onchange = (e) => {
        if (e.target.files[0]) loadTiff(e.target.files[0]);
      };

      // ê·¸ë¦¬ë“œ í¬ê¸° ë³€ê²½ ì‹œ í˜ì´ì§€ ê°±ì‹ 
      [colsInput, rowsInput, cellWInput, cellHInput].forEach((el) => {
        el.removeEventListener("input", drawPage); // í˜¹ì‹œ ì¤‘ë³µ ë°©ì§€
        el.addEventListener("input", () => {
          drawPage(); // í˜ì´ì§€ë„¤ì´ì…˜ ìœ ì§€
        });
      });

      // CSV íŒŒì¼ ì—…ë¡œë“œ
      csvInput.onchange = async (e) => {
        if (e.target.files[0]) {
          csvRows = parseBondingMap(await e.target.files[0].text());
          chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
          drawPage(); // CSV ë¡œë“œ í›„ ë°”ë¡œ ê·¸ë¦¬ë“œì™€ ì  ê°±ì‹ 
        }
      };

      // ì—‘ì…€ ë³µë¶™
      csvPaste.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        csvRows = parseBondingMap(text);
        chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
        alert(`ë³µë¶™í•œ ${csvRows.length}ê°œì˜ chip ì¢Œí‘œ ë¡œë“œ ì™„ë£Œ`);
        drawPage();
      });
      // ë“œë˜ê·¸ë¡œ origin ì´ë™
      let dragging = false;
      let start = { x: 0, y: 0 };
      waferCanvas.addEventListener("mousedown", (e) => {
        if (refMode) return; // ì°¸ì¡°ëª¨ë“œì¼ ë•ŒëŠ” ë“œë˜ê·¸ê¸ˆì§€
        dragging = true;
        waferCanvas.classList.add("dragging");
        start.x = e.clientX;
        start.y = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        waferCanvas.classList.remove("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        origin.x += e.clientX - start.x;
        origin.y += e.clientY - start.y;
        start.x = e.clientX;
        start.y = e.clientY;
        drawPage();
      });

      // ğŸŸ¥ ê¸°ì¤€ì  ì„¤ì • ëª¨ë“œ
      setRefBtn.onclick = () => {
        refMode = !refMode;
        setRefBtn.classList.toggle("refMode", refMode);
        setRefBtn.textContent = refMode ? "Click Grid to Set" : "Set Reference";
      };

      // ê·¸ë¦¬ë“œ í´ë¦­ â†’ ì°¸ì¡° ì„¤ì •
      waferCanvas.addEventListener("click", (e) => {
        if (!refMode) return;

        const rect = waferCanvas.getBoundingClientRect();
        const scaleX = waferCanvas.width / rect.width;
        const scaleY = waferCanvas.height / rect.height;

        const clickX = (e.clientX - rect.left) * scaleX;
        const clickY = (e.clientY - rect.top) * scaleY;

        console.log(clickX, clickY, cellW, cellH);
        const gx = Math.floor(
          ((clickX - origin.x) / cellW.value) * currentScale
        );
        const gy = Math.floor(
          ((clickY - origin.y) / cellH.value) * currentScale
        );
        console.log(gx, gy);
        refGrid = { x: gx, y: gy };
        refMode = false;
        setRefBtn.classList.remove("refMode");
        setRefBtn.textContent = "Set Reference";
        drawPage();
      });

      const targetMeanInput = document.getElementById("targetMean");
      const targetStdInput = document.getElementById("targetStd");
      const padPxInput = document.getElementById("padPx");

      let allPatchPages = []; // ì¢Œí‘œë³„ í˜ì´ì§€ (ê° í˜ì´ì§€ = {coord, layers:[canvasâ€¦]})
      let currentPatchPage = 0;

      // ê¸°ì¡´ extractBtn.onclick êµì²´
      extractBtn.onclick = () => {
        console.log("Extract button clicked!");
        console.log("Pages loaded:", pages.length);
        console.log("CSV rows loaded:", csvRows.length);
        console.log("CSV data:", csvRows);
        
        if (!pages.length) {
          alert("TIFF íŒŒì¼ì„ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”!");
          return;
        }
        if (!csvRows.length) {
          alert("CSV ë°ì´í„°ë¥¼ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”!");
          return;
        }

        allPatchPages = [];
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const tMean = parseFloat(targetMeanInput.value);
        const tStd = parseFloat(targetStdInput.value);
        const pad = parseInt(padPxInput.value, 10);
        window.allPatchCanvases = [];

        csvRows.forEach((r) => {
          const pageData = { coord: `(${r.x},${r.y})`, layers: [] };

          pages.forEach((src, pageIdx) => {
            const gx = origin.x / currentScale + (r.x + refGrid.x) * cellW;
            const gy = origin.y / currentScale + (r.y + refGrid.y) * cellH;

            const titleH = 40;
            const c = document.createElement("canvas");
            c.width = cellW;
            c.height = cellH + titleH;
            const ctx = c.getContext("2d");

            // íƒ€ì´í‹€
            // ìŒìˆ˜ ì¢Œí‘œ ì²˜ë¦¬ë¥¼ ìœ„í•œ íŒ¨ë”© í•¨ìˆ˜
            const padCoord = (coord) => {
              if (coord < 0) {
                return `N${String(Math.abs(coord)).padStart(2, "0")}`;
              }
              return `${String(coord).padStart(2, "0")}`;
            };
            
            const label = `X${padCoord(r.x)}_Y${padCoord(r.y)}_L${String(pageIdx + 1).padStart(2, "0")}_LEG:${
              r.type || "NA"
            }`;
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cellW, titleH);
            ctx.fillStyle = "#fff";
            ctx.font = "20px sans-serif";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 6, titleH / 2);

            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            ctx.drawImage(src, gx, gy, cellW, cellH, 0, titleH, cellW, cellH);
            const originalImageData = ctx.getImageData(0, 0, c.width, c.height);

            // ë§ˆí‚¹ ì´ë²¤íŠ¸ ë¶€ì°©
            attachVoidEvents(c, label, originalImageData);

            // ë°ê¸°/ëŒ€ë¹„ ë³´ì • (ROI ê¸°ë°˜)
            const subImg = ctx.getImageData(0, titleH, cellW, cellH);
            const tmp = document.createElement("canvas");
            tmp.width = cellW;
            tmp.height = cellH;
            tmp.getContext("2d").putImageData(subImg, 0, 0);
            enhanceToTarget(tmp.getContext("2d"), tMean, tStd, pad);
            ctx.putImageData(
              tmp.getContext("2d").getImageData(0, 0, cellW, cellH),
              0,
              titleH
            );

            // ë°ì´í„° ìˆ˜ì§‘
            pageData.layers.push({
              canvas: c,
              label,
              type: r.type || "NA",
              layer: pageIdx + 1,
              imageData: originalImageData, // â˜… ì¶”ê°€
            });
            const typeFolder = r.type
              ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
              : "NA";
            window.allPatchCanvases.push({
              canvas: c,
              layer: pageIdx + 1,
              label,
              type: typeFolder,
            });
          });

          allPatchPages.push(pageData);
        });

        currentPatchPage = 0;
        showPatchPage(0);
      };

      document.getElementById("downloadZipBtn").onclick = () => {
        if (!window.allPatchCanvases || !window.allPatchCanvases.length) {
          alert("ë¨¼ì € Extract Patchesë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.");
          return;
        }

        const zip = new JSZip();

        window.allPatchCanvases.forEach((p) => {
          const folderPath = `split/${p.type}/layer_${String(p.layer).padStart(
            2,
            "0"
          )}`;
          const folder = zip.folder(folderPath);
          const dataURL = p.canvas.toDataURL("image/png").split(",")[1]; // base64
          folder.file(`${p.label}.png`, dataURL, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then((content) => {
          saveAs(content, "wafer_patches_by_type.zip");
        });
      };

      // í˜ì´ì§€ í‘œì‹œ í•¨ìˆ˜
      function showPatchPage(idx) {
        if (!allPatchPages.length) return;
        if (idx < 0) idx = 0;
        if (idx >= allPatchPages.length) idx = allPatchPages.length - 1;
        currentPatchPage = idx;

        const page = allPatchPages[idx];
        const patchesDiv = document.getElementById("patches");
        patchesDiv.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "coord-card";
        wrap.innerHTML = `<h3 style="color:white">Chip ${page.coord}</h3>`;

        const layersWrap = document.createElement("div");
        layersWrap.className = "layers-wrap";
        page.layers.forEach((l) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.innerHTML = `<div class="layer-label">${l.label}</div>`;
          item.appendChild(l.canvas);
          layersWrap.appendChild(item);
        });
        wrap.appendChild(layersWrap);
        patchesDiv.appendChild(wrap);

        document.getElementById("pageInfo").textContent = `Page ${
          currentPatchPage + 1
        } / ${allPatchPages.length}`;
      }

      // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
      document.getElementById("prevPage").onclick = () =>
        showPatchPage(currentPatchPage - 1);
      document.getElementById("nextPage").onclick = () =>
        showPatchPage(currentPatchPage + 1);

      document.getElementById("downloadVoids").onclick = () => {
        if (!voidRecords.length) {
          alert("No voids recorded.");
          return;
        }
        const blob = new Blob([JSON.stringify(voidRecords, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "void_records.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      // ìˆ«ìí‚¤ â†’ íƒ€ì…
      const voidKeyMap = {
        1: "void",
        2: "crack",
        3: "particle",
      };
      const typeSelect = document.getElementById("voidTypeSelect");

      // ìˆ«ì í‚¤ ëˆŒë €ì„ ë•Œ íƒ€ì… ë³€ê²½
      document.addEventListener("keydown", (e) => {
        if (!voidMarkMode) return; // ë§ˆí‚¹ ëª¨ë“œì¼ ë•Œë§Œ
        const newType = voidKeyMap[e.key];
        if (newType) {
          typeSelect.value = newType; // ë“œë¡­ë‹¤ìš´ë„ ì—…ë°ì´íŠ¸
          console.log(`Void type set to: ${newType}`);
        }
      });
    </script>
  </body>
</html>
