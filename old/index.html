<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
      }
      #left {
        width: 260px;
        padding: 10px;
        background: #eee;
        overflow-y: auto;
      }
      #center {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #333;
      }
      #right {
        width: 320px;
        overflow-y: auto;
        background: #111;
        color: #fff;
        padding: 10px;
      }
      canvas {
        max-width: 100%;
        height: auto;
        cursor: grab;
      }
      canvas.dragging {
        cursor: grabbing;
      }
      .patch {
        margin-bottom: 10px;
      }
      textarea {
        width: 100%;
        height: 80px;
      }
      .refMode {
        background: #ff8;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        height: auto;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .coord-card {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 12px;
        background: #222;
      }
      .coord-title {
        margin: 0 0 6px;
        font-size: 14px;
        color: #fff;
      }
      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      .layer-item {
        text-align: center;
        background: #333;
        padding: 4px;
        border-radius: 4px;
      }
      .layer-label {
        font-size: 11px;
        color: #ccc;
        margin-bottom: 4px;
      }
      .layer-item canvas {
        max-width: 100%;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .mode-on {
        background-color: #28a745; /* Ï¥àÎ°ùÏÉâ */
        color: white;
        font-weight: bold;
      }

      #topControls {
        position: sticky;
        top: 0; /* ÌôîÎ©¥ ÏµúÏÉÅÎã® Í≥†Ï†ï */
        z-index: 1000; /* Îã§Î•∏ ÏöîÏÜå ÏúÑÏóê ÌëúÏãú */
        background: #222; /* Î∞∞Í≤ΩÏÉâ, Ïä§ÌÅ¨Î°§ Ïãú ÎÇ¥Ïö©Ïù¥ ÎπÑÏπòÏßÄ ÏïäÍ≤å */
        padding: 10px;
      }

      #voidControls {
        padding: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      
      #voidControls button {
        padding: 6px 12px;
        border: 1px solid #555;
        background: #333;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      #voidControls button:hover {
        background: #444;
        border-color: #666;
      }
      
      #voidControls select {
        padding: 6px;
        background: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <label
        >Multi-page TIFF
        <input id="tiffFile" type="file" accept=".tif,.tiff" /> </label
      ><br /><br />

      <label>Chip CSV (ÌååÏùº ÎòêÎäî ÏóëÏÖÄÎ≥µÎ∂ô)</label>
      <input id="csvFile" type="file" accept=".csv" /><br />
      <textarea
        id="csvPaste"
        placeholder="ÏóëÏÖÄÏóêÏÑú Î≥µÏÇ¨ ÌõÑ Î∂ôÏó¨ÎÑ£Í∏∞ (x,y,type)"
      ></textarea
      ><br /><br />

      <label
        >Page:
        <select id="pageSelect"></select> </label
      ><br /><br />

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br /><br />

      <h3>Reference</h3>
      Í∏∞Ï§Ä X <input id="refX" type="number" value="0" /><br />
      Í∏∞Ï§Ä Y <input id="refY" type="number" value="0" /><br />
      <button id="setRefBtn">Set Reference</button><br /><br />

      <h3>Enhance</h3>
      Contrast Œ± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Œ≤ <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
      <button id="debugBtn">Debug Check</button>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <h3>Patches</h3>
      <div id="topControls">
        <div id="voidControls">
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <option value="void">void</option>
            <option value="crack">crack</option>
            <option value="particle">particle</option>
          </select>
          <button id="toggleSyncMode">Sync Layers</button>
          <button id="mergeVoids">Merge All</button>
          <button id="downloadVoids">Download Voids JSON</button>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">‚óÄ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next ‚ñ∂</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>

    <script type="module">
      import UTIF from "https://cdn.skypack.dev/utif";

      const waferCanvas = document.getElementById("wafer");
      const waferCtx = waferCanvas.getContext("2d");

      const pageSelect = document.getElementById("pageSelect");
      let pages = [];
      let pageIndex = 0;
      let origin = { x: 50, y: 50 };
      let csvRows = [];
      let refGrid = { x: 0, y: 0 }; // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Í∏∞Ï§Ä grid index
      let refMode = false;
      let currentScale = 1;
      let chipPoints = []; // üîµ ÌååÎûÄÏ†ê Ï¢åÌëú Ï†ÄÏû•
      let voidMarkMode = false;
      let voidRecords = []; // [{patchLabel, chipCoord, layer, type, centerX, centerY, radiusX, radiusY, id}]
      let deleteVoidMode = false;
      let selectedVoid = null;
      let resizeMode = false;
      let voidSyncMode = true; // Î†àÏù¥Ïñ¥ Í∞Ñ Î≥¥Ïù¥Îìú ÎèôÍ∏∞Ìôî Î™®Îìú
      let voidIdCounter = 0;
      let syncThrottleTimer = null; // ÎèôÍ∏∞Ìôî throttlingÏö© ÌÉÄÏù¥Î®∏
      let voidGroupCounter = 0; // Î≥¥Ïù¥Îìú Í∑∏Î£π ID Ïπ¥Ïö¥ÌÑ∞

      const markBtn = document.getElementById("toggleVoidMode");
      const deleteBtn = document.getElementById("toggleDeleteMode");

      document.getElementById("toggleVoidMode").onclick = () => {
        voidMarkMode = !voidMarkMode;
        markBtn.classList.toggle("mode-on", voidMarkMode); // ONÏù¥Î©¥ Ï¥àÎ°ùÏÉâ
      };

      document.getElementById("toggleDeleteMode").onclick = () => {
        deleteVoidMode = !deleteVoidMode;
        deleteBtn.classList.toggle("mode-on", deleteVoidMode);
      };

      // Î†àÏù¥Ïñ¥ ÎèôÍ∏∞Ìôî Î™®Îìú ÌÜ†Í∏Ä
      const syncBtn = document.getElementById("toggleSyncMode");
      syncBtn.classList.toggle("mode-on", voidSyncMode);
      document.getElementById("toggleSyncMode").onclick = () => {
        voidSyncMode = !voidSyncMode;
        syncBtn.classList.toggle("mode-on", voidSyncMode);
        // ÌòÑÏû¨ Î≥¥Ïù¥Îäî Ìå®ÏπòÎì§ÏùÑ Îã§Ïãú Í∑∏Î¶¨Í∏∞
        refreshCurrentPatches();
      };

      // Ïπ©Î≥Ñ Î≥¥Ïù¥Îìú Î®∏ÏßÄ
      document.getElementById("mergeVoids").onclick = () => {
        mergeChipVoids();
        alert("All chip voids have been merged across layers!");
        refreshCurrentPatches();
      };

      // ÎîîÎ≤ÑÍ∑∏ Ï≤¥ÌÅ¨ Î≤ÑÌäº
      document.getElementById("debugBtn").onclick = () => {
        console.log("=== DEBUG CHECK ===");
        console.log("Pages loaded:", pages.length);
        console.log("CSV rows:", csvRows.length);
        console.log("CSV data sample:", csvRows.slice(0, 5));
        console.log("Chip points:", chipPoints.slice(0, 5));
        console.log("Reference grid:", refGrid);
        console.log("Current scale:", currentScale);
        console.log("Origin:", origin);
        
        alert(`Debug Info:
Pages: ${pages.length}
CSV Rows: ${csvRows.length}
Chip Points: ${chipPoints.length}
Check console for details.`);
      };
      // === UI ÏóòÎ¶¨Î®ºÌä∏ ===
      const tiffInput = document.getElementById("tiffFile");
      const csvInput = document.getElementById("csvFile");
      const csvPaste = document.getElementById("csvPaste");
      const colsInput = document.getElementById("cols");
      const rowsInput = document.getElementById("rows");
      const cellWInput = document.getElementById("cellW");
      const cellHInput = document.getElementById("cellH");
      const alphaInput = document.getElementById("alpha");
      const betaInput = document.getElementById("beta");
      const extractBtn = document.getElementById("extractBtn");
      const patchesDiv = document.getElementById("patches");
      const refXInput = document.getElementById("refX");
      const refYInput = document.getElementById("refY");
      const setRefBtn = document.getElementById("setRefBtn");

      // ===== TIFF Î°úÎìú =====
      async function loadTiff(file) {
        console.log("Loading TIFF file:", file.name);
        try {
          const buf = await file.arrayBuffer();
          console.log("TIFF buffer size:", buf.byteLength);
          const ifds = UTIF.decode(buf);
          console.log("TIFF pages found:", ifds.length);
          ifds.forEach((ifd) => UTIF.decodeImage(buf, ifd));
          pages = ifds.map((ifd) => {
          const rgba = UTIF.toRGBA8(ifd);
          const c = document.createElement("canvas");
          c.width = ifd.width;
          c.height = ifd.height;
          c.getContext("2d").putImageData(
            new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height),
            0,
            0
          );
          return c;
        });

        // ÌéòÏù¥ÏßÄ ÏÑ†ÌÉù UI Í∞±Ïã†
        pageSelect.innerHTML = pages
          .map((_, i) => `<option value=\"${i}\">Page ${i + 1}</option>`)
          .join("");
        pageIndex = 0;
        console.log("TIFF loaded successfully, pages:", pages.length);
        drawPage();
        } catch (error) {
          console.error("TIFF loading failed:", error);
          alert("TIFF ÌååÏùº Î°úÎìú Ïã§Ìå®: " + error.message);
        }
      }

      function drawPage() {
        const src = pages[pageIndex];
        if (!src) return; // ÌòπÏãúÎùºÎèÑ undefinedÏùº Í≤ΩÏö∞ ÎåÄÎπÑ

        const MAX_SIZE = 1024; // Î∏åÎùºÏö∞Ï†Ä ÏïàÏ†Ñ Î≤îÏúÑ
        const scale = Math.min(1, MAX_SIZE / Math.max(src.width, src.height));
        const drawW = Math.round(src.width * scale);
        const drawH = Math.round(src.height * scale);

        waferCanvas.width = drawW;
        waferCanvas.height = drawH;
        waferCtx.drawImage(src, 0, 0, drawW, drawH);

        // Í∑∏Î¶¨Îìú ÏúÑÏπò/ÌÅ¨Í∏∞ Ïä§ÏºÄÏùºÎèÑ Í∞ôÏù¥ Ï†ÅÏö©
        currentScale = scale;
        drawGrid();
      }

      pageSelect.addEventListener("change", (e) => {
        pageIndex = e.target.value;
        drawPage();
      });

      function parseBondingMap(text) {
        console.log("Parsing bonding map, text length:", text.length);
        console.log("Text preview:", text.substring(0, 200));
        
        const lines = text.trimEnd().split(/\r?\n/);
        console.log("Lines found:", lines.length);
        
        if (lines.length < 2) {
          console.log("Not enough lines for bonding map");
          return [];
        }

        // Ï≤´ Ìñâ: X Ìó§Îçî (Îπà Î¨∏ÏûêÏó¥ÎèÑ Ïú†ÏßÄ)
        const xHeaders = lines[0]
          .split("\t")
          .slice(1)
          .map((h) => h.trim())
          .map((h) => parseInt(h, 10));
        console.log("X headers:", xHeaders);

        const out = [];
        for (let r = 1; r < lines.length; r++) {
          // Ìñâ Ï†ÑÏ≤¥Î•º ÌÉ≠ Í∏∞Ï§ÄÏúºÎ°ú Í∑∏ÎåÄÎ°ú split ‚Üí ÎÅùÏùò Îπà Ïπ∏ÎèÑ Ïú†ÏßÄ
          const cells = lines[r].split("\t");
          if (cells.length < 2) continue;

          const y = parseInt((cells[0] || "").trim(), 10);
          if (isNaN(y)) continue;

          // xHeaders Í∏∏Ïù¥Ïóê ÎßûÍ≤å ÏàúÌöå
          for (let c = 1; c <= xHeaders.length; c++) {
            const val = (cells[c] || "").trim();
            if (!val) continue;
            const x = xHeaders[c - 1];
            if (!isNaN(x)) out.push({ x, y, type: val });
          }
        }
        console.log("Parsed bonding map result:", out);
        console.log("Total coordinates found:", out.length);
        return out;
      }

      function drawGrid() {
        if (!pages.length) return;
        const cols = +colsInput.value;
        const rows = +rowsInput.value;
        const cellW = +cellWInput.value * currentScale;
        const cellH = +cellHInput.value * currentScale;

        waferCtx.strokeStyle = "lime";
        for (let i = 0; i <= cols; i++) {
          const x = origin.x + i * cellW;
          waferCtx.beginPath();
          waferCtx.moveTo(x, origin.y);
          waferCtx.lineTo(x, origin.y + rows * cellH);
          waferCtx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          const y = origin.y + j * cellH;
          waferCtx.beginPath();
          waferCtx.moveTo(origin.x, y);
          waferCtx.lineTo(origin.x + cols * cellW, y);
          waferCtx.stroke();
        }

        // üîµ CSV Ï¢åÌëú Í∏∞Ï§ÄÏúºÎ°ú ÌååÎûÄ Ï†ê ÌëúÏãú
        waferCtx.fillStyle = "deepskyblue";
        chipPoints.forEach((pt) => {
          const px = origin.x + (pt.x + refGrid.x + 0.5) * cellW;
          const py = origin.y + (pt.y + refGrid.y + 0.5) * cellH;
          waferCtx.beginPath();
          waferCtx.arc(px, py, Math.max(3, cellW * 0.05), 0, 2 * Math.PI);
          waferCtx.fill();
        });

        // üî¥ Í∏∞Ï§ÄÏ†ê(Reference) Îπ®Í∞Ñ Ï†ê
        waferCtx.fillStyle = "red";
        const refPixelX = origin.x + refGrid.x * cellW + cellW / 2;
        const refPixelY = origin.y + refGrid.y * cellH + cellH / 2;
        waferCtx.beginPath();
        waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
        waferCtx.fill();
      }

      // CSV/ÏóëÏÖÄ ÌååÏã± (ÌÉ≠¬∑ÏΩ§Îßà ÏßÄÏõê)
      function parseCSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split(/[\t,]+/).map((h) => h.toLowerCase());
        const xi = header.indexOf("x"),
          yi = header.indexOf("y"),
          ti = header.indexOf("type");
        if (xi === -1 || yi === -1) {
          alert("x,y Ìó§ÎçîÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.");
          return [];
        }
        const out = [];
        lines.slice(1).forEach((l) => {
          if (!l.trim()) return;
          const c = l.split(/[\t,]+/);
          const x = parseFloat(c[xi]);
          const y = parseFloat(c[yi]);
          if (isNaN(x) || isNaN(y)) return;
          out.push({ x, y, type: ti >= 0 && c[ti] ? c[ti] : "" });
        });
        return out;
      }

      // Î∞ùÍ∏∞/ÎåÄÎπÑ
      function adjust(ctx) {
        const img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const a = +alphaInput.value,
          b = +betaInput.value;
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = Math.min(255, Math.max(0, d[i] * a + b));
          d[i + 1] = Math.min(255, Math.max(0, d[i + 1] * a + b));
          d[i + 2] = Math.min(255, Math.max(0, d[i + 2] * a + b));
        }
        ctx.putImageData(img, 0, 0);
      }

      function enhanceToTarget(
        ctx,
        targetMean = 0.5,
        targetStd = 0.2,
        pad = 10
      ) {
        const { width, height } = ctx.canvas;
        const imgData = ctx.getImageData(0, 0, width, height);
        const d = imgData.data;

        // ROI : padding ÏïàÏ™Ω
        const roiPixels = [];
        for (let y = pad; y < height - pad; y++) {
          for (let x = pad; x < width - pad; x++) {
            const idx = (y * width + x) * 4;
            // grayscale = average RGB
            const g = (d[idx] + d[idx + 1] + d[idx + 2]) / (3 * 255);
            roiPixels.push(g);
          }
        }
        const mean = roiPixels.reduce((a, b) => a + b, 0) / roiPixels.length;
        const std =
          Math.sqrt(
            roiPixels.reduce((a, b) => a + (b - mean) ** 2, 0) /
              roiPixels.length
          ) || 1e-6;

        // Î≥¥Ï†ï: (v - mean)/std -> target
        const scale = targetStd / std;
        const offset = targetMean - mean * scale;

        for (let i = 0; i < d.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            let v = d[i + c] / 255;
            v = v * scale + offset;
            v = Math.min(1, Math.max(0, v));
            d[i + c] = v * 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      const voidColors = {
        void: "cyan",
        crack: "magenta",
        particle: "lime",
        default: "yellow", // ÎØ∏ÏßÄÏ†ï ÌÉÄÏûÖ
      };
      function attachVoidEvents(canvas, patchLabel, imageData) {
        const ctx = canvas.getContext("2d");

        canvas.addEventListener("mousedown", (e) => {
          if (!voidMarkMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const startX = (e.clientX - rect.left) * scaleX;
          const startY = (e.clientY - rect.top) * scaleY;

          const dragHandler = (me) => {
            const curX = (me.clientX - rect.left) * scaleX;
            const curY = (me.clientY - rect.top) * scaleY;
            // ÌÉÄÏûÖÎ≥Ñ ÏÉâÏÉÅ Îßµ

            ctx.putImageData(imageData, 0, 0);
            const selType =
              document.getElementById("voidTypeSelect").value || "default";
            ctx.strokeStyle = voidColors[selType] || voidColors.default;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(
              (startX + curX) / 2,
              (startY + curY) / 2,
              Math.abs(curX - startX) / 2,
              Math.abs(curY - startY) / 2,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          };

          const upHandler = (ue) => {
            document.removeEventListener("mousemove", dragHandler);
            document.removeEventListener("mouseup", upHandler);
            const endX = (ue.clientX - rect.left) * scaleX;
            const endY = (ue.clientY - rect.top) * scaleY;

            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            const radiusX = Math.abs(endX - startX) / 2;
            const radiusY = Math.abs(endY - startY) / 2;

            const type =
              document.getElementById("voidTypeSelect").value || "void";
            
            // Ìå®Ïπò ÎùºÎ≤®ÏóêÏÑú Ïπ© Ï¢åÌëúÏôÄ Î†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            const { chipCoord, layer } = parsePatchLabel(patchLabel);
            
            const groupId = ++voidGroupCounter;
            const newVoid = {
              id: ++voidIdCounter,
              groupId: groupId,
              patchLabel,
              chipCoord,
              layer,
              type,
              centerX,
              centerY,
              radiusX,
              radiusY,
            };
            
            voidRecords.push(newVoid);

            // ÎèôÍ∏∞Ìôî Î™®ÎìúÍ∞Ä ÏºúÏ†∏ÏûàÏúºÎ©¥ Í∞ôÏùÄ Ïπ©Ïùò Îã§Î•∏ Î†àÏù¥Ïñ¥ÏóêÎèÑ Î≥¥Ïù¥Îìú ÌëúÏãú
            if (voidSyncMode) {
              syncVoidToAllLayers(newVoid);
            }

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
          };

          document.addEventListener("mousemove", dragHandler);
          document.addEventListener("mouseup", upHandler);
        });

        canvas.addEventListener("click", (e) => {
          if (!deleteVoidMode) return;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // ÌÅ¥Î¶≠Ìïú Ï†êÏùÑ Ìè¨Ìï®ÌïòÎäî Î≥¥Ïù¥Îìú Ï∞æÍ∏∞
          let removed = false;
          voidRecords = voidRecords.filter((v) => {
            if (v.patchLabel !== patchLabel) return true;
            // ÌÉÄÏõê ÏïàÏóê Îì§Ïñ¥Í∞ÄÎ©¥ ÏÇ≠Ï†ú
            const dx = (x - v.centerX) / v.radiusX;
            const dy = (y - v.centerY) / v.radiusY;
            const inside = dx * dx + dy * dy <= 1;
            if (inside && !removed) {
              removed = true;
              return false; // ÏÇ≠Ï†ú
            }
            return true;
          });

          if (removed) {
            ctx.putImageData(imageData, 0, 0); // ÏõêÎ≥∏ Î≥µÏõê
            drawAllVoids(ctx, patchLabel); // ÎÇ®ÏùÄ Î≥¥Ïù¥Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
            
            // ÎèôÍ∏∞Ìôî Î™®ÎìúÏùº Îïå Îã§Î•∏ Î†àÏù¥Ïñ¥Îì§ÎèÑ ÏÉàÎ°úÍ≥†Ïπ®
            if (voidSyncMode) {
              refreshCurrentPatches();
            }
          }
        });

        canvas.addEventListener("mousedown", (e) => {
          if (voidMarkMode || deleteVoidMode) return;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          selectedVoid = voidRecords.find(
            (v) =>
              v.patchLabel === patchLabel &&
              (() => {
                const dx = x - v.centerX;
                const dy = y - v.centerY;
                const angle = Math.atan2(dy, dx);
                const rB =
                  (v.radiusX * v.radiusY) /
                  Math.sqrt(
                    (v.radiusY * Math.cos(angle)) ** 2 +
                      (v.radiusX * Math.sin(angle)) ** 2
                  );
                const dist = Math.hypot(dx, dy);
                return dist <= rB + 8; // 8px Ïò§Ï∞® ÌóàÏö©
              })()
          );

          if (!selectedVoid) return;

          // Ïù¥Îèô/Î¶¨ÏÇ¨Ïù¥Ï¶à Íµ¨Î∂Ñ
          const dx = x - selectedVoid.centerX;
          const dy = y - selectedVoid.centerY;
          const angle = Math.atan2(dy, dx);
          const rB =
            (selectedVoid.radiusX * selectedVoid.radiusY) /
            Math.sqrt(
              (selectedVoid.radiusY * Math.cos(angle)) ** 2 +
                (selectedVoid.radiusX * Math.sin(angle)) ** 2
            );
          const dist = Math.hypot(dx, dy);
          const tol = 8;

          resizeMode = Math.abs(dist - rB) <= tol;

          const offsetX = x - selectedVoid.centerX;
          const offsetY = y - selectedVoid.centerY;

          const moveHandler = (me) => {
            const mx = (me.clientX - rect.left) * scaleX;
            const my = (me.clientY - rect.top) * scaleY;

            if (resizeMode) {
              // Shift ÎàÑÎ•¥Î©¥ ÎπÑÏú® Ïú†ÏßÄ
              const dx = Math.abs(mx - selectedVoid.centerX);
              const dy = Math.abs(my - selectedVoid.centerY);
              if (me.shiftKey) {
                const r = Math.max(dx, dy);
                selectedVoid.radiusX = selectedVoid.radiusY = r;
              } else {
                selectedVoid.radiusX = dx;
                selectedVoid.radiusY = dy;
              }
            } else {
              // Ïù¥Îèô
              selectedVoid.centerX = mx - offsetX;
              selectedVoid.centerY = my - offsetY;
            }

            ctx.putImageData(imageData, 0, 0);
            drawAllVoids(ctx, patchLabel);
            
            // Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî (throttled)
            throttledSyncRefresh();
          };

          const upHandler = () => {
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
            
            // void Ïù¥Îèô/ÌÅ¨Í∏∞ Ï°∞Ï†à ÏôÑÎ£å ÌõÑ Îã§Î•∏ Î†àÏù¥Ïñ¥Ïùò ÎèôÏùºÌïú Î≥¥Ïù¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
            if (voidSyncMode && selectedVoid) {
              updateSyncedVoids(selectedVoid);
              refreshCurrentPatches();
            }
            
            selectedVoid = null;
          };

          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
        });
      }

      // ÌäπÏ†ï Ìå®ÏπòÏóê Ï†ÄÏû•Îêú Î™®Îì† Î≥¥Ïù¥Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
      function drawAllVoids(ctx, patchLabel) {
        ctx.lineWidth = 2;
        
        // ÌòÑÏû¨ Ìå®ÏπòÏùò Ïπ© Ï¢åÌëú Î∞è Î†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï∂îÏ∂ú
        const { chipCoord, layer } = parsePatchLabel(patchLabel);
        
        // ÌòÑÏû¨ Î†àÏù¥Ïñ¥Ïùò Î≥¥Ïù¥Îìú (Ïã§ÏÑ†)
        voidRecords
          .filter((v) => v.patchLabel === patchLabel)
          .forEach((v) => {
            ctx.beginPath();
            const color = voidColors[v.type] || voidColors.default;
            ctx.strokeStyle = color;
            ctx.setLineDash([]); // Ïã§ÏÑ†
            ctx.ellipse(
              v.centerX,
              v.centerY,
              v.radiusX,
              v.radiusY,
              0,
              0,
              2 * Math.PI
            );
            ctx.stroke();
          });

        // ÎèôÍ∏∞Ìôî Î™®ÎìúÏùº Îïå Îã§Î•∏ Î†àÏù¥Ïñ¥Ïùò Î≥¥Ïù¥Îìú (Ï†êÏÑ†)
        if (voidSyncMode) {
          const otherLayerVoids = voidRecords.filter((v) => v.chipCoord === chipCoord && v.layer !== layer);
          
          otherLayerVoids.forEach((v) => {
              ctx.beginPath();
              const color = voidColors[v.type] || voidColors.default;
              ctx.strokeStyle = color;
              ctx.globalAlpha = 0.5; // Î∞òÌà¨Î™Ö
              ctx.setLineDash([5, 5]); // Ï†êÏÑ†
              ctx.ellipse(
                v.centerX,
                v.centerY,
                v.radiusX,
                v.radiusY,
                0,
                0,
                2 * Math.PI
              );
              ctx.stroke();
              ctx.globalAlpha = 1.0; // Ìà¨Î™ÖÎèÑ Î≥µÏõê
              ctx.setLineDash([]); // ÏÑ† Ïä§ÌÉÄÏùº Î≥µÏõê
            });
        }
      }

      // Ìå®Ïπò ÎùºÎ≤®ÏóêÏÑú Ïπ© Ï¢åÌëúÏôÄ Î†àÏù¥Ïñ¥ Ï∂îÏ∂ú
      function parsePatchLabel(patchLabel) {
        // Ïòà: "XN05_Y07_L03_LEG:good" -> chipCoord: "(-5,7)", layer: 3
        // Ïòà: "X05_YN07_L03_LEG:good" -> chipCoord: "(5,-7)", layer: 3
        const match = patchLabel.match(/X(N?)(\d+)_Y(N?)(\d+)_L(\d+)/);
        if (match) {
          const xNegative = match[1] === 'N';
          const xValue = parseInt(match[2], 10);
          const yNegative = match[3] === 'N';
          const yValue = parseInt(match[4], 10);
          const layer = parseInt(match[5], 10);
          
          const actualX = xNegative ? -xValue : xValue;
          const actualY = yNegative ? -yValue : yValue;
          
          return { 
            chipCoord: `(${actualX},${actualY})`, 
            layer: layer 
          };
        }
        return { chipCoord: "unknown", layer: 1 };
      }

      // Í∞ôÏùÄ Ïπ©Ïùò Î™®Îì† Î†àÏù¥Ïñ¥Ïóê Î≥¥Ïù¥Îìú ÎèôÍ∏∞Ìôî
      function syncVoidToAllLayers(newVoid) {
        if (!newVoid || !voidSyncMode) return;
        
        // ÌòÑÏû¨ Î≥¥Ïù¥Îäî Ïπ©Ïùò Î™®Îì† Î†àÏù¥Ïñ¥Ïóê ÎèôÏùºÌïú Î≥¥Ïù¥Îìú ÏÉùÏÑ±
        if (allPatchPages.length > 0 && currentPatchPage < allPatchPages.length) {
          const currentPage = allPatchPages[currentPatchPage];
          const currentChipCoord = currentPage.coord;
          
          // Í∞ôÏùÄ Ïπ©Ïùò Îã§Î•∏ Î†àÏù¥Ïñ¥Îì§Ïóê Î≥¥Ïù¥Îìú Ï∂îÍ∞Ä
          currentPage.layers.forEach(layerInfo => {
            if (layerInfo.label === newVoid.patchLabel) return; // ÏõêÎ≥∏ Î†àÏù¥Ïñ¥Îäî Ï†úÏô∏
            
            // Ïù¥ÎØ∏ Í∞ôÏùÄ Í∑∏Î£πÏùò Î≥¥Ïù¥ÎìúÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
            const existingVoid = voidRecords.find(v => 
              v.patchLabel === layerInfo.label && 
              v.groupId === newVoid.groupId
            );
            
            if (!existingVoid) {
              // ÏÉàÎ°úÏö¥ Ïó∞Í≤∞Îêú Î≥¥Ïù¥Îìú ÏÉùÏÑ±
              const { chipCoord, layer } = parsePatchLabel(layerInfo.label);
              const syncedVoid = {
                id: ++voidIdCounter,
                groupId: newVoid.groupId, // Í∞ôÏùÄ Í∑∏Î£π ID ÏÇ¨Ïö©
                patchLabel: layerInfo.label,
                chipCoord: chipCoord,
                layer: layer,
                type: newVoid.type,
                centerX: newVoid.centerX,
                centerY: newVoid.centerY,
                radiusX: newVoid.radiusX,
                radiusY: newVoid.radiusY,
              };
              
              voidRecords.push(syncedVoid);
            }
          });
        }
        
        // ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏùò Î™®Îì† Ìå®ÏπòÎì§ÏùÑ ÏÉàÎ°úÍ≥†Ïπ®
        refreshCurrentPatches();
      }

      // ÌòÑÏû¨ Î≥¥Ïù¥Îäî Ìå®ÏπòÎì§ÏùÑ Îã§Ïãú Í∑∏Î¶¨Í∏∞
      function refreshCurrentPatches() {
        if (!allPatchPages.length || currentPatchPage >= allPatchPages.length) return;
        
        const currentPage = allPatchPages[currentPatchPage];
        currentPage.layers.forEach(layerInfo => {
          const ctx = layerInfo.canvas.getContext('2d');
          ctx.putImageData(layerInfo.imageData, 0, 0);
          drawAllVoids(ctx, layerInfo.label);
        });
      }

      // ÎèôÍ∏∞ÌôîÎ•º throttlingÌïòÏó¨ ÏÑ±Îä• ÏµúÏ†ÅÌôî
      function throttledSyncRefresh() {
        if (!voidSyncMode) return;
        
        if (syncThrottleTimer) {
          clearTimeout(syncThrottleTimer);
        }
        
        syncThrottleTimer = setTimeout(() => {
          refreshCurrentPatches();
          syncThrottleTimer = null;
        }, 100); // 100ms throttling
      }

      // Ïù¥Îèô/ÌÅ¨Í∏∞ Ï°∞Ï†àÎêú voidÎ•º Í∞ôÏùÄ Í∑∏Î£πÏùò Îã§Î•∏ Î†àÏù¥Ïñ¥ Î≥¥Ïù¥ÎìúÎì§Í≥º ÎèôÍ∏∞Ìôî
      function updateSyncedVoids(movedVoid) {
        if (!movedVoid || !voidSyncMode) return;
        
        // Í∞ôÏùÄ Í∑∏Î£π IDÎ•º Í∞ÄÏßÑ Î™®Îì† Î≥¥Ïù¥ÎìúÎì§ÏùÑ ÏóÖÎç∞Ïù¥Ìä∏
        if (movedVoid.groupId) {
          voidRecords.forEach(v => {
            if (v.id === movedVoid.id) return; // ÏûêÍ∏∞ ÏûêÏã†ÏùÄ Ï†úÏô∏
            if (v.groupId === movedVoid.groupId) {
              // Í∞ôÏùÄ Í∑∏Î£πÏùò Î≥¥Ïù¥ÎìúÎì§ÏùÄ ÏúÑÏπòÏôÄ ÌÅ¨Í∏∞ ÎèôÍ∏∞Ìôî
              v.centerX = movedVoid.centerX;
              v.centerY = movedVoid.centerY;
              v.radiusX = movedVoid.radiusX;
              v.radiusY = movedVoid.radiusY;
            }
          });
        } else {
          // groupIdÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Ï°¥ Î∞©Ïãù ÏÇ¨Ïö© (Í±∞Î¶¨ Í∏∞Î∞ò)
          const { chipCoord } = parsePatchLabel(movedVoid.patchLabel);
          
          voidRecords.forEach(v => {
            if (v.id === movedVoid.id) return;
            if (v.chipCoord !== chipCoord) return;
            if (v.type !== movedVoid.type) return;
            
            const distanceThreshold = 30;
            const originalDistance = Math.sqrt(
              Math.pow(v.centerX - movedVoid.centerX, 2) + 
              Math.pow(v.centerY - movedVoid.centerY, 2)
            );
            
            if (originalDistance < distanceThreshold) {
              v.centerX = movedVoid.centerX;
              v.centerY = movedVoid.centerY;
              v.radiusX = movedVoid.radiusX;
              v.radiusY = movedVoid.radiusY;
            }
          });
        }
      }

      // Ïπ©Î≥Ñ Î≥¥Ïù¥Îìú Î®∏ÏßÄ (Î™®Îì† Î†àÏù¥Ïñ¥Ïùò Î≥¥Ïù¥ÎìúÎ•º Í∞Å Î†àÏù¥Ïñ¥Ïóê Î≥µÏÇ¨)
      function mergeChipVoids() {
        // Ïπ©Î≥ÑÎ°ú Í∑∏Î£πÌïë
        const voidsByChip = {};
        voidRecords.forEach(v => {
          if (!voidsByChip[v.chipCoord]) {
            voidsByChip[v.chipCoord] = [];
          }
          voidsByChip[v.chipCoord].push(v);
        });

        // Í∞Å Ïπ©Ïóê ÎåÄÌï¥ Î™®Îì† Î†àÏù¥Ïñ¥Ïóê Î™®Îì† Î≥¥Ïù¥Îìú Î≥µÏÇ¨
        Object.keys(voidsByChip).forEach(chipCoord => {
          const chipVoids = voidsByChip[chipCoord];
          const uniqueVoids = removeDuplicateVoids(chipVoids);
          
          // Ìï¥Îãπ Ïπ©Ïùò Î™®Îì† Î†àÏù¥Ïñ¥Ïóê Î≥¥Ïù¥Îìú Ï∂îÍ∞Ä
          const chipLayers = getChipLayers(chipCoord);
          chipLayers.forEach(layer => {
            uniqueVoids.forEach(originalVoid => {
              const existingVoid = voidRecords.find(v => 
                v.chipCoord === chipCoord && 
                v.layer === layer &&
                Math.abs(v.centerX - originalVoid.centerX) < 5 &&
                Math.abs(v.centerY - originalVoid.centerY) < 5 &&
                v.type === originalVoid.type
              );
              
              if (!existingVoid) {
                const newPatchLabel = generatePatchLabel(chipCoord, layer);
                voidRecords.push({
                  id: ++voidIdCounter,
                  patchLabel: newPatchLabel,
                  chipCoord: chipCoord,
                  layer: layer,
                  type: originalVoid.type,
                  centerX: originalVoid.centerX,
                  centerY: originalVoid.centerY,
                  radiusX: originalVoid.radiusX,
                  radiusY: originalVoid.radiusY,
                });
              }
            });
          });
        });
      }

      // Ï§ëÎ≥µ Î≥¥Ïù¥Îìú Ï†úÍ±∞
      function removeDuplicateVoids(voids) {
        const unique = [];
        const tolerance = 10; // ÌîΩÏÖÄ ÌóàÏö© Ïò§Ï∞®
        
        voids.forEach(v => {
          const isDuplicate = unique.some(u => 
            Math.abs(u.centerX - v.centerX) < tolerance &&
            Math.abs(u.centerY - v.centerY) < tolerance &&
            u.type === v.type
          );
          
          if (!isDuplicate) {
            unique.push(v);
          }
        });
        
        return unique;
      }

      // ÌäπÏ†ï Ïπ©Ïùò Î™®Îì† Î†àÏù¥Ïñ¥ Î≤àÌò∏ Í∞ÄÏ†∏Ïò§Í∏∞
      function getChipLayers(chipCoord) {
        const layers = new Set();
        voidRecords.forEach(v => {
          if (v.chipCoord === chipCoord) {
            layers.add(v.layer);
          }
        });
        
        // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Î™®Îì† ÌéòÏù¥ÏßÄ Î†àÏù¥Ïñ¥ Ìè¨Ìï®
        for (let i = 1; i <= pages.length; i++) {
          layers.add(i);
        }
        
        return Array.from(layers);
      }

      // Ìå®Ïπò ÎùºÎ≤® ÏÉùÏÑ±
      function generatePatchLabel(chipCoord, layer) {
        const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
        if (match) {
          const x = parseInt(match[1], 10);
          const y = parseInt(match[2], 10);
          
          const padCoord = (coord) => {
            if (coord < 0) {
              return `N${String(Math.abs(coord)).padStart(2, "0")}`;
            }
            return `${String(coord).padStart(2, "0")}`;
          };
          
          return `X${padCoord(x)}_Y${padCoord(y)}_L${String(layer).padStart(2, '0')}_LEG:merged`;
        }
        return `merged_${chipCoord}_L${layer}`;
      }

      // === Ïù¥Î≤§Ìä∏ ===

      tiffInput.onchange = (e) => {
        if (e.target.files[0]) loadTiff(e.target.files[0]);
      };

      // Í∑∏Î¶¨Îìú ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú ÌéòÏù¥ÏßÄ Í∞±Ïã†
      [colsInput, rowsInput, cellWInput, cellHInput].forEach((el) => {
        el.removeEventListener("input", drawPage); // ÌòπÏãú Ï§ëÎ≥µ Î∞©ÏßÄ
        el.addEventListener("input", () => {
          drawPage(); // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ïú†ÏßÄ
        });
      });

      // CSV ÌååÏùº ÏóÖÎ°úÎìú
      csvInput.onchange = async (e) => {
        if (e.target.files[0]) {
          csvRows = parseBondingMap(await e.target.files[0].text());
          chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
          drawPage(); // CSV Î°úÎìú ÌõÑ Î∞îÎ°ú Í∑∏Î¶¨ÎìúÏôÄ Ï†ê Í∞±Ïã†
        }
      };

      // ÏóëÏÖÄ Î≥µÎ∂ô
      csvPaste.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        csvRows = parseBondingMap(text);
        chipPoints = csvRows.map((r) => ({ x: r.x, y: r.y }));
        alert(`Î≥µÎ∂ôÌïú ${csvRows.length}Í∞úÏùò chip Ï¢åÌëú Î°úÎìú ÏôÑÎ£å`);
        drawPage();
      });
      // ÎìúÎûòÍ∑∏Î°ú origin Ïù¥Îèô
      let dragging = false;
      let start = { x: 0, y: 0 };
      waferCanvas.addEventListener("mousedown", (e) => {
        if (refMode) return; // Ï∞∏Ï°∞Î™®ÎìúÏùº ÎïåÎäî ÎìúÎûòÍ∑∏Í∏àÏßÄ
        dragging = true;
        waferCanvas.classList.add("dragging");
        start.x = e.clientX;
        start.y = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        waferCanvas.classList.remove("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        origin.x += e.clientX - start.x;
        origin.y += e.clientY - start.y;
        start.x = e.clientX;
        start.y = e.clientY;
        drawPage();
      });

      // üü• Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï Î™®Îìú
      setRefBtn.onclick = () => {
        refMode = !refMode;
        setRefBtn.classList.toggle("refMode", refMode);
        setRefBtn.textContent = refMode ? "Click Grid to Set" : "Set Reference";
      };

      // Í∑∏Î¶¨Îìú ÌÅ¥Î¶≠ ‚Üí Ï∞∏Ï°∞ ÏÑ§Ï†ï
      waferCanvas.addEventListener("click", (e) => {
        if (!refMode) return;

        const rect = waferCanvas.getBoundingClientRect();
        const scaleX = waferCanvas.width / rect.width;
        const scaleY = waferCanvas.height / rect.height;

        const clickX = (e.clientX - rect.left) * scaleX;
        const clickY = (e.clientY - rect.top) * scaleY;

        console.log(clickX, clickY, cellW, cellH);
        const gx = Math.floor(
          ((clickX - origin.x) / cellW.value) * currentScale
        );
        const gy = Math.floor(
          ((clickY - origin.y) / cellH.value) * currentScale
        );
        console.log(gx, gy);
        refGrid = { x: gx, y: gy };
        refMode = false;
        setRefBtn.classList.remove("refMode");
        setRefBtn.textContent = "Set Reference";
        drawPage();
      });

      const targetMeanInput = document.getElementById("targetMean");
      const targetStdInput = document.getElementById("targetStd");
      const padPxInput = document.getElementById("padPx");

      let allPatchPages = []; // Ï¢åÌëúÎ≥Ñ ÌéòÏù¥ÏßÄ (Í∞Å ÌéòÏù¥ÏßÄ = {coord, layers:[canvas‚Ä¶]})
      let currentPatchPage = 0;

      // Í∏∞Ï°¥ extractBtn.onclick ÍµêÏ≤¥
      extractBtn.onclick = () => {
        console.log("Extract button clicked!");
        console.log("Pages loaded:", pages.length);
        console.log("CSV rows loaded:", csvRows.length);
        console.log("CSV data:", csvRows);
        
        if (!pages.length) {
          alert("TIFF ÌååÏùºÏùÑ Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
          return;
        }
        if (!csvRows.length) {
          alert("CSV Îç∞Ïù¥ÌÑ∞Î•º Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
          return;
        }

        allPatchPages = [];
        const cellW = +cellWInput.value;
        const cellH = +cellHInput.value;
        const tMean = parseFloat(targetMeanInput.value);
        const tStd = parseFloat(targetStdInput.value);
        const pad = parseInt(padPxInput.value, 10);
        window.allPatchCanvases = [];

        csvRows.forEach((r) => {
          const pageData = { coord: `(${r.x},${r.y})`, layers: [] };

          pages.forEach((src, pageIdx) => {
            const gx = origin.x / currentScale + (r.x + refGrid.x) * cellW;
            const gy = origin.y / currentScale + (r.y + refGrid.y) * cellH;

            const titleH = 40;
            const c = document.createElement("canvas");
            c.width = cellW;
            c.height = cellH + titleH;
            const ctx = c.getContext("2d");

            // ÌÉÄÏù¥ÌãÄ
            // ÏùåÏàò Ï¢åÌëú Ï≤òÎ¶¨Î•º ÏúÑÌïú Ìå®Îî© Ìï®Ïàò
            const padCoord = (coord) => {
              if (coord < 0) {
                return `N${String(Math.abs(coord)).padStart(2, "0")}`;
              }
              return `${String(coord).padStart(2, "0")}`;
            };
            
            const label = `X${padCoord(r.x)}_Y${padCoord(r.y)}_L${String(pageIdx + 1).padStart(2, "0")}_LEG:${
              r.type || "NA"
            }`;
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cellW, titleH);
            ctx.fillStyle = "#fff";
            ctx.font = "20px sans-serif";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 6, titleH / 2);

            // Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
            ctx.drawImage(src, gx, gy, cellW, cellH, 0, titleH, cellW, cellH);
            const originalImageData = ctx.getImageData(0, 0, c.width, c.height);

            // ÎßàÌÇπ Ïù¥Î≤§Ìä∏ Î∂ÄÏ∞©
            attachVoidEvents(c, label, originalImageData);

            // Î∞ùÍ∏∞/ÎåÄÎπÑ Î≥¥Ï†ï (ROI Í∏∞Î∞ò)
            const subImg = ctx.getImageData(0, titleH, cellW, cellH);
            const tmp = document.createElement("canvas");
            tmp.width = cellW;
            tmp.height = cellH;
            tmp.getContext("2d").putImageData(subImg, 0, 0);
            enhanceToTarget(tmp.getContext("2d"), tMean, tStd, pad);
            ctx.putImageData(
              tmp.getContext("2d").getImageData(0, 0, cellW, cellH),
              0,
              titleH
            );

            // Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            pageData.layers.push({
              canvas: c,
              label,
              type: r.type || "NA",
              layer: pageIdx + 1,
              imageData: originalImageData, // ‚òÖ Ï∂îÍ∞Ä
            });
            const typeFolder = r.type
              ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
              : "NA";
            window.allPatchCanvases.push({
              canvas: c,
              layer: pageIdx + 1,
              label,
              type: typeFolder,
            });
          });

          allPatchPages.push(pageData);
        });

        currentPatchPage = 0;
        showPatchPage(0);
      };

      document.getElementById("downloadZipBtn").onclick = () => {
        if (!window.allPatchCanvases || !window.allPatchCanvases.length) {
          alert("Î®ºÏ†Ä Extract PatchesÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî.");
          return;
        }

        const zip = new JSZip();

        window.allPatchCanvases.forEach((p) => {
          const folderPath = `split/${p.type}/layer_${String(p.layer).padStart(
            2,
            "0"
          )}`;
          const folder = zip.folder(folderPath);
          const dataURL = p.canvas.toDataURL("image/png").split(",")[1]; // base64
          folder.file(`${p.label}.png`, dataURL, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then((content) => {
          saveAs(content, "wafer_patches_by_type.zip");
        });
      };

      // ÌéòÏù¥ÏßÄ ÌëúÏãú Ìï®Ïàò
      function showPatchPage(idx) {
        if (!allPatchPages.length) return;
        if (idx < 0) idx = 0;
        if (idx >= allPatchPages.length) idx = allPatchPages.length - 1;
        currentPatchPage = idx;

        const page = allPatchPages[idx];
        const patchesDiv = document.getElementById("patches");
        patchesDiv.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "coord-card";
        wrap.innerHTML = `<h3 style="color:white">Chip ${page.coord}</h3>`;

        const layersWrap = document.createElement("div");
        layersWrap.className = "layers-wrap";
        page.layers.forEach((l) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.innerHTML = `<div class="layer-label">${l.label}</div>`;
          item.appendChild(l.canvas);
          layersWrap.appendChild(item);
        });
        wrap.appendChild(layersWrap);
        patchesDiv.appendChild(wrap);

        document.getElementById("pageInfo").textContent = `Page ${
          currentPatchPage + 1
        } / ${allPatchPages.length}`;
      }

      // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î≤ÑÌäº
      document.getElementById("prevPage").onclick = () =>
        showPatchPage(currentPatchPage - 1);
      document.getElementById("nextPage").onclick = () =>
        showPatchPage(currentPatchPage + 1);

      document.getElementById("downloadVoids").onclick = () => {
        if (!voidRecords.length) {
          alert("No voids recorded.");
          return;
        }
        const blob = new Blob([JSON.stringify(voidRecords, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "void_records.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      // Ïà´ÏûêÌÇ§ ‚Üí ÌÉÄÏûÖ
      const voidKeyMap = {
        1: "void",
        2: "crack",
        3: "particle",
      };
      const typeSelect = document.getElementById("voidTypeSelect");

      // Ïà´Ïûê ÌÇ§ ÎàåÎ†ÄÏùÑ Îïå ÌÉÄÏûÖ Î≥ÄÍ≤Ω
      document.addEventListener("keydown", (e) => {
        if (!voidMarkMode) return; // ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎßå
        const newType = voidKeyMap[e.key];
        if (newType) {
          typeSelect.value = newType; // ÎìúÎ°≠Îã§Ïö¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
          console.log(`Void type set to: ${newType}`);
        }
      });
    </script>
  </body>
</html>
