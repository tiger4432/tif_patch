<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool - V2</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist/geotiff.bundle.js"></script>
    <script type="module">
      import { ProgressManager } from "./js/progressManager.js";
      import { FileSaveManager } from "./js/fileSaveManager.js";
      window.ProgressManager = ProgressManager;
      window.FileSaveManager = FileSaveManager;
    </script>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <div class="highlight-box" style="margin: 8px 0">
        <button
          id="quickTestBtn"
          style="
            font-size: 12px;
            background: #28a745;
            border-color: #28a745;
            margin-bottom: 6px;
            width: 100%;
          "
        >
          üöÄ Quick Test Mode
        </button>
        <input
          id="localTiffPath"
          type="text"
          placeholder="Ïòà: /large_wafer_500chip_14900x14900_11layers.tif"
          style="font-size: 12px; margin-bottom: 4px"
        />
        <button id="loadLocalTiff" style="font-size: 12px">Load TIFF</button>
        <div
          id="memoryStatus"
          style="font-size: 12px; color: #6c757d; margin-top: 4px"
        >
          Memory: Ready
        </div>
        <div id="progressContainer" style="margin-top: 4px; display: none">
          <div style="font-size: 10px; margin-bottom: 2px">
            <span id="progressText">Loading...</span>
          </div>
          <div
            style="
              background: #ddd;
              border-radius: 2px;
              height: 4px;
              overflow: hidden;
            "
          >
            <div
              id="progressBar"
              style="
                background: linear-gradient(to right, #4caf50, #2196f3);
                height: 100%;
                width: 0%;
                transition: width 0.3s ease;
              "
            ></div>
          </div>
          <div style="font-size: 11px; color: #6c757d; margin-top: 1px">
            <span id="progressDetails"></span>
          </div>
        </div>
      </div>
      <textarea
        id="csvPaste"
        placeholder="Bonding Map Í≤©Ïûê ÌòïÌÉú Î∂ôÏó¨ÎÑ£Í∏∞ (Ïòà: ÌÉ≠ÏúºÎ°ú Íµ¨Î∂ÑÎêú x,y Ï¢åÌëú Ìëú)"
        style="height: 60px; font-size: 11px"
      ></textarea>
      <div style="margin-top: 6px">
        <label style="font-size: 13px; color: #495057"
          >Page:
          <select id="pageSelect" style="font-size: 12px"></select
        ></label>
      </div>

      <h3>Quick Load</h3>
      <div class="info-panel" style="margin-bottom: 12px; padding: 8px; font-size: 11px;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px;">
          <button id="quickSave1" style="padding: 4px; font-size: 10px; background: #28a745; border-color: #28a745;">Save 1</button>
          <button id="quickLoad1" style="padding: 4px; font-size: 10px;">Load 1</button>
          <div id="slotInfo1" style="grid-column: 1 / -1; min-height: 20px; border: 1px solid #ddd; padding: 2px; border-radius: 3px; background: #f9f9f9;"></div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px;">
          <button id="quickSave2" style="padding: 4px; font-size: 10px; background: #28a745; border-color: #28a745;">Save 2</button>
          <button id="quickLoad2" style="padding: 4px; font-size: 10px;">Load 2</button>
          <div id="slotInfo2" style="grid-column: 1 / -1; min-height: 20px; border: 1px solid #ddd; padding: 2px; border-radius: 3px; background: #f9f9f9;"></div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px;">
          <button id="quickSave3" style="padding: 4px; font-size: 10px; background: #28a745; border-color: #28a745;">Save 3</button>
          <button id="quickLoad3" style="padding: 4px; font-size: 10px;">Load 3</button>
          <div id="slotInfo3" style="grid-column: 1 / -1; min-height: 20px; border: 1px solid #ddd; padding: 2px; border-radius: 3px; background: #f9f9f9;"></div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px;">
          <button id="quickSave4" style="padding: 4px; font-size: 10px; background: #28a745; border-color: #28a745;">Save 4</button>
          <button id="quickLoad4" style="padding: 4px; font-size: 10px;">Load 4</button>
          <div id="slotInfo4" style="grid-column: 1 / -1; min-height: 20px; border: 1px solid #ddd; padding: 2px; border-radius: 3px; background: #f9f9f9;"></div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
          <button id="quickSave5" style="padding: 4px; font-size: 10px; background: #28a745; border-color: #28a745;">Save 5</button>
          <button id="quickLoad5" style="padding: 4px; font-size: 10px;">Load 5</button>
          <div id="slotInfo5" style="grid-column: 1 / -1; min-height: 20px; border: 1px solid #ddd; padding: 2px; border-radius: 3px; background: #f9f9f9;"></div>
        </div>
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">
          <input id="folderPath" type="text" placeholder="Ïòà: /extracted_patches_20241201_123456" style="font-size: 11px; margin-bottom: 4px;">
          <button id="loadFromFolder" style="width: 100%; padding: 6px; font-size: 11px; background: #6c757d; border-color: #6c757d;">Load from Folder</button>
        </div>
      </div>

      <h3>Compression Settings</h3>
      <div class="info-panel" style="margin-bottom: 12px; padding: 8px">
        <strong style="font-size: 14px">Max Size:</strong>
        <div
          style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 4px;
            font-size: 12px;
          "
        >
          <label
            ><input type="radio" name="compression" value="2048" /> 2K</label
          >
          <label
            ><input type="radio" name="compression" value="4096" /> 4K</label
          >
          <label
            ><input type="radio" name="compression" value="6144" /> 6K</label
          >
          <label
            ><input type="radio" name="compression" value="8192" checked />
            8K</label
          >
        </div>
      </div>

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br />

      <div style="margin-top: 8px">
        <h3>Grid Fine Adjustment:</h3>
        <br />
        Step Size:
        <input
          id="gridStepSize"
          type="number"
          step="0.1"
          value="0.5"
          style="width: 60px"
        />
        pixels<br />
        <small style="color: #666"
          >Î∞©Ìñ•ÌÇ§Î°ú Í∑∏Î¶¨Îìú ÎØ∏ÏÑ∏Ï°∞Ï†ï (Origin X,Y Ïù¥Îèô)</small
        >
      </div>

      <div style="margin-top: 8px">
        <h3>Real Size Settings:</h3>
        <br />
        Real Chip Size:
        <input
          id="realChipSize"
          type="number"
          value="1000"
          style="width: 80px"
        />
        Œºm<br />
        Canvas Chip Size:
        <input
          id="canvasChipSize"
          type="number"
          value="100"
          style="width: 80px"
        />
        pixels<br />
        <small style="color: #666">dela void Ïã§Ï†ú ÌÅ¨Í∏∞ ÌëúÏãúÏö© ÏÑ§Ï†ï</small>
      </div>
      <br />

      <div style="margin-top: 10px">
        <h3>Patch Alignment Preview:</h3>
        <br />
        <canvas
          id="gridPreview"
          width="300"
          height="200"
          style="border: 1px solid #ccc; margin-top: 5px"
        ></canvas>
        <div
          id="previewStatus"
          style="font-size: 11px; color: #666; margin-top: 2px"
        >
          Load TIFF to see patch samples
        </div>
      </div>
      <br />

      <h3>Reference Point</h3>
      Îπ®Í∞ÑÏ†ê Ï¢åÌëú ÏßÄÏ†ï:<br />
      X: <input id="refX" type="number" value="0" style="width: 60px" /> Y:
      <input id="refY" type="number" value="0" style="width: 60px" />
      <button id="setRefBtn">Apply</button><br />
      <small style="color: #666">Îπ®Í∞ÑÏ†êÏù¥ ÌëúÏãúÎê† Ïπ© Ï¢åÌëúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî</small
      ><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <h3>Detection Configuration</h3>
      Edge Threshold Min
      <input id="cannyMin" type="number" step="1" value="20" /><br />
      Edge Threshold Max
      <input id="cannyMax" type="number" step="1" value="50" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>

      <h3>Load Settings</h3>
      <div class="highlight-box">
        <textarea
          id="metadataPaste"
          placeholder="Metadata JSON Î∂ôÏó¨ÎÑ£Í∏∞"
          style="
            height: 80px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
          "
        ></textarea>
        <button id="loadMetadata" style="font-size: 12px">
          Apply Settings
        </button>
        <div style="font-size: 11px; color: #666; margin-top: 2px">
          Paste metadata.json or void JSON to restore grid settings
        </div>
      </div>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <div id="topControls">
        <h3>Patches</h3>
        <div id="voidControls">
          <textarea id="voidJson"></textarea>
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <!-- Options will be populated dynamically from VOID_COLORS -->
          </select>
          <button id="toggleSyncMode">Sync Layers</button>
          <button id="showSummary">Show Type Summary</button>
        </div>
        <div id="binLegend" style="margin: 10px 0; font-size: 12px">
          <h4 style="margin: 5px 0">Bin Classification</h4>
          <div id="binLegendContent">
            <!-- Bin legend will be populated dynamically -->
          </div>
          <div style="margin-top: 8px">
            <button id="copyBinMap" style="font-size: 11px; padding: 4px 8px">
              üìã Copy Bin Map
            </button>
          </div>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">‚óÄ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next ‚ñ∂</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>

    <!-- Patch Zoom Modal -->
    <div id="patchZoomModal" class="patch-zoom-modal">
      <div class="patch-zoom-content">
        <div class="patch-zoom-header">
          <h3 id="patchZoomTitle" class="patch-zoom-title">Patch Zoom</h3>
          <button id="patchZoomClose" class="patch-zoom-close">√ó</button>
        </div>
        <canvas id="patchZoomCanvas" class="patch-zoom-canvas"></canvas>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script type="module">
      // UTIF ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏûÑÌè¨Ìä∏
      import UTIF from "https://cdn.skypack.dev/utif";
      window.UTIF = UTIF;

      // Î™®Îìà ÏûÑÌè¨Ìä∏
      import {
        VOID_COLORS,
        VOID_KEY_MAP,
        CONFIG,
        BIN_RULES,
      } from "./js/constants.js";
      import {
        padCoord,
        parsePatchLabel,
        parseBondingMap,
        parseCSV,
      } from "./js/utils.js";
      import { VoidManagerV2 } from "./js/voidManager_v2.js";
      import { ImageProcessor } from "./js/imageProcessor.js";
      import { PatchManager } from "./js/patchManager.js";

      // Ï†ÑÏó≠ ÏÉÅÌÉú
      class WaferAppV2 {
        constructor() {
          this.pages = [];
          this.pageIndex = 0;
          this.currentScale = 1;
          this.origin = { x: 50, y: 50 };
          this.refGrid = { x: 0, y: 0 };
          this.csvRows = [];
          this.chipPoints = [];
          this.currentTiffFileName = null; // ÌòÑÏû¨ Î°úÎìúÎêú TIFF ÌååÏùºÎ™Ö

          // ÏÉàÎ°úÏö¥ Î≥¥Ïù¥Îìú Îß§ÎãàÏ†Ä
          this.voidManager = new VoidManagerV2();

          // Ìå®Ïπò Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî
          this.patchManager = new PatchManager(this.voidManager, this);
          this.voidMarkMode = false;
          this.deleteVoidMode = false;
          this.selectedVoid = null;
          this.resizeMode = false;
          this.showingSummary = false; // summary ÌëúÏãú ÏÉÅÌÉú Ï∂îÏ†Å

          // Î™®Îìà Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî
          this.progressManager = new window.ProgressManager();
          this.fileSaveManager = new window.FileSaveManager(
            this,
            this.progressManager
          );

          // Í∑∏Î¶¨Îìú ÌîÑÎ¶¨Î∑∞ Ï¥àÍ∏∞Ìôî
          this.gridPreviewCanvas = document.getElementById("gridPreview");
          this.gridPreviewCtx = this.gridPreviewCanvas.getContext("2d");

          this.initializeUI();
          this.populateVoidTypeSelect();
          this.setupEventHandlers();
          this.setupVoidJsonSync();
        }

        // Progress Bar Methods - Îç∏Î¶¨Í≤åÏù¥Ìä∏ Î©îÏÑúÎìúÎì§ (ProgressManager ÏÇ¨Ïö©)
        showProgress() {
          this.progressManager.showProgress();
        }

        hideProgress() {
          this.progressManager.hideProgress();
        }

        showFolderSaveProgress() {
          this.progressManager.showFolderSaveProgress();
        }

        hideFolderSaveProgress() {
          this.progressManager.hideFolderSaveProgress();
        }

        updateFolderSaveProgress(current, total, text = "", details = "") {
          this.progressManager.updateFolderSaveProgress(
            current,
            total,
            text,
            details
          );
        }

        updateProgress(percentage, text = "", details = "") {
          this.progressManager.updateProgress(percentage, text, details);
        }

        showSuccess(message, duration = 2000) {
          this.progressManager.showSuccess(message, duration);
        }

        showError(message, duration = 3000) {
          this.progressManager.showError(message, duration);
        }

        showWaiting(message) {
          this.progressManager.showWaiting(message);
        }

        downloadVoids() {
          const voidData = this.voidManager.exportVoids();
          if (!voidData.length) {
            alert("No voids recorded.");
            return;
          }

          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏôÄ Ìï®Íªò void Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
          const voidExportData = {
            metadata: this.getGridMetadata(),
            voidRecords: voidData,
            statistics: this.voidManager.getStats(),
            exportInfo: {
              totalVoids: voidData.length,
              exportDate: new Date().toISOString(),
              syncModeEnabled: this.voidManager.syncMode,
            },
          };

          const blob = new Blob([JSON.stringify(voidExportData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;

          const fileName = this.generateFileName("voids", ".json");
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        }

        initializeUI() {
          this.waferCanvas = document.getElementById("wafer");
          this.waferCtx = this.waferCanvas.getContext("2d");
          this.pageSelect = document.getElementById("pageSelect");

          this.markBtn = document.getElementById("toggleVoidMode");
          this.deleteBtn = document.getElementById("toggleDeleteMode");
          this.syncBtn = document.getElementById("toggleSyncMode");

          this.syncBtn.classList.toggle("mode-on", this.voidManager.syncMode);
        }

        /**
         * VOID_COLORSÏóêÏÑú void ÌÉÄÏûÖ select ÏòµÏÖòÎì§ÏùÑ ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±
         */
        populateVoidTypeSelect() {
          const voidTypeSelect = document.getElementById("voidTypeSelect");
          const voidTypes = Object.keys(VOID_COLORS).filter(
            (key) => key !== "default"
          );

          // Í∏∞Ï°¥ ÏòµÏÖòÎì§ Ï†úÍ±∞
          voidTypeSelect.innerHTML = "";

          // VOID_COLORS ÏàúÏÑúÎåÄÎ°ú ÏòµÏÖò Ï∂îÍ∞Ä
          voidTypes.forEach((type, index) => {
            const option = document.createElement("option");
            option.value = type;
            option.textContent = `${type} (${index + 1})`;
            option.style.color = VOID_COLORS[type];
            voidTypeSelect.appendChild(option);
          });

          // Ï≤´ Î≤àÏß∏ ÏòµÏÖòÏùÑ Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÑ§Ï†ï
          if (voidTypes.length > 0) {
            voidTypeSelect.value = voidTypes[0];
          }

          console.log(
            `Populated void type select with: ${voidTypes.join(", ")}`
          );
          console.log("Generated VOID_KEY_MAP:", VOID_KEY_MAP);
        }

        /**
         * Bin Î≤îÎ°Ä ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateBinLegend() {
          const binStats = this.voidManager.getBinStats(this.chipPoints);
          const binLegendContent = document.getElementById("binLegendContent");

          if (!binLegendContent) return;

          binLegendContent.innerHTML = "";

          // BIN_RULESÏóêÏÑú Í≥†Ïú†Ìïú bin Î≤àÌò∏Îì§ÏùÑ Ï∂îÏ∂ú (Ï§ëÎ≥µ Ï†úÍ±∞)
          const uniqueBins = new Map();
          Object.entries(BIN_RULES).forEach(([key, binInfo]) => {
            if (!uniqueBins.has(binInfo.bin) || key === "default") {
              uniqueBins.set(binInfo.bin, binInfo);
            }
          });

          // bin Î≤àÌò∏ ÏàúÏúºÎ°ú Ï†ïÎ†¨ (ÎÜíÏùÄ Î≤àÌò∏Í∞Ä Î®ºÏ†Ä)
          const sortedBins = Array.from(uniqueBins.entries()).sort(
            (a, b) => b[0] - a[0]
          );

          sortedBins.forEach(([binNumber, binInfo]) => {
            const count = binStats.byBin[binInfo.name]?.count || 0;

            const binItem = document.createElement("div");
            binItem.style.cssText = `
              display: flex;
              align-items: center;
              margin: 2px 0;
              font-size: 11px;
            `;

            binItem.innerHTML = `
              <div style="
                width: 16px;
                height: 12px;
                background: ${binInfo.color};
                margin-right: 6px;
                border: 1px solid #333;
                opacity: 0.7;
              "></div>
              <span style="font-weight: bold;">${binInfo.name}</span>
              <span style="margin-left: 4px; color: #666;">(${count})</span>
            `;

            binLegendContent.appendChild(binItem);
          });

          // Ï¥ù Ïπ© Ïàò ÌëúÏãú
          const totalItem = document.createElement("div");
          totalItem.style.cssText = `
            margin-top: 6px;
            padding-top: 4px;
            border-top: 1px solid #ddd;
            font-size: 11px;
            font-weight: bold;
          `;
          totalItem.textContent = `Total Chips: ${binStats.totalChips}`;
          binLegendContent.appendChild(totalItem);
        }

        /**
         * Bin MapÏùÑ ÌÅ¥Î¶ΩÎ≥¥ÎìúÎ°ú Î≥µÏÇ¨
         */
        async copyBinMapToClipboard() {
          if (!this.chipPoints.length) {
            alert("Î®ºÏ†Ä chip pointsÎ•º Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.");
            return;
          }

          const gridSettings = {
            cols: +document.getElementById("cols").value,
            rows: +document.getElementById("rows").value,
            refGrid: this.refGrid,
          };

          const binMap = this.voidManager.generateBinMap(
            this.chipPoints,
            gridSettings
          );
          if (!binMap) {
            alert("Bin map ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
            return;
          }

          const binMapText = this.voidManager.binMapToText(
            binMap,
            gridSettings
          );

          try {
            await navigator.clipboard.writeText(binMapText);
            this.showSuccess("Bin map copied to clipboard!", 2000);
            console.log("Bin map copied to clipboard");
          } catch (error) {
            console.error("Failed to copy to clipboard:", error);

            // ÌÅ¥Î¶ΩÎ≥¥Îìú APIÍ∞Ä Ïã§Ìå®ÌïòÎ©¥ ÌÖçÏä§Ìä∏ ÏòÅÏó≠ ÏÇ¨Ïö©
            const textarea = document.createElement("textarea");
            textarea.value = binMapText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);

            this.showSuccess(
              "Bin map copied to clipboard (fallback method)!",
              2000
            );
          }
        }

        /**
         * Î∞©Ìñ•ÌÇ§Î°ú Í∑∏Î¶¨Îìú ÎØ∏ÏÑ∏Ï°∞Ï†ï
         */
        adjustGridWithArrowKeys(key) {
          const stepSize =
            +document.getElementById("gridStepSize").value || 0.5;

          switch (key) {
            case "ArrowUp":
              this.origin.y -= stepSize;
              break;
            case "ArrowDown":
              this.origin.y += stepSize;
              break;
            case "ArrowLeft":
              this.origin.x -= stepSize;
              break;
            case "ArrowRight":
              this.origin.x += stepSize;
              break;
          }

          // Í∑∏Î¶¨Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
          this.drawPage();
          this.updateGridPreview();

          // ÌòÑÏû¨ origin Í∞íÏùÑ ÏΩòÏÜîÏóê Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖÏö©)
          console.log(
            `Grid adjusted: Origin (${this.origin.x.toFixed(
              1
            )}, ${this.origin.y.toFixed(1)}), Step: ${stepSize}`
          );
        }

        setupEventHandlers() {
          // Quick Test Mode Î≤ÑÌäº
          document.getElementById("quickTestBtn").onclick = async () => {
            await this.loadQuickTestData();
          };

          // Î°úÏª¨ ÏÑúÎ≤ÑÏóêÏÑú TIFF Î°úÎìú (Range ÏÑúÎ≤Ñ ÏÇ¨Ïö©)
          document.getElementById("loadLocalTiff").onclick = async () => {
            const filePath = document.getElementById("localTiffPath").value;
            if (!filePath) {
              alert("ÌååÏùº Í≤ΩÎ°úÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî (Ïòà: /large_image.tif)");
              return;
            }

            const loadBtn = document.getElementById("loadLocalTiff");
            const originalText = loadBtn.textContent;

            try {
              loadBtn.textContent = "Loading...";
              loadBtn.disabled = true;

              // Range ÏÑúÎ≤Ñ URL Íµ¨ÏÑ± (Ìè¨Ìä∏ 8083 ÏÇ¨Ïö©)
              const rangeServerUrl = `http://localhost:8083${
                filePath.startsWith("/") ? filePath : "/" + filePath
              }`;

              // ÌååÏùºÎ™Ö Ï∂îÏ∂ú Î∞è Ï†ÄÏû•
              const fileName = filePath.split("/").pop() || filePath;
              this.currentTiffFileName = fileName.replace(/\.[^/.]+$/, ""); // ÌôïÏû•Ïûê Ï†úÍ±∞

              console.log("Loading from Range server:", rangeServerUrl);
              console.log("TIFF file name:", this.currentTiffFileName);

              // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
              const memoryStatus = document.getElementById("memoryStatus");
              let initialMemory = null;

              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  initialMemory = ImageProcessor.getMemoryUsage();
                  if (initialMemory) {
                    console.log("Initial memory usage:", initialMemory);
                    memoryStatus.textContent = `Memory: ${initialMemory.used}MB / ${initialMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Not supported";
                  }
                } else {
                  console.warn("getMemoryUsage method not available");
                  memoryStatus.textContent = "Memory: Method not available";
                }
              } catch (error) {
                console.error("Memory monitoring error:", error);
                memoryStatus.textContent = "Memory: Error";
              }

              console.log("loadtitff");

              // ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î ÌëúÏãú
              this.showProgress();

              try {
                // Range ÏÑúÎ≤ÑÎ•º ÌÜµÌïú Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôîÎêú TIFF Î°úÎî©
                this.updateProgress(
                  10,
                  "Connecting to Range server...",
                  rangeServerUrl
                );
                this.pages = await ImageProcessor.loadTiffFromServer(
                  rangeServerUrl,
                  (current, total, details) => {
                    const progress = 10 + (current / total) * 80; // 10-90%
                    this.updateProgress(
                      progress,
                      `Loading page ${current}/${total}`,
                      details
                    );
                  }
                );

                this.updateProgress(
                  95,
                  "Processing pages...",
                  "Updating page selector"
                );
                this.updatePageSelect();

                this.updateProgress(
                  98,
                  "Rendering image...",
                  "Drawing current page"
                );
                await this.drawPage();

                this.updateProgress(
                  99,
                  "Updating preview...",
                  "Grid preview generation"
                );
                this.updateGridPreview();

                this.updateProgress(
                  100,
                  "Loading complete!",
                  `${this.pages.length} pages loaded successfully`
                );

                // 2Ï¥à ÌõÑ ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î Ïà®Í∏∞Í∏∞
                setTimeout(() => this.hideProgress(), 2000);
              } catch (error) {
                this.updateProgress(0, "Loading failed", error.message);
                setTimeout(() => this.hideProgress(), 3000);
                throw error;
              }

              // ÏµúÏ¢Ö Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏
              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  const finalMemory = ImageProcessor.getMemoryUsage();
                  if (finalMemory && initialMemory) {
                    console.log("Final memory usage:", finalMemory);
                    const memoryIncrease =
                      finalMemory.used - initialMemory.used;
                    console.log("Memory increase:", memoryIncrease, "MB");
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB (+${memoryIncrease}MB)`;
                  } else if (finalMemory) {
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Load Complete";
                  }
                } else {
                  memoryStatus.textContent = "Memory: Load Complete";
                }
              } catch (error) {
                console.error("Final memory check error:", error);
                memoryStatus.textContent = "Memory: Load Complete";
              }

              // ÏÑ±Í≥µ Î©îÏãúÏßÄ
              const finalMemoryText = memoryStatus.textContent.includes("MB")
                ? memoryStatus.textContent.split(" ")[1]
                : "N/A";
              alert(
                `Î°úÏª¨ ÏÑúÎ≤ÑÏóêÏÑú Î°úÎìú ÏôÑÎ£å!\nÌéòÏù¥ÏßÄ Ïàò: ${this.pages.length}\nÎ©îÎ™®Î¶¨ ÏÉÅÌÉú: ${finalMemoryText}`
              );
            } catch (error) {
              alert(error.message);
              console.error("Local server loading error:", error);
            } finally {
              loadBtn.textContent = originalText;
              loadBtn.disabled = false;
            }
          };

          // CSV Î∂ôÏó¨ÎÑ£Í∏∞
          document
            .getElementById("csvPaste")
            .addEventListener("paste", async (e) => {
              const text = e.clipboardData.getData("text");
              this.csvRows = parseBondingMap(text);
              this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));
              alert(`Î≥µÎ∂ôÌïú ${this.csvRows.length}Í∞úÏùò chip Ï¢åÌëú Î°úÎìú ÏôÑÎ£å`);
              await this.drawPage();
              this.updateGridPreview();
            });

          // ÌéòÏù¥ÏßÄ ÏÑ†ÌÉù
          this.pageSelect.addEventListener("change", async (e) => {
            this.pageIndex = parseInt(e.target.value) || 0;
            await this.drawPage();
            this.updateGridPreview();
          });

          // ÏïïÏ∂ï ÏÑ§Ï†ï Î≥ÄÍ≤Ω
          document
            .querySelectorAll('input[name="compression"]')
            .forEach((radio) => {
              radio.addEventListener("change", (e) => {
                if (e.target.checked) {
                  ImageProcessor.updateCompressionSettings(e.target.value);
                  console.log(
                    "Compression setting changed to:",
                    e.target.value
                  );
                }
              });
            });

          // Í∑∏Î¶¨Îìú Î≥ÄÍ≤Ω
          ["cols", "rows", "cellW", "cellH"].forEach((id) => {
            document.getElementById(id).addEventListener("input", async () => {
              await this.drawPage();
              this.updateGridPreview();
            });
          });

          // Void Í¥ÄÎ†® Î≤ÑÌäºÎì§
          this.markBtn.onclick = () => {
            this.voidMarkMode = !this.voidMarkMode;
            this.markBtn.classList.toggle("mode-on", this.voidMarkMode);
          };

          this.deleteBtn.onclick = () => {
            this.deleteVoidMode = !this.deleteVoidMode;
            this.deleteBtn.classList.toggle("mode-on", this.deleteVoidMode);
          };

          this.syncBtn.onclick = () => {
            const newState = this.voidManager.toggleSyncMode();
            this.syncBtn.classList.toggle("mode-on", newState);
            this.patchManager.refreshCurrentPatches();
          };

          // Í∏∞ÌÉÄ Î≤ÑÌäºÎì§
          document.getElementById("extractBtn").onclick = async () =>
            await this.patchManager.extractPatches();
          document.getElementById("downloadZipBtn").onclick = () =>
            this.fileSaveManager.downloadZip();
          document.getElementById("showSummary").onclick = () =>
            this.showTypeSummary();
          document.getElementById("copyBinMap").onclick = () =>
            this.copyBinMapToClipboard();

          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú (Î≥µÎ∂ô Î∞©Ïãù)
          document.getElementById("loadMetadata").onclick = async () => {
            const textarea = document.getElementById("metadataPaste");
            const text = textarea.value.trim();

            if (!text) {
              alert("Please paste metadata JSON first.");
              return;
            }

            try {
              const jsonData = JSON.parse(text);
              const metadata = this.extractMetadataFromJson(jsonData);

              if (!metadata) {
                alert(
                  "Invalid metadata format. Please paste a valid metadata.json or void JSON content."
                );
                return;
              }

              const success = this.applyMetadata(metadata);
              if (success) {
                // Í∑∏Î¶¨Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
                await this.drawPage();
                this.updateGridPreview();

                alert(
                  `Settings loaded successfully!\nTIFF: ${
                    metadata.tiffFileName || "Unknown"
                  }\nGrid: ${metadata.gridSettings?.cols}x${
                    metadata.gridSettings?.rows
                  }\nCell: ${metadata.gridSettings?.cellW}x${
                    metadata.gridSettings?.cellH
                  }`
                );

                console.log("Loaded metadata:", metadata);

                // textarea Ï¥àÍ∏∞Ìôî
                textarea.value = "";
              } else {
                alert("Failed to apply metadata settings.");
              }
            } catch (error) {
              console.error("Error loading metadata:", error);
              alert("Failed to parse JSON. Please check the format.");
            }
          };

          // Ï∫îÎ≤ÑÏä§ ÎìúÎûòÍ∑∏
          this.setupCanvasDrag();

          // Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï
          this.setupReferenceMode();

          // Ìå®Ïπò ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
          document.getElementById("prevPage").onclick = async () => {
            this.exitSummaryMode();
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage - 1
            );
          };
          document.getElementById("nextPage").onclick = async () => {
            this.exitSummaryMode();
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage + 1
            );
          };

          // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
          document.addEventListener("keydown", (e) => {
            // Î∞©Ìñ•ÌÇ§Î°ú Í∑∏Î¶¨Îìú ÎØ∏ÏÑ∏Ï°∞Ï†ï (ÏûÖÎ†• ÌïÑÎìúÏóê Ìè¨Ïª§Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå)
            if (
              ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
                e.key
              )
            ) {
              const activeElement = document.activeElement;
              const isInputFocused =
                activeElement &&
                (activeElement.tagName === "INPUT" ||
                  activeElement.tagName === "TEXTAREA");

              if (!isInputFocused) {
                e.preventDefault();
                this.adjustGridWithArrowKeys(e.key);
                return;
              }
            }

            // void ÌÉÄÏûÖ Îã®Ï∂ïÌÇ§ (void mark Î™®ÎìúÏùº ÎïåÎßå)
            if (!this.voidMarkMode) return;
            const newType = VOID_KEY_MAP[e.key];
            if (newType) {
              document.getElementById("voidTypeSelect").value = newType;
            }
          });

          // Ï¥àÍ∏∞ Í∑∏Î¶¨Îìú ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
          this.updateGridPreview();

          // Ïõ®Ïù¥Ìçº Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (ÌååÎûÄÏ†ê ÌÅ¥Î¶≠ÏúºÎ°ú Ìå®Ïπò Ïù¥Îèô)
          this.setupWaferCanvasClick();
        }

        /**
         * Ïõ®Ïù¥Ìçº Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
         */
        setupWaferCanvasClick() {
          this.waferCanvas.addEventListener("click", async (e) => {
            // ÎìúÎûòÍ∑∏ Ï§ëÏù¥Í±∞ÎÇò Î≥¥Ïù¥Îìú ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎäî Î¨¥Ïãú
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = this.waferCanvas.getBoundingClientRect();
            const scaleX = this.waferCanvas.width / rect.width;
            const scaleY = this.waferCanvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // ÌÅ¥Î¶≠Ìïú Ï¢åÌëúÎ•º Í∑∏Î¶¨Îìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const cellW =
              +document.getElementById("cellW").value * this.currentScale;
            const cellH =
              +document.getElementById("cellH").value * this.currentScale;

            const gridX = Math.floor(
              (clickX - this.origin.x * this.currentScale) / cellW
            );
            const gridY = Math.floor(
              (clickY - this.origin.y * this.currentScale) / cellH
            );

            // Ïã§Ï†ú Ïπ© Ï¢åÌëúÎ°ú Î≥ÄÌôò (Í∏∞Ï§ÄÏ†ê Í≥†Î†§)
            const chipX = gridX + this.refGrid.x;
            const chipY = gridY + this.refGrid.y;

            // Auto bbox detection Î™®ÎìúÏùº Îïå bbox ÌÉêÏßÄ ÏàòÌñâ
            if (this.voidManager.autoBboxDetection) {
              await this.detectBboxForChip(chipX, chipY);
              return;
            }

            // Summary Î™®Îìú Ìï¥Ï†ú
            this.exitSummaryMode();

            // Ìï¥Îãπ Ï¢åÌëúÏùò Ìå®ÏπòÎ•º Ï∞æÏïÑÏÑú Ïù¥Îèô
            await this.patchManager.navigateToChipPatch(chipX, chipY);
          });
        }

        /**
         * ÌäπÏ†ï Ïπ©ÏóêÏÑú bbox ÌÉêÏßÄ ÏàòÌñâ
         */
        async detectBboxForChip(chipX, chipY) {
          console.log(`Detecting bbox for chip (${chipX}, ${chipY})`);

          // Ìï¥Îãπ Ïπ©Ïùò Ìå®Ïπò Ï∞æÍ∏∞
          const targetCoord = `(${chipX},${chipY})`;
          const targetPatch = this.allPatchPages.find(
            (patch) => patch.coord === targetCoord
          );

          if (!targetPatch) {
            console.log(`No patch found for chip (${chipX}, ${chipY})`);
            return;
          }

          // Í∞Å Î†àÏù¥Ïñ¥ÏóêÏÑú bbox ÌÉêÏßÄ ÏàòÌñâ
          for (const layerData of targetPatch.layers) {
            if (layerData.canvas) {
              const detectedBboxes = this.voidManager.detectBboxFromImage(
                layerData.canvas,
                chipX,
                chipY,
                300
              );

              console.log(
                `Detected ${detectedBboxes.length} bboxes for chip (${chipX}, ${chipY}) layer ${layerData.layer}`
              );
            }
          }

          // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
          this.refreshCurrentPatches();
        }

        /**
         * ÌäπÏ†ï Ïπ© Ï¢åÌëúÏùò Ìå®ÏπòÎ°ú Ïù¥Îèô
         */
        async navigateToChipPatch(chipX, chipY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          // Ìï¥Îãπ Ï¢åÌëúÏùò Ìå®Ïπò Ï∞æÍ∏∞
          const targetCoord = `(${chipX},${chipY})`;
          const patchIndex = this.patchManager.allPatchPages.findIndex(
            (patch) => patch.coord === targetCoord
          );

          if (patchIndex !== -1) {
            this.patchManager.currentPatchPage = patchIndex;
            await this.patchManager.showPatchPage(patchIndex);
            await this.drawPage(); // Ï¥àÎ°ùÏ†ê ÏóÖÎç∞Ïù¥Ìä∏

            console.log(
              `Navigated to patch: ${targetCoord} (index: ${patchIndex})`
            );
          } else {
            console.log(`No patch found for coordinates: ${targetCoord}`);
          }
        }

        updatePageSelect() {
          this.pageSelect.innerHTML = this.pages
            .map((_, i) => `<option value="${i}">Page ${i + 1}</option>`)
            .join("");
          this.pageIndex = 0;
        }

        async drawPage() {
          if (!this.pages.length) return;

          const src = this.pages[this.pageIndex];

          // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ
          const memory = ImageProcessor.getMemoryUsage();
          if (memory) {
            console.log(
              `Current memory usage: ${memory.used}MB / ${memory.limit}MB`
            );

            // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏúºÎ©¥ Í≤ΩÍ≥†
            if (memory.used / memory.limit > 0.8) {
              console.warn("High memory usage detected");
            }
          }

          this.currentScale = ImageProcessor.drawPage(src, this.waferCanvas);
          this.drawGrid();
        }

        drawGrid() {
          if (!this.pages.length) return;

          const cols = +document.getElementById("cols").value;
          const rows = +document.getElementById("rows").value;
          const cellW =
            +document.getElementById("cellW").value * this.currentScale;
          const cellH =
            +document.getElementById("cellH").value * this.currentScale;

          // Í∏∞Ï§ÄÏ†êÎèÑ Ïä§ÏºÄÏùº Ï†ÅÏö©
          const scaledOriginX = this.origin.x * this.currentScale;
          const scaledOriginY = this.origin.y * this.currentScale;

          this.waferCtx.strokeStyle = "lime";
          this.waferCtx.lineWidth = 1;

          // ÏàòÏßÅÏÑ† Í∑∏Î¶¨Í∏∞
          for (let i = 0; i <= cols; i++) {
            const x = scaledOriginX + i * cellW;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(x, scaledOriginY);
            this.waferCtx.lineTo(x, scaledOriginY + rows * cellH);
            this.waferCtx.stroke();
          }

          // ÏàòÌèâÏÑ† Í∑∏Î¶¨Í∏∞
          for (let j = 0; j <= rows; j++) {
            const y = scaledOriginY + j * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(scaledOriginX, y);
            this.waferCtx.lineTo(scaledOriginX + cols * cellW, y);
            this.waferCtx.stroke();
          }

          // Ïπ© Ìè¨Ïù∏Ìä∏ (bin ÏÉâÏÉÅ Î∞∞Í≤Ω + ÌååÎûÄ Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.chipPoints.forEach((pt) => {
            const px = scaledOriginX + (pt.x - this.refGrid.x) * cellW;
            const py = scaledOriginY + (pt.y - this.refGrid.y) * cellH;

            // bin ÏÉâÏÉÅ Î∞∞Í≤Ω Í∑∏Î¶¨Í∏∞
            const binInfo = this.voidManager.calculateChipBin(pt.x, pt.y);
            this.waferCtx.fillStyle = binInfo.color;
            this.waferCtx.globalAlpha = 0.3; // Î∞òÌà¨Î™Ö
            this.waferCtx.fillRect(px, py, cellW, cellH);

            // Ïπ© Ìè¨Ïù∏Ìä∏ (ÌååÎûÄ Ï†ê)
            this.waferCtx.globalAlpha = 1.0; // Î∂àÌà¨Î™Ö
            this.waferCtx.fillStyle = "deepskyblue";
            const centerX = px + 0.5 * cellW;
            const centerY = py + 0.5 * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.arc(
              centerX,
              centerY,
              Math.max(3, cellW * 0.05),
              0,
              2 * Math.PI
            );
            this.waferCtx.fill();
          });

          // Í∏∞Ï§ÄÏ†ê (Îπ®Í∞Ñ Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.waferCtx.fillStyle = "red";
          const refPixelX = scaledOriginX + 0.5 * cellW;
          const refPixelY = scaledOriginY + 0.5 * cellH;
          this.waferCtx.beginPath();
          this.waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // ÌòÑÏû¨ Ìå®Ïπò (Ï¥àÎ°ù Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.drawCurrentPatchIndicator(
            cellW,
            cellH,
            scaledOriginX,
            scaledOriginY
          );

          // bin Î≤îÎ°Ä ÏóÖÎç∞Ïù¥Ìä∏
          this.updateBinLegend();
        }

        /**
         * ÌòÑÏû¨ Î≥¥Í≥† ÏûàÎäî Ìå®ÏπòÎ•º Ï¥àÎ°ùÏ†êÏúºÎ°ú ÌëúÏãú (Ïä§ÏºÄÏùº Ï†ÅÏö©)
         */
        drawCurrentPatchIndicator(cellW, cellH, scaledOriginX, scaledOriginY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          const currentPatch =
            this.patchManager.allPatchPages[this.patchManager.currentPatchPage];
          if (!currentPatch) return;

          // ÌòÑÏû¨ Ìå®ÏπòÏùò Ï¢åÌëú ÌååÏã±
          const match = currentPatch.coord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) {
            console.log(
              "Failed to parse patch coordinates:",
              currentPatch.coord
            );
            return;
          }

          const patchX = parseInt(match[1], 10);
          const patchY = parseInt(match[2], 10);

          // ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò (Ïä§ÏºÄÏùº Ï†ÅÏö©)
          const px = scaledOriginX + (patchX - this.refGrid.x + 0.5) * cellW;
          const py = scaledOriginY + (patchY - this.refGrid.y + 0.5) * cellH;

          console.log(
            `Drawing green dot for patch (${patchX},${patchY}) at screen (${px},${py})`
          );

          // Ï¥àÎ°ùÏ†ê Í∑∏Î¶¨Í∏∞ (Îπ®Í∞ÑÏ†êÎ≥¥Îã§ ÏïΩÍ∞Ñ ÌÅ¨Í≤å)
          this.waferCtx.fillStyle = "lime";
          this.waferCtx.beginPath();
          this.waferCtx.arc(px, py, 8, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
          this.waferCtx.strokeStyle = "darkgreen";
          this.waferCtx.lineWidth = 2;
          this.waferCtx.stroke();
        }

        setupCanvasDrag() {
          let dragging = false;
          let start = { x: 0, y: 0 };
          let previewUpdateTimeout = null;

          this.waferCanvas.addEventListener("mousedown", (e) => {
            dragging = true;
            this.waferCanvas.classList.add("dragging");
            start.x = e.clientX;
            start.y = e.clientY;
          });

          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              this.waferCanvas.classList.remove("dragging");
              // ÎìúÎûòÍ∑∏ ÏôÑÎ£å Ïãú Ï¶âÏãú ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
              this.updateGridPreview();
            }
          });

          window.addEventListener("mousemove", async (e) => {
            if (!dragging) return;
            const deltaX = e.clientX - start.x;
            const deltaY = e.clientY - start.y;

            // Ïä§ÏºÄÏùºÏùÑ Í≥†Î†§Ìïú ÎìúÎûòÍ∑∏
            this.origin.x += deltaX / this.currentScale;
            this.origin.y += deltaY / this.currentScale;

            start.x = e.clientX;
            start.y = e.clientY;
            await this.drawPage();

            // ÎìúÎûòÍ∑∏ Ï§ë ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏ (throttling Ï†ÅÏö©)
            if (previewUpdateTimeout) {
              clearTimeout(previewUpdateTimeout);
            }
            previewUpdateTimeout = setTimeout(() => {
              this.updateGridPreview();
            }, 100); // 100ms ÎîúÎ†àÏù¥
          });
        }

        setupReferenceMode() {
          const setRefBtn = document.getElementById("setRefBtn");
          const refXInput = document.getElementById("refX");
          const refYInput = document.getElementById("refY");

          // Ï¢åÌëú ÏûÖÎ†•Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
          const updateReference = async () => {
            const refX = parseInt(refXInput.value) || 0;
            const refY = parseInt(refYInput.value) || 0;

            this.refGrid = { x: refX, y: refY };
            await this.drawPage();
            this.updateGridPreview();

            console.log(`Reference point set to: (${refX}, ${refY})`);
          };

          // Apply Reference Î≤ÑÌäº ÌÅ¥Î¶≠
          setRefBtn.onclick = updateReference;

          // Enter ÌÇ§ Ï≤òÎ¶¨
          refXInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          refYInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          // Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
          refXInput.addEventListener("input", updateReference);
          refYInput.addEventListener("input", updateReference);
        }

        async extractPatches() {
          if (!this.pages.length) {
            alert("TIFF ÌååÏùºÏùÑ Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
            return;
          }
          if (!this.csvRows.length) {
            alert("CSV Îç∞Ïù¥ÌÑ∞Î•º Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
            return;
          }

          // Í∏∞Ï°¥ Î≥¥Ïù¥Îìú Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();
          console.log("Void data cleared for new patch extraction");

          this.allPatchPages = [];
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;
          const tMean = parseFloat(document.getElementById("targetMean").value);
          const tStd = parseFloat(document.getElementById("targetStd").value);
          const pad = parseInt(document.getElementById("padPx").value, 10);
          window.allPatchCanvases = [];

          this.csvRows.forEach((r) => {
            const pageData = {
              coord: `(${r.x},${r.y})`,
              layers: [],
              type: r.type,
            };

            this.pages.forEach((src, pageIdx) => {
              const gx = this.origin.x + (r.x - this.refGrid.x) * cellW;
              const gy = this.origin.y + (r.y - this.refGrid.y) * cellH;

              console.log(gx, gy, cellW, cellH);

              const titleH = 40;
              const patchSize = 300; // Í≥†Ï†ï Ìå®Ïπò ÌÅ¨Í∏∞
              const c = document.createElement("canvas");
              c.width = patchSize;
              c.height = (patchSize * cellH) / cellW + titleH;
              const ctx = c.getContext("2d");

              const label = `X${padCoord(r.x)}_Y${padCoord(r.y)}_L${String(
                pageIdx + 1
              ).padStart(2, "0")}_LEG:${r.type || "NA"}`;
              ctx.fillStyle = "#000";
              ctx.fillRect(0, 0, patchSize, titleH);
              ctx.fillStyle = "#fff";
              ctx.font = "20px sans-serif";
              ctx.textBaseline = "middle";
              ctx.fillText(label, 6, titleH / 2);

              ctx.drawImage(
                src,
                gx,
                gy,
                cellW,
                cellH,
                0,
                titleH,
                patchSize,
                (patchSize * cellH) / cellW
              );

              // Ïù¥ÎØ∏ÏßÄ Ìñ•ÏÉÅ Î®ºÏ†Ä ÏàòÌñâ
              const subImg = ctx.getImageData(0, titleH, c.width, c.height);
              const tmp = document.createElement("canvas");
              tmp.width = c.width;
              tmp.height = c.height;
              tmp.getContext("2d").putImageData(subImg, 0, 0);
              ImageProcessor.enhanceToTarget(
                tmp.getContext("2d"),
                tMean,
                tStd,
                pad
              );
              ctx.putImageData(
                tmp.getContext("2d").getImageData(0, 0, c.width, c.height),
                0,
                titleH
              );

              // Î≥¥Ï†ï ÏôÑÎ£åÎêú Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
              const enhancedImageData = ctx.getImageData(
                0,
                0,
                c.width,
                c.height
              );

              this.attachVoidEvents(c, label, enhancedImageData);

              pageData.layers.push({
                canvas: c,
                label,
                type: r.type || "NA",
                layer: pageIdx + 1,
                imageData: enhancedImageData,
              });

              const typeFolder = r.type
                ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
                : "NA";
              window.allPatchCanvases.push({
                canvas: c,
                layer: pageIdx + 1,
                label,
                type: typeFolder,
              });
            });

            this.allPatchPages.push(pageData);
          });

          this.currentPatchPage = 0;
          await this.showPatchPage(0);

          // Î≥¥Ïù¥Îìú Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî ÌõÑ Ìå®Ïπò Î∑∞Ïñ¥ Í∞±Ïã†
          this.refreshCurrentPatches();

          console.log(
            `Ìå®Ïπò Ï∂îÏ∂ú ÏôÑÎ£å: ${this.allPatchPages.length}Í∞ú Ï¢åÌëú, Ï¥ù ${
              this.allPatchPages.length * this.pages.length
            }Í∞ú Ìå®Ïπò`
          );
        }

        attachVoidEvents(canvas, patchLabel, imageData) {
          const ctx = canvas.getContext("2d");
          const { chipCoord, layer } = parsePatchLabel(patchLabel);
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return;

          const x = parseInt(match[1], 10);
          const y = parseInt(match[2], 10);

          const repaint = () => {
            ctx.putImageData(imageData, 0, 0);
            this.voidManager.drawVoids(ctx, patchLabel);
          };

          // Î≥¥Ïù¥Îìú ÎßàÌÇπ
          canvas.addEventListener("mousedown", (e) => {
            if (!this.voidMarkMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const sx = (e.clientX - rect.left) * scaleX;
            const sy = (e.clientY - rect.top) * scaleY;

            const drag = (me) => {
              const cx = (me.clientX - rect.left) * scaleX;
              const cy = (me.clientY - rect.top) * scaleY;
              repaint();
              const selType =
                document.getElementById("voidTypeSelect").value || "default";
              ctx.strokeStyle = VOID_COLORS[selType] || VOID_COLORS.default;
              ctx.lineWidth = 2;
              ctx.beginPath();

              if (selType === "bbox") {
                // bbox ÌÉÄÏûÖÏù¥Î©¥ ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞
                ctx.strokeRect(
                  Math.min(sx, cx),
                  Math.min(sy, cy),
                  Math.abs(cx - sx),
                  Math.abs(cy - sy)
                );
              } else {
                // ÏùºÎ∞ò void ÌÉÄÏûÖÏù¥Î©¥ ÌÉÄÏõê Í∑∏Î¶¨Í∏∞
                ctx.ellipse(
                  (sx + cx) / 2,
                  (sy + cy) / 2,
                  Math.abs(cx - sx) / 2,
                  Math.abs(cy - sy) / 2,
                  0,
                  0,
                  2 * Math.PI
                );
                ctx.stroke();
              }
            };

            const up = (ue) => {
              document.removeEventListener("mousemove", drag);
              document.removeEventListener("mouseup", up);
              const ex = (ue.clientX - rect.left) * scaleX;
              const ey = (ue.clientY - rect.top) * scaleY;
              const type =
                document.getElementById("voidTypeSelect").value || "void";

              let newVoid;

              if (type === "bbox") {
                // bbox ÌÉÄÏûÖÏù¥Î©¥ ÏÇ¨Í∞ÅÌòïÏúºÎ°ú Ï†ÄÏû•
                const rectX = Math.min(sx, ex);
                const rectY = Math.min(sy, ey);
                const rectW = Math.abs(ex - sx);
                const rectH = Math.abs(ey - sy);

                // bboxÎäî centerX, centerYÏóê Ï¢åÏÉÅÎã® Ï¢åÌëúÎ•º Ï†ÄÏû•ÌïòÍ≥† radiusX, radiusYÏóê ÎÑàÎπÑ, ÎÜíÏù¥Î•º Ï†ÄÏû•
                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  rectX, // centerXÏóê x Ï¢åÌëú
                  rectY, // centerYÏóê y Ï¢åÌëú
                  rectW, // radiusXÏóê width
                  rectH // radiusYÏóê height
                );
              } else {
                // ÏùºÎ∞ò void ÌÉÄÏûÖÏù¥Î©¥ ÌÉÄÏõêÏúºÎ°ú Ï†ÄÏû•
                const centerX = (sx + ex) / 2;
                const centerY = (sy + ey) / 2;
                const radiusX = Math.abs(ex - sx) / 2;
                const radiusY = Math.abs(ey - sy) / 2;

                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  centerX,
                  centerY,
                  radiusX,
                  radiusY
                );
              }

              if (newVoid) {
                this.patchManager.refreshCurrentPatches();
                this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
              } else {
                repaint();
              }
            };

            // void ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎßå void Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
            if (this.voidMarkMode) {
              document.addEventListener("mousemove", drag);
              document.addEventListener("mouseup", up);
            }
          });

          // Î≥¥Ïù¥Îìú ÏÇ≠Ï†ú (Ìï¥Îãπ Î†àÏù¥Ïñ¥ÏóêÏÑúÎßå)
          canvas.addEventListener("click", (e) => {
            if (!this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            console.log(
              `Attempting to delete void at (${x},${y},${layer}) click:(${clickX},${clickY})`
            );

            const deleted = this.voidManager.deleteVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );

            console.log(`Delete result: ${deleted}`);

            if (deleted) {
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
            }
          });

          // Î≥¥Ïù¥Îìú Ìé∏Ïßë (Ìï¥Îãπ Î†àÏù¥Ïñ¥ÏóêÏÑúÎßå)
          canvas.addEventListener("mousedown", (e) => {
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            const editableVoid = this.voidManager.findEditableVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );
            if (!editableVoid) return;

            this.selectedVoid = editableVoid;
            const originalCenterX = editableVoid.centerX;
            const originalCenterY = editableVoid.centerY;

            // Ïù¥Îèô vs ÌÅ¨Í∏∞Ï°∞Ï†à ÌåêÎã®
            const dx = clickX - editableVoid.centerX;
            const dy = clickY - editableVoid.centerY;
            const angle = Math.atan2(dy, dx);
            const rB =
              (editableVoid.radiusX * editableVoid.radiusY) /
              Math.sqrt(
                (editableVoid.radiusY * Math.cos(angle)) ** 2 +
                  (editableVoid.radiusX * Math.sin(angle)) ** 2
              );
            const dist = Math.hypot(dx, dy);

            this.resizeMode = Math.abs(dist - rB) <= CONFIG.TOLERANCE;
            const offsetX = clickX - editableVoid.centerX;
            const offsetY = clickY - editableVoid.centerY;

            const moveHandler = (me) => {
              const mx = (me.clientX - rect.left) * scaleX;
              const my = (me.clientY - rect.top) * scaleY;

              if (this.resizeMode) {
                const newRadiusX = Math.abs(mx - editableVoid.centerX);
                const newRadiusY = Math.abs(my - editableVoid.centerY);

                if (me.shiftKey) {
                  const r = Math.max(newRadiusX, newRadiusY);
                  editableVoid.radiusX = editableVoid.radiusY = r;
                } else {
                  editableVoid.radiusX = newRadiusX;
                  editableVoid.radiusY = newRadiusY;
                }
              } else {
                editableVoid.centerX = mx - offsetX;
                editableVoid.centerY = my - offsetY;
              }

              repaint();
            };

            const upHandler = () => {
              document.removeEventListener("mousemove", moveHandler);
              document.removeEventListener("mouseup", upHandler);

              // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÄÏû• (Ïã§Ï†úÎ°úÎäî Ïù¥ÎØ∏ editableVoid Í∞ùÏ≤¥Í∞Ä ÏàòÏ†ïÎêòÏóàÏùå)
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
              this.selectedVoid = null;
            };

            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
          });
        }

        refreshCurrentPatches() {
          if (
            !this.allPatchPages.length ||
            this.currentPatchPage >= this.allPatchPages.length
          )
            return;

          const currentPage = this.allPatchPages[this.currentPatchPage];

          // Ïã§Ï†ú ÌÅ¨Í∏∞ ÏÑ§Ï†ï Í∞í Í∞ÄÏ†∏Ïò§Í∏∞
          const realChipSize =
            +document.getElementById("realChipSize").value || 1000;
          const canvasChipSize =
            +document.getElementById("canvasChipSize").value || 100;

          currentPage.layers.forEach((layerInfo) => {
            const ctx = layerInfo.canvas.getContext("2d");
            ctx.putImageData(layerInfo.imageData, 0, 0);
            this.voidManager.drawVoids(ctx, layerInfo.label, {
              realChipSize,
              canvasChipSize,
              showSizes: true,
            });
          });

          // void JSON ÏóÖÎç∞Ïù¥Ìä∏
          this.updateVoidJsonDisplay();

          // bin Î≤îÎ°Ä ÏóÖÎç∞Ïù¥Ìä∏
          this.updateBinLegend();

          // Ïõ®Ïù¥Ìçº Í∑∏Î¶¨ÎìúÎèÑ Îã§Ïãú Í∑∏Î†§ÏÑú bin ÏÉâÏÉÅ Î∞òÏòÅ
          this.drawPage();

          // Ìå®Ïπò Î∑∞Ïñ¥ Ï†ÑÏ≤¥ ÏÉàÎ°úÍ≥†Ïπ® (void ÎßàÏä§ÌÅ¨ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
          this.showPatchPage(this.currentPatchPage);
        }

        async showPatchPage(idx) {
          if (!this.allPatchPages.length) return;
          if (idx < 0) idx = 0;
          if (idx >= this.allPatchPages.length)
            idx = this.allPatchPages.length - 1;
          this.currentPatchPage = idx;

          const page = this.allPatchPages[idx];
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3 >Chip ${page.coord}</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          // void ÎßàÏä§ÌÅ¨ Î®ºÏ†Ä Ï∂îÍ∞Ä (Í∞ÄÏû• Îß® ÏúÑ, Ìï≠ÏÉÅ ÌëúÏãú)
          const voidMaskCanvas = this.createVoidMaskCanvas(
            page.coord,
            page.type,
            true
          ); // Ìï≠ÏÉÅ ÏÉùÏÑ±
          const voidItem = document.createElement("div");
          voidItem.className = "layer-item";
          voidItem.innerHTML = `<div class="layer-label" style="color: #e74c3c">VOID MASK (ALL LAYERS)</div>`;
          voidItem.appendChild(voidMaskCanvas);
          layersWrap.appendChild(voidItem);

          // Í∏∞Ï°¥ Î†àÏù¥Ïñ¥Îì§ Ï∂îÍ∞Ä
          page.layers.forEach((l) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label">${l.label}</div>`;
            item.appendChild(l.canvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById("pageInfo").textContent = `Page ${
            this.currentPatchPage + 1
          } / ${this.allPatchPages.length}`;

          // ÌòÑÏû¨ Ìå®Ïπò Î≥ÄÍ≤Ω Ïãú Í∑∏Î¶¨ÎìúÏùò Ï¥àÎ°ùÏ†ê ÏóÖÎç∞Ïù¥Ìä∏
          await this.drawPage();
        }

        /**
         * ÌååÏùº/Ìè¥ÎçîÎ™ÖÏóêÏÑú ÌóàÏö©ÎêòÏßÄ ÏïäÎäî Î¨∏Ïûê Ï†úÍ±∞
         */
        sanitizeFileName(fileName) {
          // Windows/Mac/LinuxÏóêÏÑú ÌóàÏö©ÎêòÏßÄ ÏïäÎäî Î¨∏ÏûêÎì§ Ï†úÍ±∞
          return fileName
            .replace(/[<>:"\/\\|?*\x00-\x1f]/g, "_") // ÌäπÏàòÎ¨∏ÏûêÎ•º '_'Î°ú ÎåÄÏ≤¥
            .replace(/\.$/, "_") // ÎßàÏßÄÎßâ Ï†ê Ï†úÍ±∞
            .replace(/\s+/g, "_") // Í≥µÎ∞±ÏùÑ '_'Î°ú ÎåÄÏ≤¥
            .substring(0, 255); // Í∏∏Ïù¥ Ï†úÌïú
        }

        /**
         * README ÎÇ¥Ïö© ÏÉùÏÑ±
         */
        generateReadmeContent(metadata) {
          return `# Wafer Patch Extraction Data

TIFF File: ${metadata.tiffFileName || "Unknown"}
Extraction Date: ${metadata.timestamp}
Version: ${metadata.version}

## Grid Settings
- Columns: ${metadata.gridSettings.cols}
- Rows: ${metadata.gridSettings.rows}
- Cell Width: ${metadata.gridSettings.cellW}px
- Cell Height: ${metadata.gridSettings.cellH}px

## Alignment
- Origin: (${metadata.origin.x}, ${metadata.origin.y})
- Reference Grid: (${metadata.referenceGrid.x}, ${metadata.referenceGrid.y})

## Enhancement Settings
- Alpha (Contrast): ${metadata.enhanceSettings.alpha}
- Beta (Brightness): ${metadata.enhanceSettings.beta}
- Target Mean: ${metadata.enhanceSettings.targetMean}
- Target Std: ${metadata.enhanceSettings.targetStd}
- Padding: ${metadata.enhanceSettings.padPx}px

## Extraction Info
- Total Pages: ${metadata.extractionInfo.totalPages}
- Total Coordinates: ${metadata.extractionInfo.totalCoordinates}
- Total Patches: ${metadata.extractionInfo.totalPatches}
- Patch Size: ${metadata.extractionInfo.patchSize}px

## Folder Structure
- no_voids/[type]/layer_[XX]/[patch_name].png (patches without voids)
- split/[type]/layer_[XX]/[patch_name].png (patches with void markings)
- merge/[type]/[patch_name]_merge.png (merged mask layers)
- summary/[type]_summary.png (type-based void pattern summaries)
- metadata.json: Grid and extraction settings
- coordinates.json: Chip coordinate data
- voids.json: Void detection data
`;
        }

        /**
         * Summary Î™®Îìú Ìï¥Ï†ú
         */
        exitSummaryMode() {
          if (this.showingSummary) {
            this.showingSummary = false;
            const summaryBtn = document.getElementById("showSummary");
            summaryBtn.classList.remove("mode-on");
          }
        }

        showTypeSummary() {
          // ÌÜ†Í∏Ä Í∏∞Îä•: Ïù¥ÎØ∏ summary Î™®ÎìúÎ©¥ ÏõêÎûò Ìå®Ïπò Î∑∞Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞
          if (this.showingSummary) {
            this.exitSummaryMode();

            // ÌòÑÏû¨ Ìå®Ïπò ÌéòÏù¥ÏßÄÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞
            if (this.patchManager.allPatchPages.length > 0) {
              this.patchManager.showPatchPage(
                this.patchManager.currentPatchPage
              );
              // Í∑∏Î¶¨ÎìúÏùò Ï¥àÎ°ùÏ†êÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
              this.drawPage();
            }
            return;
          }

          if (!this.patchManager.allPatchPages.length) {
            alert("Î®ºÏ†Ä Extract PatchesÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî.");
            return;
          }

          // Î™®Îì† ÌÉÄÏûÖÏùò summary ÎßàÏä§ÌÅ¨ ÏÉùÏÑ±
          const summaryMasks = this.patchManager.createAllTypeSummaryMasks();

          if (summaryMasks.size === 0) {
            alert(
              "ÏÉùÏÑ±Ìï† summaryÍ∞Ä ÏóÜÏäµÎãàÎã§. voidÎ•º ÎßàÌÇπÌïú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî."
            );
            return;
          }

          // Summary Î™®ÎìúÎ°ú Ï†ÑÌôò
          this.showingSummary = true;
          const summaryBtn = document.getElementById("showSummary");
          summaryBtn.classList.add("mode-on");

          // Ìå®Ïπò Î∑∞Ïñ¥Ïóê summary ÎßàÏä§ÌÅ¨Îì§ ÌëúÏãú
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3>Type Summary - All Void Patterns</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          summaryMasks.forEach((summaryCanvas, chipType) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label" style="color: #e74c3c">${chipType.toUpperCase()} - ALL VOIDS</div>`;
            item.appendChild(summaryCanvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById(
            "pageInfo"
          ).textContent = `Type Summary (${summaryMasks.size} types) - Click again to return`;

          console.log(
            `Displayed summary for types: ${Array.from(
              summaryMasks.keys()
            ).join(", ")}`
          );
        }

        showVoidStats() {
          const stats = this.voidManager.getStats();
          alert(`Void Statistics:
Total Voids: ${stats.totalVoids}

By Type:
${Object.entries(stats.byType)
  .map(([type, count]) => `${type}: ${count}`)
  .join("\n")}

By Layer:
${Object.entries(stats.byLayer)
  .map(([layer, count]) => `Layer ${layer}: ${count}`)
  .join("\n")}

Check console for detailed info.`);
          console.log("Detailed void statistics:", stats);
        }

        debugCheck() {
          console.log("=== WAFER APP V2 DEBUG ===");
          console.log("Pages loaded:", this.pages.length);
          console.log("CSV rows:", this.csvRows.length);
          console.log("Patch pages:", this.allPatchPages.length);

          this.voidManager.debug();

          alert(`Debug Info:
Pages: ${this.pages.length}
CSV Rows: ${this.csvRows.length}
Void Records: ${this.voidManager.voids.size}
Check console for details.`);
        }

        /**
         * Ìå®Ïπò Ï†ïÎ†¨ ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateGridPreview() {
          const canvas = this.gridPreviewCanvas;
          const ctx = this.gridPreviewCtx;
          const statusDiv = document.getElementById("previewStatus");

          // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f8f8f8";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
          if (!this.pages.length) {
            ctx.fillStyle = "#999";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
              "Load TIFF file to see patch samples",
              canvas.width / 2,
              canvas.height / 2
            );
            statusDiv.textContent = "Load TIFF to see patch samples";
            return;
          }

          // ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Ïù¥ÎØ∏ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
          const currentPage = this.pages[this.pageIndex] || this.pages[0];

          // Í∑∏Î¶¨Îìú ÌååÎùºÎØ∏ÌÑ∞
          const cellW = +document.getElementById("cellW").value || 100;
          const cellH = +document.getElementById("cellH").value || 100;

          // ÏÉòÌîå Ï¢åÌëú Í≤∞Ï†ï
          const sampleCoords = this.getSampleCoordsForPreview();

          if (sampleCoords.length === 0) {
            // Î≥∏Îî© Ï¢åÌëúÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏÉòÌîå ÏúÑÏπò ÏÇ¨Ïö©
            sampleCoords.push(
              { x: 0, y: 0, label: "Center sample" },
              { x: 2, y: 1, label: "Sample 2" },
              { x: -1, y: -1, label: "Sample 3" }
            );
          }

          // ÏÉòÌîå Ìå®ÏπòÎì§ÏùÑ ÌîÑÎ¶¨Î∑∞Ïóê Í∑∏Î¶¨Í∏∞
          this.drawPatchSamples(ctx, currentPage, sampleCoords, cellW, cellH);

          // ÏÉÅÌÉú ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
          statusDiv.textContent = `Showing ${sampleCoords.length} patch samples (Cell: ${cellW}√ó${cellH})`;
        }

        /**
         * ÌîÑÎ¶¨Î∑∞Ïö© ÏÉòÌîå Ï¢åÌëú Í∞ÄÏ†∏Ïò§Í∏∞
         */
        getSampleCoordsForPreview() {
          if (this.csvRows.length === 0) return [];

          const samples = [];
          const maxSamples = 4; // ÌîÑÎ¶¨Î∑∞ÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏµúÎåÄ ÏÉòÌîå Ïàò

          if (this.csvRows.length <= maxSamples) {
            // Ï†ÑÏ≤¥ Ï¢åÌëúÍ∞Ä Ï†ÅÏúºÎ©¥ Î™®Îëê ÌëúÏãú
            return this.csvRows.map((coord, i) => ({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            }));
          }

          // Í∑†Îì±ÌïòÍ≤å Î∂ÑÏÇ∞Îêú ÏÉòÌîå ÏÑ†ÌÉù
          const step = Math.floor(this.csvRows.length / maxSamples);
          for (let i = 0; i < maxSamples; i++) {
            const coord = this.csvRows[i * step];
            samples.push({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            });
          }

          return samples;
        }

        /**
         * Ìå®Ïπò ÏÉòÌîåÎì§ÏùÑ ÌîÑÎ¶¨Î∑∞ Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶¨Í∏∞
         */
        drawPatchSamples(ctx, sourcePage, sampleCoords, cellW, cellH) {
          const canvas = ctx.canvas;
          const padding = 5;
          const cols = 2; // 2Ïó¥Î°ú Î∞∞Ïπò
          const rows = Math.ceil(sampleCoords.length / cols);

          const availableWidth = canvas.width - padding * 2;
          const availableHeight = canvas.height - padding * 2 - 20; // ÌÖçÏä§Ìä∏ Í≥µÍ∞Ñ

          const patchW = Math.floor(availableWidth / cols) - padding;
          const patchH = Math.floor(availableHeight / rows) - padding;

          // Ìå®Ïπò ÌÅ¨Í∏∞Î•º Ï†ïÏÇ¨Í∞ÅÌòïÏúºÎ°ú ÎßûÏ∂îÍ∏∞
          const patchSize = Math.min(patchW, patchH);

          sampleCoords.forEach((coord, index) => {
            const col = index % cols;
            const row = Math.floor(index / cols);

            const drawX = padding + col * (patchSize + padding);
            const drawY = padding + row * (patchSize + padding) + 15; // ÌÖçÏä§Ìä∏ Í≥µÍ∞Ñ

            // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÏóêÏÑú Ìå®Ïπò ÏòÅÏó≠ Í≥ÑÏÇ∞
            const sourceX = this.origin.x + (coord.x - this.refGrid.x) * cellW;
            const sourceY = this.origin.y + (coord.y - this.refGrid.y) * cellH;

            console.log(sourceX, sourceY, cellW, cellH);

            // Ìå®Ïπò Í∑∏Î¶¨Í∏∞
            try {
              ctx.drawImage(
                sourcePage,
                sourceX,
                sourceY,
                cellW,
                cellH,
                drawX,
                drawY,
                patchSize,
                patchSize
              );

              // Ìå®Ïπò Í≤ΩÍ≥ÑÏÑ†
              ctx.strokeStyle = "#333";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              // Ï¢åÌëú ÎùºÎ≤®
              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            } catch (error) {
              // Ïù¥ÎØ∏ÏßÄ ÏòÅÏó≠Ïù¥ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Í≤ΩÏö∞
              ctx.fillStyle = "#ffeeee";
              ctx.fillRect(drawX, drawY, patchSize, patchSize);
              ctx.strokeStyle = "#ff0000";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              ctx.fillStyle = "#ff0000";
              ctx.font = "9px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(
                "Out of",
                drawX + patchSize / 2,
                drawY + patchSize / 2 - 5
              );
              ctx.fillText(
                "bounds",
                drawX + patchSize / 2,
                drawY + patchSize / 2 + 5
              );

              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            }

            // Í∞Å Ìå®ÏπòÏóê Îπ®Í∞ÑÏ†ê ÌëúÏãú (Í∏∞Ï§ÄÏ†êÏù¥ Ïù¥ Ìå®ÏπòÏùò Ïñ¥Îäê ÏúÑÏπòÏù∏ÏßÄ)
            this.drawRedPointOnPatch(
              ctx,
              coord,
              drawX,
              drawY,
              patchSize,
              cellW,
              cellH
            );
          });
        }

        /**
         * Ïã§ÏãúÍ∞Ñ void ÎßàÏä§ÌÅ¨ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
         */
        createVoidMaskCanvas(chipCoord, type, forceCreate = false) {
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return null;

          const chipX = parseInt(match[1], 10);
          const chipY = parseInt(match[2], 10);
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;

          // Ìï¥Îãπ Ïπ©Ïóê voidÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
          const chipVoids = [];
          for (const [voidKey, voidData] of this.voidManager.voids.entries()) {
            if (voidData.x === chipX && voidData.y === chipY) {
              chipVoids.push(voidData);
            }
          }

          // forceCreateÍ∞Ä falseÏù¥Í≥† voidÍ∞Ä ÏóÜÏúºÎ©¥ null Î∞òÌôò (Ïù¥Ï†Ñ ÎèôÏûë)
          if (!forceCreate && chipVoids.length === 0) {
            return null;
          }

          // Ìà¨Î™Ö ÎßàÏä§ÌÅ¨ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ± (voidÍ∞Ä ÏóÜÏñ¥ÎèÑ Îπà Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±)
          const patchSize = 300;
          const titleH = 40;
          const maskCanvas = document.createElement("canvas");
          maskCanvas.width = patchSize;
          maskCanvas.height = (patchSize * cellH) / cellW + titleH;
          const maskCtx = maskCanvas.getContext("2d");

          // Î∞∞Í≤ΩÏùÑ Ìà¨Î™ÖÌïòÍ≤å ÏÑ§Ï†ï
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

          // ÌÉÄÏù¥ÌãÄ ÏòÅÏó≠ (Í≤ÄÏùÄ Î∞∞Í≤Ω)
          const label = `X${padCoord(chipX)}_Y${padCoord(
            chipY
          )}_L00_LEG:${type}`;
          maskCtx.fillStyle = "#000";
          maskCtx.fillRect(0, 0, patchSize, titleH);
          maskCtx.fillStyle = "#fff";
          maskCtx.font = "20px sans-serif";
          maskCtx.textBaseline = "middle";
          maskCtx.fillText(label, 6, titleH / 2);

          // void ÎßàÏä§ÌÅ¨ Í∑∏Î¶¨Í∏∞ (voidÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå)
          if (chipVoids.length > 0) {
            // ÌÜµÌï©Îêú void Í∑∏Î¶¨Í∏∞ Ìï®Ïàò ÏÇ¨Ïö©
            this.voidManager.drawVoidsUnified(maskCtx, chipVoids, {
              titleOffset: 0, // void Ï¢åÌëúÍ∞Ä Ïù¥ÎØ∏ title ÏòÅÏó≠ Ìè¨Ìï®
              alpha: 1.0,
              lineDash: [],
            });
          }
          // voidÍ∞Ä ÏóÜÏúºÎ©¥ ÌÉÄÏù¥ÌãÄÎßå ÏûàÎäî Îπà Ï∫îÎ≤ÑÏä§

          return maskCanvas;
        }

        /**
         * Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏÑ§Ï†ï Ï†ïÎ≥¥ Ï†ÅÏö©
         */
        applyMetadata(metadata) {
          try {
            // Í∑∏Î¶¨Îìú ÏÑ§Ï†ï Ï†ÅÏö©
            if (metadata.gridSettings) {
              document.getElementById("cols").value =
                metadata.gridSettings.cols || 8;
              document.getElementById("rows").value =
                metadata.gridSettings.rows || 8;
              document.getElementById("cellW").value =
                metadata.gridSettings.cellW || 100;
              document.getElementById("cellH").value =
                metadata.gridSettings.cellH || 100;
            }

            // OriginÍ≥º Ï∞∏Ï°∞ Í∑∏Î¶¨Îìú Ï†ÅÏö©
            if (metadata.origin) {
              this.origin = { ...metadata.origin };
            }
            if (metadata.referenceGrid) {
              this.refGrid = { ...metadata.referenceGrid };
              document.getElementById("refX").value =
                metadata.referenceGrid.x || 0;
              document.getElementById("refY").value =
                metadata.referenceGrid.y || 0;
            }

            // Ìñ•ÏÉÅ ÏÑ§Ï†ï Ï†ÅÏö©
            if (metadata.enhanceSettings) {
              const settings = metadata.enhanceSettings;
              document.getElementById("alpha").value = settings.alpha || 1.2;
              document.getElementById("beta").value = settings.beta || 10;
              document.getElementById("targetMean").value =
                settings.targetMean || 0.5;
              document.getElementById("targetStd").value =
                settings.targetStd || 0.2;
              document.getElementById("padPx").value = settings.padPx || 10;
            }

            // TIFF ÌååÏùºÎ™Ö ÏÑ§Ï†ï (ÏûàÎäî Í≤ΩÏö∞)
            if (metadata.tiffFileName) {
              this.currentTiffFileName = metadata.tiffFileName;
              document.getElementById(
                "localTiffPath"
              ).value = `/${metadata.tiffFileName}.tif`;
            }

            return true;
          } catch (error) {
            console.error("Error applying metadata:", error);
            return false;
          }
        }

        /**
         * JSON ÌååÏùºÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
         */
        extractMetadataFromJson(jsonData) {
          // ÏßÅÏ†ë metadata Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
          if (jsonData.gridSettings && jsonData.origin) {
            return jsonData;
          }

          // void JSON ÌååÏùºÏù∏ Í≤ΩÏö∞ (metadata ÌïÑÎìú ÏïàÏóê ÏûàÏùå)
          if (jsonData.metadata) {
            return jsonData.metadata;
          }

          // Îã§Î•∏ Íµ¨Ï°∞Ïùº Ïàò ÏûàÏúºÎØÄÎ°ú null Î∞òÌôò
          return null;
        }

        /**
         * ÌòÑÏû¨ Í∑∏Î¶¨Îìú ÏÑ§Ï†ï Ï†ïÎ≥¥ ÏàòÏßë
         */
        getGridMetadata() {
          return {
            tiffFileName: this.currentTiffFileName,
            gridSettings: {
              cols: +document.getElementById("cols").value,
              rows: +document.getElementById("rows").value,
              cellW: +document.getElementById("cellW").value,
              cellH: +document.getElementById("cellH").value,
            },
            origin: { ...this.origin },
            referenceGrid: { ...this.refGrid },
            enhanceSettings: {
              targetMean: parseFloat(
                document.getElementById("targetMean").value
              ),
              targetStd: parseFloat(document.getElementById("targetStd").value),
              padPx: parseInt(document.getElementById("padPx").value, 10),
            },
            extractionInfo: {
              totalPages: this.pages.length,
              totalCoordinates: this.csvRows.length,
              totalPatches:
                this.patchManager.allPatchPages.length * this.pages.length,
              patchSize: 300, // Í≥†Ï†ï Ìå®Ïπò ÌÅ¨Í∏∞
            },
            timestamp: new Date().toISOString(),
            version: "v2",
          };
        }

        /**
         * ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ•º Ìè¨Ìï®Ìïú ÌååÏùºÎ™Ö ÏÉùÏÑ±
         */
        generateFileName(suffix = "", extension = "") {
          const now = new Date();
          const timestamp =
            now.getFullYear() +
            String(now.getMonth() + 1).padStart(2, "0") +
            String(now.getDate()).padStart(2, "0") +
            "_" +
            String(now.getHours()).padStart(2, "0") +
            String(now.getMinutes()).padStart(2, "0") +
            String(now.getSeconds()).padStart(2, "0");

          const baseName = this.currentTiffFileName || "wafer_data";
          return `${baseName}_${suffix}_${timestamp}${extension}`;
        }

        /**
         * void JSON ÎèôÍ∏∞Ìôî ÏÑ§Ï†ï
         */
        setupVoidJsonSync() {
          const voidJsonTextarea = document.getElementById("voidJson");

          // textarea Î≥ÄÍ≤Ω Ïãú void Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
          voidJsonTextarea.addEventListener("input", () => {
            try {
              const jsonData = JSON.parse(voidJsonTextarea.value);
              this.loadVoidDataFromJson(jsonData);
              this.patchManager.refreshCurrentPatches();
            } catch (error) {
              // JSON ÌååÏã± Ïò§Î•ò Ïãú Î¨¥Ïãú (ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÏù¥Ìïë Ï§ëÏùº Ïàò ÏûàÏùå)
            }
          });

          // Ï¥àÍ∏∞ ÌëúÏãú
          this.updateVoidJsonDisplay();
        }

        /**
         * void Îç∞Ïù¥ÌÑ∞Î•º JSONÏúºÎ°ú ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateVoidJsonDisplay() {
          const voidJsonTextarea = document.getElementById("voidJson");
          const voidData = this.voidManager.exportVoids();
          voidJsonTextarea.value = JSON.stringify(voidData, null, 2);
        }

        /**
         * JSON Îç∞Ïù¥ÌÑ∞ÏóêÏÑú void Îç∞Ïù¥ÌÑ∞ Î°úÎìú
         */
        loadVoidDataFromJson(jsonData) {
          // Í∏∞Ï°¥ void Îç∞Ïù¥ÌÑ∞ ÌÅ¥Î¶¨Ïñ¥
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();

          // JSON Îç∞Ïù¥ÌÑ∞ÏóêÏÑú void Î≥µÏõê
          jsonData.forEach((voidItem) => {
            const voidKey = voidItem.key;
            delete voidItem.key; // keyÎäî Î≥ÑÎèÑÎ°ú Ï≤òÎ¶¨
            this.voidManager.voids.set(voidKey, voidItem);

            // Ïù∏Îç±Ïä§ Ïπ¥Ïö¥ÌÑ∞ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            const locationKey = this.voidManager.createLocationKey(
              voidItem.x,
              voidItem.y,
              voidItem.layer
            );
            const currentMax =
              this.voidManager.voidIndexCounters.get(locationKey) || 0;
            this.voidManager.voidIndexCounters.set(
              locationKey,
              Math.max(currentMax, voidItem.voidIndex + 1)
            );
          });
        }

        /**
         * Ìå®ÏπòÏóê Îπ®Í∞ÑÏ†ê(Í∏∞Ï§ÄÏ†ê) ÌëúÏãú
         */
        drawRedPointOnPatch(
          ctx,
          coord,
          patchX,
          patchY,
          patchSize,
          cellW,
          cellH
        ) {
          // Í∏∞Ï§ÄÏ†êÏù¥ Ïù¥ Ìå®Ïπò ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
          const refRelativeX = this.refGrid.x - coord.x; // Í∏∞Ï§ÄÏ†êÏùò ÏÉÅÎåÄÏ†Å X ÏúÑÏπò
          const refRelativeY = this.refGrid.y - coord.y; // Í∏∞Ï§ÄÏ†êÏùò ÏÉÅÎåÄÏ†Å Y ÏúÑÏπò

          // Ìå®Ïπò ÎÇ¥Î∂Ä Ï¢åÌëúÎ°ú Î≥ÄÌôò (0~1 Î≤îÏúÑ)
          const refNormalizedX = refRelativeX + 0.5; // Ìå®Ïπò Ï§ëÏã¨Ïù¥ 0.5
          const refNormalizedY = refRelativeY + 0.5;

          // Ìå®Ïπò ÎÇ¥Î∂ÄÏóê ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Îπ®Í∞ÑÏ†ê ÌëúÏãú
          if (
            refNormalizedX >= 0 &&
            refNormalizedX <= 1 &&
            refNormalizedY >= 0 &&
            refNormalizedY <= 1
          ) {
            const redPointX = patchX + refNormalizedX * patchSize;
            const redPointY = patchY + refNormalizedY * patchSize;

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(redPointX, redPointY, 4, 0, 2 * Math.PI);
            ctx.fill();

            // Îπ®Í∞ÑÏ†ê Ï£ºÏúÑÏóê Ìù∞ÏÉâ ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        /**
         * Quick Test Mode - ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏûêÎèô Î°úÎìú
         */
        async loadQuickTestData() {
          const quickBtn = document.getElementById("quickTestBtn");
          const originalText = quickBtn.textContent;

          try {
            quickBtn.textContent = "Loading Test Data...";
            quickBtn.disabled = true;

            // 1. ÌÖåÏä§Ìä∏Ïö© TIFF ÌååÏùº ÏÑ§Ï†ï Î∞è Î°úÎìú
            const testTiffPath = "/realistic_wafer_sample_fast_1000.tif";
            document.getElementById("localTiffPath").value = testTiffPath;

            console.log("üöÄ Quick Test Mode: Loading TIFF file...");

            // TIFF Î°úÎìú
            const rangeServerUrl = `http://localhost:8083${testTiffPath}`;
            this.currentTiffFileName = "realistic_wafer_sample_fast";

            this.showProgress();
            this.updateProgress(10, "Loading test TIFF...", rangeServerUrl);

            this.pages = await ImageProcessor.loadTiffFromServer(
              rangeServerUrl,
              (current, total, details) => {
                const progress = 10 + (current / total) * 40; // 10-50%
                this.updateProgress(
                  progress,
                  `Loading page ${current}/${total}`,
                  details
                );
              }
            );

            this.updateProgress(55, "Loading test coordinates...", "");

            // 2. ÌÖåÏä§Ìä∏Ïö© Bonding Map Í≤©Ïûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            const testBondingMap = `	0	1	2	3	4	5
0	good	dummy	test	edge	good	test
1	dummy	good	good	good	edge	good
2	test	good	good	good	good	good
3	edge	good	good	good	good	good
4	good	edge	good	good	good	good
5	test	good	good	good	good	good`;

            console.log(
              "üöÄ Quick Test Mode: Loading Bonding Map coordinates..."
            );
            this.csvRows = parseBondingMap(testBondingMap);
            this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));

            // Bonding Map textareaÏóê Îç∞Ïù¥ÌÑ∞ ÌëúÏãú
            document.getElementById("csvPaste").value = testBondingMap;

            this.updateProgress(
              70,
              "Updating UI...",
              "Page selector and preview"
            );

            // 3. UI ÏóÖÎç∞Ïù¥Ìä∏
            this.updatePageSelect();
            await this.drawPage();
            this.updateGridPreview();

            this.updateProgress(
              90,
              "Setting optimal settings...",
              "Grid and enhancement"
            );

            // 4. ÏµúÏ†Å ÏÑ§Ï†ï Ï†ÅÏö©
            document.getElementById("cols").value = 6;
            document.getElementById("rows").value = 6;
            document.getElementById("cellW").value = 170;
            document.getElementById("cellH").value = 170;
            document.getElementById("targetMean").value = 0.5;
            document.getElementById("targetStd").value = 0.2;
            document.getElementById("padPx").value = 30;

            // Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï
            document.getElementById("refX").value = 0;
            document.getElementById("refY").value = 0;
            this.refGrid = { x: 0, y: 0 };

            this.updateProgress(
              100,
              "Test data loaded!",
              "Ready for patch extraction"
            );

            console.log("üöÄ Quick Test Mode: Complete!");
            console.log(`- TIFF: ${this.pages.length} pages loaded`);
            console.log(`- Coordinates: ${this.csvRows.length} chips loaded`);

            setTimeout(() => this.hideProgress(), 2000);

            alert(`üöÄ Quick Test Mode Complete!

üìä Data Loaded:
- TIFF: ${this.pages.length} pages
- Coordinates: ${this.csvRows.length} chips
- Grid: 6x6, Cell: 150x150px
- Range: x(0~5), y(0~5)

‚úÖ Ready for testing:
1. Click "Extract Patches" to generate patches
2. Use void marking tools in right panel
3. Test sync mode and export features

Happy testing! üéØ`);
          } catch (error) {
            console.error("Quick Test Mode failed:", error);
            alert(`Quick Test Mode failed: ${error.message}`);
            this.hideProgress();
          } finally {
            quickBtn.textContent = originalText;
            quickBtn.disabled = false;
          }
        }
      }

      // Ïï± Ï¥àÍ∏∞Ìôî
      const app = new WaferAppV2();
      window.waferApp = app;
    </script>
    <script src="js/quickloadManager.js"></script>
  </body>
</html>
