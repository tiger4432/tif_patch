<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool - V2</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist/geotiff.bundle.js"></script>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        height: 100vh;
        background: #f8f9fa;
        color: #2c3e50;
      }

      #left {
        width: 22%;
        height: 100vh;
        overflow-y: auto;
        background: #ffffff;
        border-right: 1px solid #dee2e6;
        padding: 12px;
        box-shadow: 1px 0 3px rgba(0, 0, 0, 0.1);
      }

      #center {
        width: 56%;
        height: 100vh;
        overflow: auto;
        background: #f1f3f4;
        border-right: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }

      #right {
        width: 22%;
        height: 100vh;
        overflow-y: auto;
        background: #ffffff;
        box-shadow: -1px 0 3px rgba(0, 0, 0, 0.1);
      }

      #patches {
        margin: 12px;
      }
      canvas {
        max-width: 95%;
        max-height: 95%;
        cursor: grab;
        border-radius: 8px;
        object-fit: contain;
      }
      canvas.dragging {
        cursor: grabbing;
      }

      /* Form Elements */
      input[type="text"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
        padding: 6px 10px;
        margin: 3px 0;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 13px;
        transition: all 0.2s ease;
        background: #ffffff;
        color: #495057;
      }

      input[type="text"]:focus,
      input[type="number"]:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.15);
      }

      textarea {
        height: 80px;
        resize: vertical;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      button {
        padding: 6px 12px;
        margin: 3px 2px;
        border: 1px solid #007bff;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
        background: #007bff;
        color: white;
      }

      button:hover {
        background: #0056b3;
        border-color: #0056b3;
      }

      button:active {
        background: #004085;
        border-color: #004085;
      }

      label {
        display: block;
        margin: 8px 0 3px 0;
        font-weight: 500;
        color: #495057;
        font-size: 13px;
      }
      .coord-card {
        border: 1px solid #bdc3c7;
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 16px;
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .coord-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      }

      .coord-title {
        margin: 0 0 10px;
        font-size: 16px;
        font-weight: 600;
        color: #2c3e50;
        border-bottom: 2px solid #667eea;
        padding-bottom: 6px;
      }

      .layers-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fill, 1fr);
        gap: 12px;
        padding: 8px 0;
      }

      .layer-item {
        text-align: center;
        background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        padding: 12px;
        border-radius: 10px;
        transition: all 0.3s ease;
        cursor: pointer;
        border: 2px solid transparent;
      }

      .layer-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(52, 73, 94, 0.4);
        border-color: #3498db;
      }

      .layer-label {
        font-size: 12px;
        color: #bdc3c7;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .layer-item canvas {
        max-width: 100%;
        border: 2px solid #7f8c8d;
        border-radius: 6px;
        transition: border-color 0.3s ease;
      }

      .layer-item:hover canvas {
        border-color: #3498db;
      }
      .mode-on {
        background: linear-gradient(
          135deg,
          #27ae60 0%,
          #2ecc71 100%
        ) !important;
        color: white !important;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4) !important;
        transform: translateY(-1px) !important;
      }

      #topControls {
        position: sticky;
        top: 0;
        z-index: 1000;
        padding: 12px;
        background: rgb(255, 255, 255);
      }

      #voidControls {
        padding: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        background: rgba(52, 73, 94);
        border-radius: 8px;
        margin-bottom: 8px;
      }

      #voidControls button {
        padding: 8px 16px;
        border: 2px solid #7f8c8d;
        background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        color: #fff;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
        font-size: 13px;
      }

      #voidControls button:hover {
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        border-color: #3498db;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
      }

      /* Special styling for important buttons */
      .info-panel {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 12px;
        margin: 8px 0;
      }

      .highlight-box {
        background: #e9ecef;
        border: 1px solid #adb5bd;
        border-radius: 6px;
        padding: 10px;
        margin: 6px 0;
      }

      /* Headers and Sections */
      h3 {
        color: #343a40;
        margin: 16px 0 10px 0;
        padding-bottom: 6px;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        font-size: 15px;
      }
      #voidControls select {
        padding: 6px;
        background: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 4px;
      }

      #voidJson {
        width: 100%;
        height: 120px;
        font-family: "Courier New", monospace;
        font-size: 10px;
        background: #2c3e50;
        color: #ecf0f1;
        border: 1px solid #34495e;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 8px;
        resize: vertical;
      }
    </style>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <div class="highlight-box" style="margin: 8px 0">
        <button
          id="quickTestBtn"
          style="
            font-size: 12px;
            background: #28a745;
            border-color: #28a745;
            margin-bottom: 6px;
            width: 100%;
          "
        >
          üöÄ Quick Test Mode
        </button>
        <input
          id="localTiffPath"
          type="text"
          placeholder="Ïòà: /large_wafer_500chip_14900x14900_11layers.tif"
          style="font-size: 12px; margin-bottom: 4px"
        />
        <button id="loadLocalTiff" style="font-size: 12px">Load TIFF</button>
        <div
          id="memoryStatus"
          style="font-size: 12px; color: #6c757d; margin-top: 4px"
        >
          Memory: Ready
        </div>
        <div id="progressContainer" style="margin-top: 4px; display: none">
          <div style="font-size: 10px; margin-bottom: 2px">
            <span id="progressText">Loading...</span>
          </div>
          <div
            style="
              background: #ddd;
              border-radius: 2px;
              height: 4px;
              overflow: hidden;
            "
          >
            <div
              id="progressBar"
              style="
                background: linear-gradient(to right, #4caf50, #2196f3);
                height: 100%;
                width: 0%;
                transition: width 0.3s ease;
              "
            ></div>
          </div>
          <div style="font-size: 11px; color: #6c757d; margin-top: 1px">
            <span id="progressDetails"></span>
          </div>
        </div>
      </div>
      <textarea
        id="csvPaste"
        placeholder="Bonding Map Í≤©Ïûê ÌòïÌÉú Î∂ôÏó¨ÎÑ£Í∏∞ (Ïòà: ÌÉ≠ÏúºÎ°ú Íµ¨Î∂ÑÎêú x,y Ï¢åÌëú Ìëú)"
        style="height: 60px; font-size: 11px"
      ></textarea>
      <div style="margin-top: 6px">
        <label style="font-size: 13px; color: #495057"
          >Page:
          <select id="pageSelect" style="font-size: 12px"></select
        ></label>
      </div>

      <h3>Compression Settings</h3>
      <div class="info-panel" style="margin-bottom: 12px; padding: 8px">
        <strong style="font-size: 14px">Max Size:</strong>
        <div
          style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 4px;
            font-size: 12px;
          "
        >
          <label
            ><input type="radio" name="compression" value="2048" checked />
            2K</label
          >
          <label
            ><input type="radio" name="compression" value="4096" /> 4K</label
          >
          <label
            ><input type="radio" name="compression" value="6144" /> 6K</label
          >
          <label
            ><input type="radio" name="compression" value="8192" /> 8K</label
          >
        </div>
      </div>

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br />

      <div style="margin-top: 10px">
        <strong>Patch Alignment Preview:</strong><br />
        <canvas
          id="gridPreview"
          width="300"
          height="200"
          style="border: 1px solid #ccc; margin-top: 5px"
        ></canvas>
        <div
          id="previewStatus"
          style="font-size: 11px; color: #666; margin-top: 2px"
        >
          Load TIFF to see patch samples
        </div>
      </div>
      <br />

      <h3>Reference Point</h3>
      Îπ®Í∞ÑÏ†ê Ï¢åÌëú ÏßÄÏ†ï:<br />
      X: <input id="refX" type="number" value="0" style="width: 60px" /> Y:
      <input id="refY" type="number" value="0" style="width: 60px" />
      <button id="setRefBtn">Apply</button><br />
      <small style="color: #666">Îπ®Í∞ÑÏ†êÏù¥ ÌëúÏãúÎê† Ïπ© Ï¢åÌëúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî</small
      ><br /><br />

      <h3>Enhance</h3>
      Contrast Œ± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Œ≤ <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
      <label for="zipFileName">Save as:</label>
      <input
        type="text"
        id="zipFileName"
        placeholder="patches.zip"
        style="margin-left: 5px; width: 200px"
      />
      <button id="debugBtn">Debug Check</button>

      <h3>Load Settings</h3>
      <div class="highlight-box">
        <textarea
          id="metadataPaste"
          placeholder="Metadata JSON Î∂ôÏó¨ÎÑ£Í∏∞"
          style="
            height: 80px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
          "
        ></textarea>
        <button id="loadMetadata" style="font-size: 12px">
          Apply Settings
        </button>
        <div style="font-size: 11px; color: #666; margin-top: 2px">
          Paste metadata.json or void JSON to restore grid settings
        </div>
      </div>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <div id="topControls">
        <h3>Patches</h3>
        <div id="voidControls">
          <textarea id="voidJson"></textarea>
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <option value="void">void</option>
            <option value="crack">crack</option>
            <option value="particle">particle</option>
            <option value="bbox">bbox</option>
          </select>
          <button id="toggleSyncMode">Sync Layers</button>
          <button id="downloadVoids">Download Voids JSON</button>
          <button id="voidStats">Void Stats</button>
          <button id="showSummary">Show Type Summary</button>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">‚óÄ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next ‚ñ∂</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script type="module">
      // UTIF ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏûÑÌè¨Ìä∏
      import UTIF from "https://cdn.skypack.dev/utif";
      window.UTIF = UTIF;

      // Î™®Îìà ÏûÑÌè¨Ìä∏
      import { VOID_COLORS, VOID_KEY_MAP, CONFIG } from "./js/constants.js";
      import {
        padCoord,
        parsePatchLabel,
        parseBondingMap,
        parseCSV,
      } from "./js/utils.js";
      import { VoidManagerV2 } from "./js/voidManager_v2.js";
      import { ImageProcessor } from "./js/imageProcessor.js";
      import { PatchManager } from "./js/patchManager.js";

      // Ï†ÑÏó≠ ÏÉÅÌÉú
      class WaferAppV2 {
        constructor() {
          this.pages = [];
          this.pageIndex = 0;
          this.currentScale = 1;
          this.origin = { x: 50, y: 50 };
          this.refGrid = { x: 0, y: 0 };
          this.csvRows = [];
          this.chipPoints = [];
          this.currentTiffFileName = null; // ÌòÑÏû¨ Î°úÎìúÎêú TIFF ÌååÏùºÎ™Ö

          // ÏÉàÎ°úÏö¥ Î≥¥Ïù¥Îìú Îß§ÎãàÏ†Ä
          this.voidManager = new VoidManagerV2();

          // Ìå®Ïπò Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî
          this.patchManager = new PatchManager(this.voidManager, this);
          this.voidMarkMode = false;
          this.deleteVoidMode = false;
          this.selectedVoid = null;
          this.resizeMode = false;

          // Í∑∏Î¶¨Îìú ÌîÑÎ¶¨Î∑∞ Ï¥àÍ∏∞Ìôî
          this.gridPreviewCanvas = document.getElementById("gridPreview");
          this.gridPreviewCtx = this.gridPreviewCanvas.getContext("2d");

          this.initializeUI();
          this.setupEventHandlers();
          this.setupVoidJsonSync();
        }

        // Progress Bar Methods
        showProgress() {
          const container = document.getElementById("progressContainer");
          container.style.display = "block";
          this.updateProgress(0, "Initializing TIFF loading...", "");
        }

        hideProgress() {
          const container = document.getElementById("progressContainer");
          container.style.display = "none";
        }

        updateProgress(percentage, text = "", details = "") {
          const progressBar = document.getElementById("progressBar");
          const progressText = document.getElementById("progressText");
          const progressDetails = document.getElementById("progressDetails");

          progressBar.style.width = `${Math.min(
            100,
            Math.max(0, percentage)
          )}%`;
          if (text) progressText.textContent = text;
          if (details) progressDetails.textContent = details;
        }

        initializeUI() {
          this.waferCanvas = document.getElementById("wafer");
          this.waferCtx = this.waferCanvas.getContext("2d");
          this.pageSelect = document.getElementById("pageSelect");

          this.markBtn = document.getElementById("toggleVoidMode");
          this.deleteBtn = document.getElementById("toggleDeleteMode");
          this.syncBtn = document.getElementById("toggleSyncMode");

          this.syncBtn.classList.toggle("mode-on", this.voidManager.syncMode);
        }

        setupEventHandlers() {
          // Quick Test Mode Î≤ÑÌäº
          document.getElementById("quickTestBtn").onclick = async () => {
            await this.loadQuickTestData();
          };

          // Î°úÏª¨ ÏÑúÎ≤ÑÏóêÏÑú TIFF Î°úÎìú (Range ÏÑúÎ≤Ñ ÏÇ¨Ïö©)
          document.getElementById("loadLocalTiff").onclick = async () => {
            const filePath = document.getElementById("localTiffPath").value;
            if (!filePath) {
              alert("ÌååÏùº Í≤ΩÎ°úÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî (Ïòà: /large_image.tif)");
              return;
            }

            const loadBtn = document.getElementById("loadLocalTiff");
            const originalText = loadBtn.textContent;

            try {
              loadBtn.textContent = "Loading...";
              loadBtn.disabled = true;

              // Range ÏÑúÎ≤Ñ URL Íµ¨ÏÑ± (Ìè¨Ìä∏ 8083 ÏÇ¨Ïö©)
              const rangeServerUrl = `http://localhost:8083${
                filePath.startsWith("/") ? filePath : "/" + filePath
              }`;

              // ÌååÏùºÎ™Ö Ï∂îÏ∂ú Î∞è Ï†ÄÏû•
              const fileName = filePath.split("/").pop() || filePath;
              this.currentTiffFileName = fileName.replace(/\.[^/.]+$/, ""); // ÌôïÏû•Ïûê Ï†úÍ±∞

              console.log("Loading from Range server:", rangeServerUrl);
              console.log("TIFF file name:", this.currentTiffFileName);

              // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
              const memoryStatus = document.getElementById("memoryStatus");
              let initialMemory = null;

              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  initialMemory = ImageProcessor.getMemoryUsage();
                  if (initialMemory) {
                    console.log("Initial memory usage:", initialMemory);
                    memoryStatus.textContent = `Memory: ${initialMemory.used}MB / ${initialMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Not supported";
                  }
                } else {
                  console.warn("getMemoryUsage method not available");
                  memoryStatus.textContent = "Memory: Method not available";
                }
              } catch (error) {
                console.error("Memory monitoring error:", error);
                memoryStatus.textContent = "Memory: Error";
              }

              console.log("loadtitff");

              // ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î ÌëúÏãú
              this.showProgress();

              try {
                // Range ÏÑúÎ≤ÑÎ•º ÌÜµÌïú Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôîÎêú TIFF Î°úÎî©
                this.updateProgress(
                  10,
                  "Connecting to Range server...",
                  rangeServerUrl
                );
                this.pages = await ImageProcessor.loadTiffFromServer(
                  rangeServerUrl,
                  (current, total, details) => {
                    const progress = 10 + (current / total) * 90; // 10-80%
                    this.updateProgress(
                      progress,
                      `Loading page ${current}/${total}`,
                      details
                    );
                  }
                );

                this.updateProgress(
                  85,
                  "Processing pages...",
                  "Updating page selector"
                );
                this.updatePageSelect();

                this.updateProgress(
                  90,
                  "Rendering image...",
                  "Drawing current page"
                );
                await this.drawPage();

                this.updateProgress(
                  95,
                  "Updating preview...",
                  "Grid preview generation"
                );
                this.updateGridPreview();

                this.updateProgress(
                  100,
                  "Loading complete!",
                  `${this.pages.length} pages loaded successfully`
                );

                // 2Ï¥à ÌõÑ ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î Ïà®Í∏∞Í∏∞
                setTimeout(() => this.hideProgress(), 2000);
              } catch (error) {
                this.updateProgress(0, "Loading failed", error.message);
                setTimeout(() => this.hideProgress(), 3000);
                throw error;
              }

              // ÏµúÏ¢Ö Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏
              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  const finalMemory = ImageProcessor.getMemoryUsage();
                  if (finalMemory && initialMemory) {
                    console.log("Final memory usage:", finalMemory);
                    const memoryIncrease =
                      finalMemory.used - initialMemory.used;
                    console.log("Memory increase:", memoryIncrease, "MB");
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB (+${memoryIncrease}MB)`;
                  } else if (finalMemory) {
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Load Complete";
                  }
                } else {
                  memoryStatus.textContent = "Memory: Load Complete";
                }
              } catch (error) {
                console.error("Final memory check error:", error);
                memoryStatus.textContent = "Memory: Load Complete";
              }

              // ÏÑ±Í≥µ Î©îÏãúÏßÄ
              const finalMemoryText = memoryStatus.textContent.includes("MB")
                ? memoryStatus.textContent.split(" ")[1]
                : "N/A";
              alert(
                `Î°úÏª¨ ÏÑúÎ≤ÑÏóêÏÑú Î°úÎìú ÏôÑÎ£å!\nÌéòÏù¥ÏßÄ Ïàò: ${this.pages.length}\nÎ©îÎ™®Î¶¨ ÏÉÅÌÉú: ${finalMemoryText}`
              );
            } catch (error) {
              alert(error.message);
              console.error("Local server loading error:", error);
            } finally {
              loadBtn.textContent = originalText;
              loadBtn.disabled = false;
            }
          };

          // CSV Î∂ôÏó¨ÎÑ£Í∏∞
          document
            .getElementById("csvPaste")
            .addEventListener("paste", async (e) => {
              const text = e.clipboardData.getData("text");
              this.csvRows = parseBondingMap(text);
              this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));
              alert(`Î≥µÎ∂ôÌïú ${this.csvRows.length}Í∞úÏùò chip Ï¢åÌëú Î°úÎìú ÏôÑÎ£å`);
              await this.drawPage();
              this.updateGridPreview();
            });

          // ÌéòÏù¥ÏßÄ ÏÑ†ÌÉù
          this.pageSelect.addEventListener("change", async (e) => {
            this.pageIndex = parseInt(e.target.value) || 0;
            await this.drawPage();
            this.updateGridPreview();
          });

          // ÏïïÏ∂ï ÏÑ§Ï†ï Î≥ÄÍ≤Ω
          document
            .querySelectorAll('input[name="compression"]')
            .forEach((radio) => {
              radio.addEventListener("change", (e) => {
                if (e.target.checked) {
                  ImageProcessor.updateCompressionSettings(e.target.value);
                  console.log(
                    "Compression setting changed to:",
                    e.target.value
                  );

                  // Î©îÎ™®Î¶¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                  this.updateMemoryStatus();
                }
              });
            });

          // Í∑∏Î¶¨Îìú Î≥ÄÍ≤Ω
          ["cols", "rows", "cellW", "cellH"].forEach((id) => {
            document.getElementById(id).addEventListener("input", async () => {
              await this.drawPage();
              this.updateGridPreview();
            });
          });

          // Void Í¥ÄÎ†® Î≤ÑÌäºÎì§
          this.markBtn.onclick = () => {
            this.voidMarkMode = !this.voidMarkMode;
            this.markBtn.classList.toggle("mode-on", this.voidMarkMode);
          };

          this.deleteBtn.onclick = () => {
            this.deleteVoidMode = !this.deleteVoidMode;
            this.deleteBtn.classList.toggle("mode-on", this.deleteVoidMode);
          };

          this.syncBtn.onclick = () => {
            const newState = this.voidManager.toggleSyncMode();
            this.syncBtn.classList.toggle("mode-on", newState);
            this.patchManager.refreshCurrentPatches();
          };

          // Í∏∞ÌÉÄ Î≤ÑÌäºÎì§
          document.getElementById("extractBtn").onclick = async () =>
            await this.patchManager.extractPatches();
          document.getElementById("downloadZipBtn").onclick = () =>
            this.downloadZip();
          document.getElementById("downloadVoids").onclick = () =>
            this.downloadVoids();
          document.getElementById("voidStats").onclick = () =>
            this.showVoidStats();
          document.getElementById("showSummary").onclick = () =>
            this.showTypeSummary();
          document.getElementById("debugBtn").onclick = () => this.debugCheck();

          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú (Î≥µÎ∂ô Î∞©Ïãù)
          document.getElementById("loadMetadata").onclick = async () => {
            const textarea = document.getElementById("metadataPaste");
            const text = textarea.value.trim();

            if (!text) {
              alert("Please paste metadata JSON first.");
              return;
            }

            try {
              const jsonData = JSON.parse(text);
              const metadata = this.extractMetadataFromJson(jsonData);

              if (!metadata) {
                alert(
                  "Invalid metadata format. Please paste a valid metadata.json or void JSON content."
                );
                return;
              }

              const success = this.applyMetadata(metadata);
              if (success) {
                // Í∑∏Î¶¨Îìú Îã§Ïãú Í∑∏Î¶¨Í∏∞
                await this.drawPage();
                this.updateGridPreview();

                alert(
                  `Settings loaded successfully!\nTIFF: ${
                    metadata.tiffFileName || "Unknown"
                  }\nGrid: ${metadata.gridSettings?.cols}x${
                    metadata.gridSettings?.rows
                  }\nCell: ${metadata.gridSettings?.cellW}x${
                    metadata.gridSettings?.cellH
                  }`
                );

                console.log("Loaded metadata:", metadata);

                // textarea Ï¥àÍ∏∞Ìôî
                textarea.value = "";
              } else {
                alert("Failed to apply metadata settings.");
              }
            } catch (error) {
              console.error("Error loading metadata:", error);
              alert("Failed to parse JSON. Please check the format.");
            }
          };

          // Ï∫îÎ≤ÑÏä§ ÎìúÎûòÍ∑∏
          this.setupCanvasDrag();

          // Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï
          this.setupReferenceMode();

          // Ìå®Ïπò ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
          document.getElementById("prevPage").onclick = async () =>
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage - 1
            );
          document.getElementById("nextPage").onclick = async () =>
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage + 1
            );

          // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
          document.addEventListener("keydown", (e) => {
            if (!this.voidMarkMode) return;
            const newType = VOID_KEY_MAP[e.key];
            if (newType) {
              document.getElementById("voidTypeSelect").value = newType;
            }
          });

          // Ï¥àÍ∏∞ Í∑∏Î¶¨Îìú ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
          this.updateGridPreview();

          // Ïõ®Ïù¥Ìçº Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (ÌååÎûÄÏ†ê ÌÅ¥Î¶≠ÏúºÎ°ú Ìå®Ïπò Ïù¥Îèô)
          this.setupWaferCanvasClick();
        }

        /**
         * Ïõ®Ïù¥Ìçº Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
         */
        setupWaferCanvasClick() {
          this.waferCanvas.addEventListener("click", async (e) => {
            // ÎìúÎûòÍ∑∏ Ï§ëÏù¥Í±∞ÎÇò Î≥¥Ïù¥Îìú ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎäî Î¨¥Ïãú
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = this.waferCanvas.getBoundingClientRect();
            const scaleX = this.waferCanvas.width / rect.width;
            const scaleY = this.waferCanvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // ÌÅ¥Î¶≠Ìïú Ï¢åÌëúÎ•º Í∑∏Î¶¨Îìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const cellW =
              +document.getElementById("cellW").value * this.currentScale;
            const cellH =
              +document.getElementById("cellH").value * this.currentScale;

            const gridX = Math.floor(
              (clickX - this.origin.x * this.currentScale) / cellW
            );
            const gridY = Math.floor(
              (clickY - this.origin.y * this.currentScale) / cellH
            );

            // Ïã§Ï†ú Ïπ© Ï¢åÌëúÎ°ú Î≥ÄÌôò (Í∏∞Ï§ÄÏ†ê Í≥†Î†§)
            const chipX = gridX + this.refGrid.x;
            const chipY = gridY + this.refGrid.y;

            // Auto bbox detection Î™®ÎìúÏùº Îïå bbox ÌÉêÏßÄ ÏàòÌñâ
            if (this.voidManager.autoBboxDetection) {
              await this.detectBboxForChip(chipX, chipY);
              return;
            }

            // Ìï¥Îãπ Ï¢åÌëúÏùò Ìå®ÏπòÎ•º Ï∞æÏïÑÏÑú Ïù¥Îèô
            await this.patchManager.navigateToChipPatch(chipX, chipY);
          });
        }

        /**
         * ÌäπÏ†ï Ïπ©ÏóêÏÑú bbox ÌÉêÏßÄ ÏàòÌñâ
         */
        async detectBboxForChip(chipX, chipY) {
          console.log(`Detecting bbox for chip (${chipX}, ${chipY})`);

          // Ìï¥Îãπ Ïπ©Ïùò Ìå®Ïπò Ï∞æÍ∏∞
          const targetCoord = `(${chipX},${chipY})`;
          const targetPatch = this.allPatchPages.find(
            (patch) => patch.coord === targetCoord
          );

          if (!targetPatch) {
            console.log(`No patch found for chip (${chipX}, ${chipY})`);
            return;
          }

          // Í∞Å Î†àÏù¥Ïñ¥ÏóêÏÑú bbox ÌÉêÏßÄ ÏàòÌñâ
          for (const layerData of targetPatch.layers) {
            if (layerData.canvas) {
              const detectedBboxes = this.voidManager.detectBboxFromImage(
                layerData.canvas,
                chipX,
                chipY,
                300
              );

              console.log(
                `Detected ${detectedBboxes.length} bboxes for chip (${chipX}, ${chipY}) layer ${layerData.layer}`
              );
            }
          }

          // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
          this.refreshCurrentPatches();
        }

        /**
         * ÌäπÏ†ï Ïπ© Ï¢åÌëúÏùò Ìå®ÏπòÎ°ú Ïù¥Îèô
         */
        async navigateToChipPatch(chipX, chipY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          // Ìï¥Îãπ Ï¢åÌëúÏùò Ìå®Ïπò Ï∞æÍ∏∞
          const targetCoord = `(${chipX},${chipY})`;
          const patchIndex = this.patchManager.allPatchPages.findIndex(
            (patch) => patch.coord === targetCoord
          );

          if (patchIndex !== -1) {
            this.patchManager.currentPatchPage = patchIndex;
            await this.patchManager.showPatchPage(patchIndex);
            await this.drawPage(); // Ï¥àÎ°ùÏ†ê ÏóÖÎç∞Ïù¥Ìä∏

            console.log(
              `Navigated to patch: ${targetCoord} (index: ${patchIndex})`
            );
          } else {
            console.log(`No patch found for coordinates: ${targetCoord}`);
          }
        }

        updatePageSelect() {
          this.pageSelect.innerHTML = this.pages
            .map((_, i) => `<option value="${i}">Page ${i + 1}</option>`)
            .join("");
          this.pageIndex = 0;
        }

        async drawPage() {
          if (!this.pages.length) return;

          const src = this.pages[this.pageIndex];

          // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ
          const memory = ImageProcessor.getMemoryUsage();
          if (memory) {
            console.log(
              `Current memory usage: ${memory.used}MB / ${memory.limit}MB`
            );

            // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏúºÎ©¥ Í≤ΩÍ≥†
            if (memory.used / memory.limit > 0.8) {
              console.warn("High memory usage detected");
            }
          }

          this.currentScale = ImageProcessor.drawPage(src, this.waferCanvas);
          this.drawGrid();
        }

        drawGrid() {
          if (!this.pages.length) return;

          const cols = +document.getElementById("cols").value;
          const rows = +document.getElementById("rows").value;
          const cellW =
            +document.getElementById("cellW").value * this.currentScale;
          const cellH =
            +document.getElementById("cellH").value * this.currentScale;

          // Í∏∞Ï§ÄÏ†êÎèÑ Ïä§ÏºÄÏùº Ï†ÅÏö©
          const scaledOriginX = this.origin.x * this.currentScale;
          const scaledOriginY = this.origin.y * this.currentScale;

          this.waferCtx.strokeStyle = "lime";
          this.waferCtx.lineWidth = 1;

          // ÏàòÏßÅÏÑ† Í∑∏Î¶¨Í∏∞
          for (let i = 0; i <= cols; i++) {
            const x = scaledOriginX + i * cellW;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(x, scaledOriginY);
            this.waferCtx.lineTo(x, scaledOriginY + rows * cellH);
            this.waferCtx.stroke();
          }

          // ÏàòÌèâÏÑ† Í∑∏Î¶¨Í∏∞
          for (let j = 0; j <= rows; j++) {
            const y = scaledOriginY + j * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(scaledOriginX, y);
            this.waferCtx.lineTo(scaledOriginX + cols * cellW, y);
            this.waferCtx.stroke();
          }

          // Ïπ© Ìè¨Ïù∏Ìä∏ (ÌååÎûÄ Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.waferCtx.fillStyle = "deepskyblue";
          this.chipPoints.forEach((pt) => {
            const px = scaledOriginX + (pt.x - this.refGrid.x + 0.5) * cellW;
            const py = scaledOriginY + (pt.y - this.refGrid.y + 0.5) * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.arc(
              px,
              py,
              Math.max(3, cellW * 0.05),
              0,
              2 * Math.PI
            );
            this.waferCtx.fill();
          });

          // Í∏∞Ï§ÄÏ†ê (Îπ®Í∞Ñ Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.waferCtx.fillStyle = "red";
          const refPixelX = scaledOriginX + 0.5 * cellW;
          const refPixelY = scaledOriginY + 0.5 * cellH;
          this.waferCtx.beginPath();
          this.waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // ÌòÑÏû¨ Ìå®Ïπò (Ï¥àÎ°ù Ï†ê) - Ïä§ÏºÄÏùº Ï†ÅÏö©
          this.drawCurrentPatchIndicator(
            cellW,
            cellH,
            scaledOriginX,
            scaledOriginY
          );
        }

        /**
         * ÌòÑÏû¨ Î≥¥Í≥† ÏûàÎäî Ìå®ÏπòÎ•º Ï¥àÎ°ùÏ†êÏúºÎ°ú ÌëúÏãú (Ïä§ÏºÄÏùº Ï†ÅÏö©)
         */
        drawCurrentPatchIndicator(cellW, cellH, scaledOriginX, scaledOriginY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          const currentPatch = this.patchManager.allPatchPages[this.patchManager.currentPatchPage];
          if (!currentPatch) return;

          // ÌòÑÏû¨ Ìå®ÏπòÏùò Ï¢åÌëú ÌååÏã±
          const match = currentPatch.coord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) {
            console.log(
              "Failed to parse patch coordinates:",
              currentPatch.coord
            );
            return;
          }

          const patchX = parseInt(match[1], 10);
          const patchY = parseInt(match[2], 10);

          // ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò (Ïä§ÏºÄÏùº Ï†ÅÏö©)
          const px = scaledOriginX + (patchX - this.refGrid.x + 0.5) * cellW;
          const py = scaledOriginY + (patchY - this.refGrid.y + 0.5) * cellH;

          console.log(
            `Drawing green dot for patch (${patchX},${patchY}) at screen (${px},${py})`
          );

          // Ï¥àÎ°ùÏ†ê Í∑∏Î¶¨Í∏∞ (Îπ®Í∞ÑÏ†êÎ≥¥Îã§ ÏïΩÍ∞Ñ ÌÅ¨Í≤å)
          this.waferCtx.fillStyle = "lime";
          this.waferCtx.beginPath();
          this.waferCtx.arc(px, py, 8, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
          this.waferCtx.strokeStyle = "darkgreen";
          this.waferCtx.lineWidth = 2;
          this.waferCtx.stroke();
        }

        setupCanvasDrag() {
          let dragging = false;
          let start = { x: 0, y: 0 };
          let previewUpdateTimeout = null;

          this.waferCanvas.addEventListener("mousedown", (e) => {
            dragging = true;
            this.waferCanvas.classList.add("dragging");
            start.x = e.clientX;
            start.y = e.clientY;
          });

          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              this.waferCanvas.classList.remove("dragging");
              // ÎìúÎûòÍ∑∏ ÏôÑÎ£å Ïãú Ï¶âÏãú ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
              this.updateGridPreview();
            }
          });

          window.addEventListener("mousemove", async (e) => {
            if (!dragging) return;
            const deltaX = e.clientX - start.x;
            const deltaY = e.clientY - start.y;

            // Ïä§ÏºÄÏùºÏùÑ Í≥†Î†§Ìïú ÎìúÎûòÍ∑∏
            this.origin.x += deltaX / this.currentScale;
            this.origin.y += deltaY / this.currentScale;

            start.x = e.clientX;
            start.y = e.clientY;
            await this.drawPage();

            // ÎìúÎûòÍ∑∏ Ï§ë ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏ (throttling Ï†ÅÏö©)
            if (previewUpdateTimeout) {
              clearTimeout(previewUpdateTimeout);
            }
            previewUpdateTimeout = setTimeout(() => {
              this.updateGridPreview();
            }, 100); // 100ms ÎîúÎ†àÏù¥
          });
        }

        setupReferenceMode() {
          const setRefBtn = document.getElementById("setRefBtn");
          const refXInput = document.getElementById("refX");
          const refYInput = document.getElementById("refY");

          // Ï¢åÌëú ÏûÖÎ†•Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
          const updateReference = async () => {
            const refX = parseInt(refXInput.value) || 0;
            const refY = parseInt(refYInput.value) || 0;

            this.refGrid = { x: refX, y: refY };
            await this.drawPage();
            this.updateGridPreview();

            console.log(`Reference point set to: (${refX}, ${refY})`);
          };

          // Apply Reference Î≤ÑÌäº ÌÅ¥Î¶≠
          setRefBtn.onclick = updateReference;

          // Enter ÌÇ§ Ï≤òÎ¶¨
          refXInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          refYInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          // Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
          refXInput.addEventListener("input", updateReference);
          refYInput.addEventListener("input", updateReference);
        }

        async extractPatches() {
          if (!this.pages.length) {
            alert("TIFF ÌååÏùºÏùÑ Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
            return;
          }
          if (!this.csvRows.length) {
            alert("CSV Îç∞Ïù¥ÌÑ∞Î•º Î®ºÏ†Ä Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî!");
            return;
          }

          // Í∏∞Ï°¥ Î≥¥Ïù¥Îìú Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();
          console.log("Void data cleared for new patch extraction");

          this.allPatchPages = [];
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;
          const tMean = parseFloat(document.getElementById("targetMean").value);
          const tStd = parseFloat(document.getElementById("targetStd").value);
          const pad = parseInt(document.getElementById("padPx").value, 10);
          window.allPatchCanvases = [];

          this.csvRows.forEach((r) => {
            const pageData = {
              coord: `(${r.x},${r.y})`,
              layers: [],
              type: r.type,
            };

            this.pages.forEach((src, pageIdx) => {
              const gx = this.origin.x + (r.x - this.refGrid.x) * cellW;
              const gy = this.origin.y + (r.y - this.refGrid.y) * cellH;

              console.log(gx, gy, cellW, cellH);

              const titleH = 40;
              const patchSize = 300; // Í≥†Ï†ï Ìå®Ïπò ÌÅ¨Í∏∞
              const c = document.createElement("canvas");
              c.width = patchSize;
              c.height = (patchSize * cellH) / cellW + titleH;
              const ctx = c.getContext("2d");

              const label = `X${padCoord(r.x)}_Y${padCoord(r.y)}_L${String(
                pageIdx + 1
              ).padStart(2, "0")}_LEG:${r.type || "NA"}`;
              ctx.fillStyle = "#000";
              ctx.fillRect(0, 0, patchSize, titleH);
              ctx.fillStyle = "#fff";
              ctx.font = "20px sans-serif";
              ctx.textBaseline = "middle";
              ctx.fillText(label, 6, titleH / 2);

              ctx.drawImage(
                src,
                gx,
                gy,
                cellW,
                cellH,
                0,
                titleH,
                patchSize,
                (patchSize * cellH) / cellW
              );

              // Ïù¥ÎØ∏ÏßÄ Ìñ•ÏÉÅ Î®ºÏ†Ä ÏàòÌñâ
              const subImg = ctx.getImageData(0, titleH, c.width, c.height);
              const tmp = document.createElement("canvas");
              tmp.width = c.width;
              tmp.height = c.height;
              tmp.getContext("2d").putImageData(subImg, 0, 0);
              ImageProcessor.enhanceToTarget(
                tmp.getContext("2d"),
                tMean,
                tStd,
                pad
              );
              ctx.putImageData(
                tmp.getContext("2d").getImageData(0, 0, c.width, c.height),
                0,
                titleH
              );

              // Î≥¥Ï†ï ÏôÑÎ£åÎêú Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
              const enhancedImageData = ctx.getImageData(
                0,
                0,
                c.width,
                c.height
              );

              this.attachVoidEvents(c, label, enhancedImageData);

              pageData.layers.push({
                canvas: c,
                label,
                type: r.type || "NA",
                layer: pageIdx + 1,
                imageData: enhancedImageData,
              });

              const typeFolder = r.type
                ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
                : "NA";
              window.allPatchCanvases.push({
                canvas: c,
                layer: pageIdx + 1,
                label,
                type: typeFolder,
              });
            });

            this.allPatchPages.push(pageData);
          });

          this.currentPatchPage = 0;
          await this.showPatchPage(0);

          // Î≥¥Ïù¥Îìú Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî ÌõÑ Ìå®Ïπò Î∑∞Ïñ¥ Í∞±Ïã†
          this.refreshCurrentPatches();

          console.log(
            `Ìå®Ïπò Ï∂îÏ∂ú ÏôÑÎ£å: ${this.allPatchPages.length}Í∞ú Ï¢åÌëú, Ï¥ù ${
              this.allPatchPages.length * this.pages.length
            }Í∞ú Ìå®Ïπò`
          );
        }

        attachVoidEvents(canvas, patchLabel, imageData) {
          const ctx = canvas.getContext("2d");
          const { chipCoord, layer } = parsePatchLabel(patchLabel);
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return;

          const x = parseInt(match[1], 10);
          const y = parseInt(match[2], 10);

          const repaint = () => {
            ctx.putImageData(imageData, 0, 0);
            this.voidManager.drawVoids(ctx, patchLabel);
          };

          // Î≥¥Ïù¥Îìú ÎßàÌÇπ
          canvas.addEventListener("mousedown", (e) => {
            if (!this.voidMarkMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const sx = (e.clientX - rect.left) * scaleX;
            const sy = (e.clientY - rect.top) * scaleY;

            const drag = (me) => {
              const cx = (me.clientX - rect.left) * scaleX;
              const cy = (me.clientY - rect.top) * scaleY;
              repaint();
              const selType =
                document.getElementById("voidTypeSelect").value || "default";
              ctx.strokeStyle = VOID_COLORS[selType] || VOID_COLORS.default;
              ctx.lineWidth = 2;
              ctx.beginPath();

              if (selType === "bbox") {
                // bbox ÌÉÄÏûÖÏù¥Î©¥ ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞
                ctx.strokeRect(
                  Math.min(sx, cx),
                  Math.min(sy, cy),
                  Math.abs(cx - sx),
                  Math.abs(cy - sy)
                );
              } else {
                // ÏùºÎ∞ò void ÌÉÄÏûÖÏù¥Î©¥ ÌÉÄÏõê Í∑∏Î¶¨Í∏∞
                ctx.ellipse(
                  (sx + cx) / 2,
                  (sy + cy) / 2,
                  Math.abs(cx - sx) / 2,
                  Math.abs(cy - sy) / 2,
                  0,
                  0,
                  2 * Math.PI
                );
                ctx.stroke();
              }
            };

            const up = (ue) => {
              document.removeEventListener("mousemove", drag);
              document.removeEventListener("mouseup", up);
              const ex = (ue.clientX - rect.left) * scaleX;
              const ey = (ue.clientY - rect.top) * scaleY;
              const type =
                document.getElementById("voidTypeSelect").value || "void";

              let newVoid;

              if (type === "bbox") {
                // bbox ÌÉÄÏûÖÏù¥Î©¥ ÏÇ¨Í∞ÅÌòïÏúºÎ°ú Ï†ÄÏû•
                const rectX = Math.min(sx, ex);
                const rectY = Math.min(sy, ey);
                const rectW = Math.abs(ex - sx);
                const rectH = Math.abs(ey - sy);

                // bboxÎäî centerX, centerYÏóê Ï¢åÏÉÅÎã® Ï¢åÌëúÎ•º Ï†ÄÏû•ÌïòÍ≥† radiusX, radiusYÏóê ÎÑàÎπÑ, ÎÜíÏù¥Î•º Ï†ÄÏû•
                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  rectX, // centerXÏóê x Ï¢åÌëú
                  rectY, // centerYÏóê y Ï¢åÌëú
                  rectW, // radiusXÏóê width
                  rectH // radiusYÏóê height
                );
              } else {
                // ÏùºÎ∞ò void ÌÉÄÏûÖÏù¥Î©¥ ÌÉÄÏõêÏúºÎ°ú Ï†ÄÏû•
                const centerX = (sx + ex) / 2;
                const centerY = (sy + ey) / 2;
                const radiusX = Math.abs(ex - sx) / 2;
                const radiusY = Math.abs(ey - sy) / 2;

                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  centerX,
                  centerY,
                  radiusX,
                  radiusY
                );
              }

              if (newVoid) {
                this.patchManager.refreshCurrentPatches();
                this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
              } else {
                repaint();
              }
            };

            // void ÎßàÌÇπ Î™®ÎìúÏùº ÎïåÎßå void Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
            if (this.voidMarkMode) {
              document.addEventListener("mousemove", drag);
              document.addEventListener("mouseup", up);
            }
          });

          // Î≥¥Ïù¥Îìú ÏÇ≠Ï†ú (Ìï¥Îãπ Î†àÏù¥Ïñ¥ÏóêÏÑúÎßå)
          canvas.addEventListener("click", (e) => {
            if (!this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            console.log(
              `Attempting to delete void at (${x},${y},${layer}) click:(${clickX},${clickY})`
            );

            const deleted = this.voidManager.deleteVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );

            console.log(`Delete result: ${deleted}`);

            if (deleted) {
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
            }
          });

          // Î≥¥Ïù¥Îìú Ìé∏Ïßë (Ìï¥Îãπ Î†àÏù¥Ïñ¥ÏóêÏÑúÎßå)
          canvas.addEventListener("mousedown", (e) => {
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            const editableVoid = this.voidManager.findEditableVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );
            if (!editableVoid) return;

            this.selectedVoid = editableVoid;
            const originalCenterX = editableVoid.centerX;
            const originalCenterY = editableVoid.centerY;

            // Ïù¥Îèô vs ÌÅ¨Í∏∞Ï°∞Ï†à ÌåêÎã®
            const dx = clickX - editableVoid.centerX;
            const dy = clickY - editableVoid.centerY;
            const angle = Math.atan2(dy, dx);
            const rB =
              (editableVoid.radiusX * editableVoid.radiusY) /
              Math.sqrt(
                (editableVoid.radiusY * Math.cos(angle)) ** 2 +
                  (editableVoid.radiusX * Math.sin(angle)) ** 2
              );
            const dist = Math.hypot(dx, dy);

            this.resizeMode = Math.abs(dist - rB) <= CONFIG.TOLERANCE;
            const offsetX = clickX - editableVoid.centerX;
            const offsetY = clickY - editableVoid.centerY;

            const moveHandler = (me) => {
              const mx = (me.clientX - rect.left) * scaleX;
              const my = (me.clientY - rect.top) * scaleY;

              if (this.resizeMode) {
                const newRadiusX = Math.abs(mx - editableVoid.centerX);
                const newRadiusY = Math.abs(my - editableVoid.centerY);

                if (me.shiftKey) {
                  const r = Math.max(newRadiusX, newRadiusY);
                  editableVoid.radiusX = editableVoid.radiusY = r;
                } else {
                  editableVoid.radiusX = newRadiusX;
                  editableVoid.radiusY = newRadiusY;
                }
              } else {
                editableVoid.centerX = mx - offsetX;
                editableVoid.centerY = my - offsetY;
              }

              repaint();
            };

            const upHandler = () => {
              document.removeEventListener("mousemove", moveHandler);
              document.removeEventListener("mouseup", upHandler);

              // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÄÏû• (Ïã§Ï†úÎ°úÎäî Ïù¥ÎØ∏ editableVoid Í∞ùÏ≤¥Í∞Ä ÏàòÏ†ïÎêòÏóàÏùå)
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
              this.selectedVoid = null;
            };

            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
          });
        }

        refreshCurrentPatches() {
          if (
            !this.allPatchPages.length ||
            this.currentPatchPage >= this.allPatchPages.length
          )
            return;

          const currentPage = this.allPatchPages[this.currentPatchPage];
          currentPage.layers.forEach((layerInfo) => {
            const ctx = layerInfo.canvas.getContext("2d");
            ctx.putImageData(layerInfo.imageData, 0, 0);
            this.voidManager.drawVoids(ctx, layerInfo.label);
          });

          // void JSON ÏóÖÎç∞Ïù¥Ìä∏
          this.updateVoidJsonDisplay();

          // Ìå®Ïπò Î∑∞Ïñ¥ Ï†ÑÏ≤¥ ÏÉàÎ°úÍ≥†Ïπ® (void ÎßàÏä§ÌÅ¨ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
          this.showPatchPage(this.currentPatchPage);
        }

        async showPatchPage(idx) {
          if (!this.allPatchPages.length) return;
          if (idx < 0) idx = 0;
          if (idx >= this.allPatchPages.length)
            idx = this.allPatchPages.length - 1;
          this.currentPatchPage = idx;

          const page = this.allPatchPages[idx];
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3 >Chip ${page.coord}</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          // void ÎßàÏä§ÌÅ¨ Î®ºÏ†Ä Ï∂îÍ∞Ä (Í∞ÄÏû• Îß® ÏúÑ, Ìï≠ÏÉÅ ÌëúÏãú)
          const voidMaskCanvas = this.createVoidMaskCanvas(
            page.coord,
            page.type,
            true
          ); // Ìï≠ÏÉÅ ÏÉùÏÑ±
          const voidItem = document.createElement("div");
          voidItem.className = "layer-item";
          voidItem.innerHTML = `<div class="layer-label" style="color: #e74c3c">VOID MASK (ALL LAYERS)</div>`;
          voidItem.appendChild(voidMaskCanvas);
          layersWrap.appendChild(voidItem);

          // Í∏∞Ï°¥ Î†àÏù¥Ïñ¥Îì§ Ï∂îÍ∞Ä
          page.layers.forEach((l) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label">${l.label}</div>`;
            item.appendChild(l.canvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById("pageInfo").textContent = `Page ${
            this.currentPatchPage + 1
          } / ${this.allPatchPages.length}`;

          // ÌòÑÏû¨ Ìå®Ïπò Î≥ÄÍ≤Ω Ïãú Í∑∏Î¶¨ÎìúÏùò Ï¥àÎ°ùÏ†ê ÏóÖÎç∞Ïù¥Ìä∏
          await this.drawPage();
        }

        downloadZip() {
          if (!this.patchManager.allPatchCanvases || !this.patchManager.allPatchCanvases.length) {
            alert("Î®ºÏ†Ä Extract PatchesÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî.");
            return;
          }

          const zip = new JSZip();

          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
          const metadata = this.getGridMetadata();
          zip.file("metadata.json", JSON.stringify(metadata, null, 2));

          // Ï¢åÌëú Ï†ïÎ≥¥ Ï∂îÍ∞Ä
          const coordinateInfo = {
            coordinates: this.csvRows,
            chipPoints: this.chipPoints,
          };
          zip.file("coordinates.json", JSON.stringify(coordinateInfo, null, 2));

          // voids Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
          const voidData = this.voidManager.exportVoids();
          zip.file("voids.json", JSON.stringify(voidData, null, 2));

          // README ÌååÏùº Ï∂îÍ∞Ä
          const readmeContent = `# Wafer Patch Extraction Data
          
TIFF File: ${metadata.tiffFileName || "Unknown"}
Extraction Date: ${metadata.timestamp}
Version: ${metadata.version}

## Grid Settings
- Columns: ${metadata.gridSettings.cols}
- Rows: ${metadata.gridSettings.rows}  
- Cell Width: ${metadata.gridSettings.cellW}px
- Cell Height: ${metadata.gridSettings.cellH}px

## Alignment
- Origin: (${metadata.origin.x}, ${metadata.origin.y})
- Reference Grid: (${metadata.referenceGrid.x}, ${metadata.referenceGrid.y})

## Enhancement Settings
- Alpha (Contrast): ${metadata.enhanceSettings.alpha}
- Beta (Brightness): ${metadata.enhanceSettings.beta}
- Target Mean: ${metadata.enhanceSettings.targetMean}
- Target Std: ${metadata.enhanceSettings.targetStd}
- Padding: ${metadata.enhanceSettings.padPx}px

## Extraction Info
- Total Pages: ${metadata.extractionInfo.totalPages}
- Total Coordinates: ${metadata.extractionInfo.totalCoordinates}
- Total Patches: ${metadata.extractionInfo.totalPatches}
- Patch Size: ${metadata.extractionInfo.patchSize}px

## Structure
- with_voids/[type]/layer_[XX]/[patch_name].png (patches containing voids)
- no_voids/[type]/layer_[XX]/[patch_name].png (patches without voids)
- merge/[type]/[patch_name]_merge.png (merged mask layers)
- metadata.json: Grid and extraction settings
- coordinates.json: Chip coordinate data
- voids.json: Void detection data
`;
          zip.file("README.txt", readmeContent);

          // Ìå®Ïπò Ïù¥ÎØ∏ÏßÄÎì§ Íµ¨Î∂ÑÌï¥ÏÑú Ï∂îÍ∞Ä (voidÍ∞Ä ÏûàÎäî Í≤ÉÍ≥º ÏóÜÎäî Í≤É Î∂ÑÎ¶¨)
          const patchesWithVoids = new Set();
          const patchesWithoutVoids = new Set();

          // voidÍ∞Ä ÏûàÎäî Ìå®ÏπòÎì§ ÏãùÎ≥Ñ
          Object.keys(voidData).forEach((patchLabel) => {
            if (voidData[patchLabel] && voidData[patchLabel].length > 0) {
              patchesWithVoids.add(patchLabel);
            }
          });

          // Î™®Îì† Ìå®Ïπò Î∂ÑÎ•ò Î∞è Ï†ÄÏû•
          this.patchManager.allPatchCanvases.forEach((p) => {
            const hasVoids = patchesWithVoids.has(p.label);

            // 1. no_voids Ìè¥Îçî: voidÍ∞Ä ÏóÜÎäî Ïπ©Îì§Ïùò ÏõêÎ≥∏ Ìå®Ïπò
            if (!hasVoids) {
              const folderPath = `no_voids/${p.typeFolder || p.type}/layer_${String(p.layer).padStart(2, "0")}`;
              const folder = zip.folder(folderPath);
              const originalCanvas = p.originalCanvas || p.canvas;
              const dataURL = originalCanvas.toDataURL("image/png").split(",")[1];
              folder.file(`${p.label}.png`, dataURL, { base64: true });
              patchesWithoutVoids.add(p.label);
            }

            // 2. split Ìè¥Îçî: Î™®Îì† Ìå®Ïπò (void ÎßàÌÇπÎêú Î≤ÑÏ†Ñ ÎòêÎäî Îπà ÎßàÏä§ÌÅ¨)
            const splitFolderPath = `split/${p.typeFolder || p.type}/layer_${String(p.layer).padStart(2, "0")}`;
            const splitFolder = zip.folder(splitFolderPath);
            const splitDataURL = p.canvas.toDataURL("image/png").split(",")[1];
            splitFolder.file(`${p.label}.png`, splitDataURL, { base64: true });

            if (hasVoids) {
              patchesWithVoids.add(p.label);
            }
          });

          // split Ìè¥ÎçîÏóê merge mask Ï∂îÍ∞Ä (Î™®Îì† Ïπ©Ïóê ÎåÄÌï¥, void ÏóÜÏúºÎ©¥ Îπà ÎßàÏä§ÌÅ¨)
          const processedChips = new Set();
          this.patchManager.allPatchPages.forEach((patchPage) => {
            const chipCoord = patchPage.coord;
            const chipType = patchPage.type;

            if (processedChips.has(chipCoord)) return;
            processedChips.add(chipCoord);

            // Ìï¥Îãπ Ïπ©Ïóê voidÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
            const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
            if (!match) return;

            const chipX = parseInt(match[1]);
            const chipY = parseInt(match[2]);

            // Î™®Îì† Ïπ©Ïóê ÎåÄÌï¥ merge mask ÏÉùÏÑ± (void ÏóÜÏúºÎ©¥ Îπà ÎßàÏä§ÌÅ¨)
            const voidMaskCanvas = this.patchManager.createVoidMaskCanvas(chipCoord, chipType, true);
            if (voidMaskCanvas) {
              const safeFolderName = chipType.replace(/[^a-zA-Z0-9_-]/g, "_");
              const folderPath = `split/${safeFolderName}/merge`;
              const folder = zip.folder(folderPath);
              const label = `X${padCoord(chipX)}_Y${padCoord(chipY)}_L00_LEG:${chipType}`;
              const dataURL = voidMaskCanvas.toDataURL("image/png").split(",")[1];
              folder.file(`${label}.png`, dataURL, { base64: true });
            }
          });

          // summary Ìè¥ÎçîÏóê typeÎ≥Ñ ÌÜµÌï© void ÎßàÏä§ÌÅ¨ Ï∂îÍ∞Ä
          console.log("Creating summary masks...");
          console.log(`Total voids in system: ${this.voidManager.voids.size}`);
          const summaryMasks = this.patchManager.createAllTypeSummaryMasks();
          console.log(`Summary masks created: ${summaryMasks.size} types`, Array.from(summaryMasks.keys()));

          if (summaryMasks.size > 0) {
            summaryMasks.forEach((summaryCanvas, chipType) => {
              const summaryFolder = zip.folder("summary");
              const safeFileName = chipType.replace(/[^a-zA-Z0-9_-]/g, "_");
              const summaryLabel = `${safeFileName}_summary_all_voids`;
              const summaryDataURL = summaryCanvas.toDataURL("image/png").split(",")[1];
              summaryFolder.file(`${summaryLabel}.png`, summaryDataURL, { base64: true });
              console.log(`Added summary mask for type: ${chipType} as ${summaryLabel}.png`);
            });
          } else {
            console.warn("No summary masks created - no types found or no voids detected");
          }

          zip.generateAsync({ type: "blob" }).then((content) => {
            // ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï ÌååÏùºÎ™Ö ÎòêÎäî Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
            const userFileName = document
              .getElementById("zipFileName")
              .value.trim();
            let fileName;
            if (userFileName) {
              fileName = userFileName.endsWith(".zip")
                ? userFileName
                : userFileName + ".zip";
            } else {
              fileName = this.generateFileName("patches", ".zip");
            }

            saveAs(content, fileName);
            console.log(`Downloaded patches ZIP: ${fileName}`);
            console.log("ZIP contents:", {
              patchesWithVoids: patchesWithVoids.size,
              patchesWithoutVoids: patchesWithoutVoids.size,
              totalPatches: this.patchManager.allPatchCanvases.length,
              metadata: "included",
              voidData: "included",
              coordinates: this.csvRows.length,
            });
          });
        }

        showTypeSummary() {
          if (!this.patchManager.allPatchPages.length) {
            alert("Î®ºÏ†Ä Extract PatchesÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî.");
            return;
          }

          // Î™®Îì† ÌÉÄÏûÖÏùò summary ÎßàÏä§ÌÅ¨ ÏÉùÏÑ±
          const summaryMasks = this.patchManager.createAllTypeSummaryMasks();

          if (summaryMasks.size === 0) {
            alert("ÏÉùÏÑ±Ìï† summaryÍ∞Ä ÏóÜÏäµÎãàÎã§. voidÎ•º ÎßàÌÇπÌïú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.");
            return;
          }

          // Ìå®Ïπò Î∑∞Ïñ¥Ïóê summary ÎßàÏä§ÌÅ¨Îì§ ÌëúÏãú
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3>Type Summary - All Void Patterns</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          summaryMasks.forEach((summaryCanvas, chipType) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label" style="color: #e74c3c">${chipType.toUpperCase()} - ALL VOIDS</div>`;
            item.appendChild(summaryCanvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById("pageInfo").textContent = `Type Summary (${summaryMasks.size} types)`;

          console.log(`Displayed summary for types: ${Array.from(summaryMasks.keys()).join(', ')}`);
        }

        downloadVoids() {
          const voidData = this.voidManager.exportVoids();
          if (!voidData.length) {
            alert("No voids recorded.");
            return;
          }

          // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏôÄ Ìï®Íªò void Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
          const voidExportData = {
            metadata: this.getGridMetadata(),
            voidRecords: voidData,
            statistics: this.voidManager.getStats(),
            exportInfo: {
              totalVoids: voidData.length,
              exportDate: new Date().toISOString(),
              syncModeEnabled: this.voidManager.syncMode,
            },
          };

          const blob = new Blob([JSON.stringify(voidExportData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;

          const fileName = this.generateFileName("voids", ".json");
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);

          console.log(`Downloaded void JSON: ${fileName}`);
          console.log("Void export data:", {
            voids: voidData.length,
            metadata: "included",
            statistics: voidExportData.statistics,
          });
        }

        showVoidStats() {
          const stats = this.voidManager.getStats();
          alert(`Void Statistics:
Total Voids: ${stats.totalVoids}

By Type:
${Object.entries(stats.byType)
  .map(([type, count]) => `${type}: ${count}`)
  .join("\n")}

By Layer:
${Object.entries(stats.byLayer)
  .map(([layer, count]) => `Layer ${layer}: ${count}`)
  .join("\n")}

Check console for detailed info.`);
          console.log("Detailed void statistics:", stats);
        }

        debugCheck() {
          console.log("=== WAFER APP V2 DEBUG ===");
          console.log("Pages loaded:", this.pages.length);
          console.log("CSV rows:", this.csvRows.length);
          console.log("Patch pages:", this.allPatchPages.length);

          this.voidManager.debug();

          alert(`Debug Info:
Pages: ${this.pages.length}
CSV Rows: ${this.csvRows.length}
Void Records: ${this.voidManager.voids.size}
Check console for details.`);
        }

        /**
         * Ìå®Ïπò Ï†ïÎ†¨ ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateGridPreview() {
          const canvas = this.gridPreviewCanvas;
          const ctx = this.gridPreviewCtx;
          const statusDiv = document.getElementById("previewStatus");

          // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f8f8f8";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
          if (!this.pages.length) {
            ctx.fillStyle = "#999";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
              "Load TIFF file to see patch samples",
              canvas.width / 2,
              canvas.height / 2
            );
            statusDiv.textContent = "Load TIFF to see patch samples";
            return;
          }

          // ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Ïù¥ÎØ∏ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
          const currentPage = this.pages[this.pageIndex] || this.pages[0];

          // Í∑∏Î¶¨Îìú ÌååÎùºÎØ∏ÌÑ∞
          const cellW = +document.getElementById("cellW").value || 100;
          const cellH = +document.getElementById("cellH").value || 100;

          // ÏÉòÌîå Ï¢åÌëú Í≤∞Ï†ï
          const sampleCoords = this.getSampleCoordsForPreview();

          if (sampleCoords.length === 0) {
            // Î≥∏Îî© Ï¢åÌëúÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏÉòÌîå ÏúÑÏπò ÏÇ¨Ïö©
            sampleCoords.push(
              { x: 0, y: 0, label: "Center sample" },
              { x: 2, y: 1, label: "Sample 2" },
              { x: -1, y: -1, label: "Sample 3" }
            );
          }

          // ÏÉòÌîå Ìå®ÏπòÎì§ÏùÑ ÌîÑÎ¶¨Î∑∞Ïóê Í∑∏Î¶¨Í∏∞
          this.drawPatchSamples(ctx, currentPage, sampleCoords, cellW, cellH);

          // ÏÉÅÌÉú ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
          statusDiv.textContent = `Showing ${sampleCoords.length} patch samples (Cell: ${cellW}√ó${cellH})`;
        }

        /**
         * ÌîÑÎ¶¨Î∑∞Ïö© ÏÉòÌîå Ï¢åÌëú Í∞ÄÏ†∏Ïò§Í∏∞
         */
        getSampleCoordsForPreview() {
          if (this.csvRows.length === 0) return [];

          const samples = [];
          const maxSamples = 4; // ÌîÑÎ¶¨Î∑∞ÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏµúÎåÄ ÏÉòÌîå Ïàò

          if (this.csvRows.length <= maxSamples) {
            // Ï†ÑÏ≤¥ Ï¢åÌëúÍ∞Ä Ï†ÅÏúºÎ©¥ Î™®Îëê ÌëúÏãú
            return this.csvRows.map((coord, i) => ({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            }));
          }

          // Í∑†Îì±ÌïòÍ≤å Î∂ÑÏÇ∞Îêú ÏÉòÌîå ÏÑ†ÌÉù
          const step = Math.floor(this.csvRows.length / maxSamples);
          for (let i = 0; i < maxSamples; i++) {
            const coord = this.csvRows[i * step];
            samples.push({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            });
          }

          return samples;
        }

        /**
         * Ìå®Ïπò ÏÉòÌîåÎì§ÏùÑ ÌîÑÎ¶¨Î∑∞ Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶¨Í∏∞
         */
        drawPatchSamples(ctx, sourcePage, sampleCoords, cellW, cellH) {
          const canvas = ctx.canvas;
          const padding = 5;
          const cols = 2; // 2Ïó¥Î°ú Î∞∞Ïπò
          const rows = Math.ceil(sampleCoords.length / cols);

          const availableWidth = canvas.width - padding * 2;
          const availableHeight = canvas.height - padding * 2 - 20; // ÌÖçÏä§Ìä∏ Í≥µÍ∞Ñ

          const patchW = Math.floor(availableWidth / cols) - padding;
          const patchH = Math.floor(availableHeight / rows) - padding;

          // Ìå®Ïπò ÌÅ¨Í∏∞Î•º Ï†ïÏÇ¨Í∞ÅÌòïÏúºÎ°ú ÎßûÏ∂îÍ∏∞
          const patchSize = Math.min(patchW, patchH);

          sampleCoords.forEach((coord, index) => {
            const col = index % cols;
            const row = Math.floor(index / cols);

            const drawX = padding + col * (patchSize + padding);
            const drawY = padding + row * (patchSize + padding) + 15; // ÌÖçÏä§Ìä∏ Í≥µÍ∞Ñ

            // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÏóêÏÑú Ìå®Ïπò ÏòÅÏó≠ Í≥ÑÏÇ∞
            const sourceX = this.origin.x + (coord.x - this.refGrid.x) * cellW;
            const sourceY = this.origin.y + (coord.y - this.refGrid.y) * cellH;

            console.log(sourceX, sourceY, cellW, cellH);

            // Ìå®Ïπò Í∑∏Î¶¨Í∏∞
            try {
              ctx.drawImage(
                sourcePage,
                sourceX,
                sourceY,
                cellW,
                cellH,
                drawX,
                drawY,
                patchSize,
                patchSize
              );

              // Ìå®Ïπò Í≤ΩÍ≥ÑÏÑ†
              ctx.strokeStyle = "#333";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              // Ï¢åÌëú ÎùºÎ≤®
              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            } catch (error) {
              // Ïù¥ÎØ∏ÏßÄ ÏòÅÏó≠Ïù¥ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Í≤ΩÏö∞
              ctx.fillStyle = "#ffeeee";
              ctx.fillRect(drawX, drawY, patchSize, patchSize);
              ctx.strokeStyle = "#ff0000";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              ctx.fillStyle = "#ff0000";
              ctx.font = "9px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(
                "Out of",
                drawX + patchSize / 2,
                drawY + patchSize / 2 - 5
              );
              ctx.fillText(
                "bounds",
                drawX + patchSize / 2,
                drawY + patchSize / 2 + 5
              );

              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            }

            // Í∞Å Ìå®ÏπòÏóê Îπ®Í∞ÑÏ†ê ÌëúÏãú (Í∏∞Ï§ÄÏ†êÏù¥ Ïù¥ Ìå®ÏπòÏùò Ïñ¥Îäê ÏúÑÏπòÏù∏ÏßÄ)
            this.drawRedPointOnPatch(
              ctx,
              coord,
              drawX,
              drawY,
              patchSize,
              cellW,
              cellH
            );
          });
        }

        /**
         * Ïã§ÏãúÍ∞Ñ void ÎßàÏä§ÌÅ¨ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
         */
        createVoidMaskCanvas(chipCoord, type, forceCreate = false) {
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return null;

          const chipX = parseInt(match[1], 10);
          const chipY = parseInt(match[2], 10);
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;

          // Ìï¥Îãπ Ïπ©Ïóê voidÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
          const chipVoids = [];
          for (const [voidKey, voidData] of this.voidManager.voids.entries()) {
            if (voidData.x === chipX && voidData.y === chipY) {
              chipVoids.push(voidData);
            }
          }

          // forceCreateÍ∞Ä falseÏù¥Í≥† voidÍ∞Ä ÏóÜÏúºÎ©¥ null Î∞òÌôò (Ïù¥Ï†Ñ ÎèôÏûë)
          if (!forceCreate && chipVoids.length === 0) {
            return null;
          }

          // Ìà¨Î™Ö ÎßàÏä§ÌÅ¨ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ± (voidÍ∞Ä ÏóÜÏñ¥ÎèÑ Îπà Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±)
          const patchSize = 300;
          const titleH = 40;
          const maskCanvas = document.createElement("canvas");
          maskCanvas.width = patchSize;
          maskCanvas.height = (patchSize * cellH) / cellW + titleH;
          const maskCtx = maskCanvas.getContext("2d");

          // Î∞∞Í≤ΩÏùÑ Ìà¨Î™ÖÌïòÍ≤å ÏÑ§Ï†ï
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

          // ÌÉÄÏù¥ÌãÄ ÏòÅÏó≠ (Í≤ÄÏùÄ Î∞∞Í≤Ω)
          const label = `X${padCoord(chipX)}_Y${padCoord(
            chipY
          )}_L00_LEG:${type}`;
          maskCtx.fillStyle = "#000";
          maskCtx.fillRect(0, 0, patchSize, titleH);
          maskCtx.fillStyle = "#fff";
          maskCtx.font = "20px sans-serif";
          maskCtx.textBaseline = "middle";
          maskCtx.fillText(label, 6, titleH / 2);

          // void ÎßàÏä§ÌÅ¨ Í∑∏Î¶¨Í∏∞ (voidÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå)
          if (chipVoids.length > 0) {
            // Ïò¨Î∞îÎ•∏ patchLabel ÌòïÌÉúÎ°ú ÏÉùÏÑ±: X05_Y07_L01_LEG:type
            const properPatchLabel = `X${padCoord(chipX)}_Y${padCoord(chipY)}_L01_LEG:${type}`;
            // mergeMode = true, titleOffset = titleH ÏÇ¨Ïö©
            this.voidManager.drawVoids(maskCtx, properPatchLabel, true, titleH);
          }
          // voidÍ∞Ä ÏóÜÏúºÎ©¥ ÌÉÄÏù¥ÌãÄÎßå ÏûàÎäî Îπà Ï∫îÎ≤ÑÏä§

          return maskCanvas;
        }

        /**
         * Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏÑ§Ï†ï Ï†ïÎ≥¥ Ï†ÅÏö©
         */
        applyMetadata(metadata) {
          try {
            // Í∑∏Î¶¨Îìú ÏÑ§Ï†ï Ï†ÅÏö©
            if (metadata.gridSettings) {
              document.getElementById("cols").value =
                metadata.gridSettings.cols || 8;
              document.getElementById("rows").value =
                metadata.gridSettings.rows || 8;
              document.getElementById("cellW").value =
                metadata.gridSettings.cellW || 100;
              document.getElementById("cellH").value =
                metadata.gridSettings.cellH || 100;
            }

            // OriginÍ≥º Ï∞∏Ï°∞ Í∑∏Î¶¨Îìú Ï†ÅÏö©
            if (metadata.origin) {
              this.origin = { ...metadata.origin };
            }
            if (metadata.referenceGrid) {
              this.refGrid = { ...metadata.referenceGrid };
              document.getElementById("refX").value =
                metadata.referenceGrid.x || 0;
              document.getElementById("refY").value =
                metadata.referenceGrid.y || 0;
            }

            // Ìñ•ÏÉÅ ÏÑ§Ï†ï Ï†ÅÏö©
            if (metadata.enhanceSettings) {
              const settings = metadata.enhanceSettings;
              document.getElementById("alpha").value = settings.alpha || 1.2;
              document.getElementById("beta").value = settings.beta || 10;
              document.getElementById("targetMean").value =
                settings.targetMean || 0.5;
              document.getElementById("targetStd").value =
                settings.targetStd || 0.2;
              document.getElementById("padPx").value = settings.padPx || 10;
            }

            // TIFF ÌååÏùºÎ™Ö ÏÑ§Ï†ï (ÏûàÎäî Í≤ΩÏö∞)
            if (metadata.tiffFileName) {
              this.currentTiffFileName = metadata.tiffFileName;
              document.getElementById(
                "localTiffPath"
              ).value = `/${metadata.tiffFileName}.tif`;
            }

            return true;
          } catch (error) {
            console.error("Error applying metadata:", error);
            return false;
          }
        }

        /**
         * JSON ÌååÏùºÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
         */
        extractMetadataFromJson(jsonData) {
          // ÏßÅÏ†ë metadata Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
          if (jsonData.gridSettings && jsonData.origin) {
            return jsonData;
          }

          // void JSON ÌååÏùºÏù∏ Í≤ΩÏö∞ (metadata ÌïÑÎìú ÏïàÏóê ÏûàÏùå)
          if (jsonData.metadata) {
            return jsonData.metadata;
          }

          // Îã§Î•∏ Íµ¨Ï°∞Ïùº Ïàò ÏûàÏúºÎØÄÎ°ú null Î∞òÌôò
          return null;
        }

        /**
         * ÌòÑÏû¨ Í∑∏Î¶¨Îìú ÏÑ§Ï†ï Ï†ïÎ≥¥ ÏàòÏßë
         */
        getGridMetadata() {
          return {
            tiffFileName: this.currentTiffFileName,
            gridSettings: {
              cols: +document.getElementById("cols").value,
              rows: +document.getElementById("rows").value,
              cellW: +document.getElementById("cellW").value,
              cellH: +document.getElementById("cellH").value,
            },
            origin: { ...this.origin },
            referenceGrid: { ...this.refGrid },
            enhanceSettings: {
              alpha: parseFloat(document.getElementById("alpha").value),
              beta: parseFloat(document.getElementById("beta").value),
              targetMean: parseFloat(
                document.getElementById("targetMean").value
              ),
              targetStd: parseFloat(document.getElementById("targetStd").value),
              padPx: parseInt(document.getElementById("padPx").value, 10),
            },
            extractionInfo: {
              totalPages: this.pages.length,
              totalCoordinates: this.csvRows.length,
              totalPatches: this.patchManager.allPatchPages.length * this.pages.length,
              patchSize: 300, // Í≥†Ï†ï Ìå®Ïπò ÌÅ¨Í∏∞
            },
            timestamp: new Date().toISOString(),
            version: "v2",
          };
        }

        /**
         * ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ•º Ìè¨Ìï®Ìïú ÌååÏùºÎ™Ö ÏÉùÏÑ±
         */
        generateFileName(suffix = "", extension = "") {
          const now = new Date();
          const timestamp =
            now.getFullYear() +
            String(now.getMonth() + 1).padStart(2, "0") +
            String(now.getDate()).padStart(2, "0") +
            "_" +
            String(now.getHours()).padStart(2, "0") +
            String(now.getMinutes()).padStart(2, "0") +
            String(now.getSeconds()).padStart(2, "0");

          const baseName = this.currentTiffFileName || "wafer_data";
          return `${baseName}_${suffix}_${timestamp}${extension}`;
        }

        /**
         * void JSON ÎèôÍ∏∞Ìôî ÏÑ§Ï†ï
         */
        setupVoidJsonSync() {
          const voidJsonTextarea = document.getElementById("voidJson");

          // textarea Î≥ÄÍ≤Ω Ïãú void Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
          voidJsonTextarea.addEventListener("input", () => {
            try {
              const jsonData = JSON.parse(voidJsonTextarea.value);
              this.loadVoidDataFromJson(jsonData);
              this.patchManager.refreshCurrentPatches();
            } catch (error) {
              // JSON ÌååÏã± Ïò§Î•ò Ïãú Î¨¥Ïãú (ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÏù¥Ìïë Ï§ëÏùº Ïàò ÏûàÏùå)
            }
          });

          // Ï¥àÍ∏∞ ÌëúÏãú
          this.updateVoidJsonDisplay();
        }

        /**
         * void Îç∞Ïù¥ÌÑ∞Î•º JSONÏúºÎ°ú ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateVoidJsonDisplay() {
          const voidJsonTextarea = document.getElementById("voidJson");
          const voidData = this.voidManager.exportVoids();
          voidJsonTextarea.value = JSON.stringify(voidData, null, 2);
        }

        /**
         * JSON Îç∞Ïù¥ÌÑ∞ÏóêÏÑú void Îç∞Ïù¥ÌÑ∞ Î°úÎìú
         */
        loadVoidDataFromJson(jsonData) {
          // Í∏∞Ï°¥ void Îç∞Ïù¥ÌÑ∞ ÌÅ¥Î¶¨Ïñ¥
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();

          // JSON Îç∞Ïù¥ÌÑ∞ÏóêÏÑú void Î≥µÏõê
          jsonData.forEach((voidItem) => {
            const voidKey = voidItem.key;
            delete voidItem.key; // keyÎäî Î≥ÑÎèÑÎ°ú Ï≤òÎ¶¨
            this.voidManager.voids.set(voidKey, voidItem);

            // Ïù∏Îç±Ïä§ Ïπ¥Ïö¥ÌÑ∞ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            const locationKey = this.voidManager.createLocationKey(
              voidItem.x,
              voidItem.y,
              voidItem.layer
            );
            const currentMax =
              this.voidManager.voidIndexCounters.get(locationKey) || 0;
            this.voidManager.voidIndexCounters.set(
              locationKey,
              Math.max(currentMax, voidItem.voidIndex + 1)
            );
          });
        }

        /**
         * Ìå®ÏπòÏóê Îπ®Í∞ÑÏ†ê(Í∏∞Ï§ÄÏ†ê) ÌëúÏãú
         */
        drawRedPointOnPatch(
          ctx,
          coord,
          patchX,
          patchY,
          patchSize,
          cellW,
          cellH
        ) {
          // Í∏∞Ï§ÄÏ†êÏù¥ Ïù¥ Ìå®Ïπò ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
          const refRelativeX = this.refGrid.x - coord.x; // Í∏∞Ï§ÄÏ†êÏùò ÏÉÅÎåÄÏ†Å X ÏúÑÏπò
          const refRelativeY = this.refGrid.y - coord.y; // Í∏∞Ï§ÄÏ†êÏùò ÏÉÅÎåÄÏ†Å Y ÏúÑÏπò

          // Ìå®Ïπò ÎÇ¥Î∂Ä Ï¢åÌëúÎ°ú Î≥ÄÌôò (0~1 Î≤îÏúÑ)
          const refNormalizedX = refRelativeX + 0.5; // Ìå®Ïπò Ï§ëÏã¨Ïù¥ 0.5
          const refNormalizedY = refRelativeY + 0.5;

          // Ìå®Ïπò ÎÇ¥Î∂ÄÏóê ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Îπ®Í∞ÑÏ†ê ÌëúÏãú
          if (
            refNormalizedX >= 0 &&
            refNormalizedX <= 1 &&
            refNormalizedY >= 0 &&
            refNormalizedY <= 1
          ) {
            const redPointX = patchX + refNormalizedX * patchSize;
            const redPointY = patchY + refNormalizedY * patchSize;

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(redPointX, redPointY, 4, 0, 2 * Math.PI);
            ctx.fill();

            // Îπ®Í∞ÑÏ†ê Ï£ºÏúÑÏóê Ìù∞ÏÉâ ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        /**
         * Quick Test Mode - ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏûêÎèô Î°úÎìú
         */
        async loadQuickTestData() {
          const quickBtn = document.getElementById("quickTestBtn");
          const originalText = quickBtn.textContent;

          try {
            quickBtn.textContent = "Loading Test Data...";
            quickBtn.disabled = true;

            // 1. ÌÖåÏä§Ìä∏Ïö© TIFF ÌååÏùº ÏÑ§Ï†ï Î∞è Î°úÎìú
            const testTiffPath = "/realistic_wafer_sample_fast_1000.tif";
            document.getElementById("localTiffPath").value = testTiffPath;

            console.log("üöÄ Quick Test Mode: Loading TIFF file...");

            // TIFF Î°úÎìú
            const rangeServerUrl = `http://localhost:8083${testTiffPath}`;
            this.currentTiffFileName = "realistic_wafer_sample_fast";

            this.showProgress();
            this.updateProgress(10, "Loading test TIFF...", rangeServerUrl);

            this.pages = await ImageProcessor.loadTiffFromServer(
              rangeServerUrl,
              (current, total, details) => {
                const progress = 10 + (current / total) * 40; // 10-50%
                this.updateProgress(
                  progress,
                  `Loading page ${current}/${total}`,
                  details
                );
              }
            );

            this.updateProgress(55, "Loading test coordinates...", "");

            // 2. ÌÖåÏä§Ìä∏Ïö© Bonding Map Í≤©Ïûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            const testBondingMap = `	0	1	2	3	4	5
0	good	dummy	test	edge	good	test
1	dummy	good	good	good	edge	good
2	test	good	good	good	good	good
3	edge	good	good	good	good	good
4	good	edge	good	good	good	good
5	test	good	good	good	good	good`;

            console.log(
              "üöÄ Quick Test Mode: Loading Bonding Map coordinates..."
            );
            this.csvRows = parseBondingMap(testBondingMap);
            this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));

            // Bonding Map textareaÏóê Îç∞Ïù¥ÌÑ∞ ÌëúÏãú
            document.getElementById("csvPaste").value = testBondingMap;

            this.updateProgress(
              70,
              "Updating UI...",
              "Page selector and preview"
            );

            // 3. UI ÏóÖÎç∞Ïù¥Ìä∏
            this.updatePageSelect();
            await this.drawPage();
            this.updateGridPreview();

            this.updateProgress(
              90,
              "Setting optimal settings...",
              "Grid and enhancement"
            );

            // 4. ÏµúÏ†Å ÏÑ§Ï†ï Ï†ÅÏö©
            document.getElementById("cols").value = 6;
            document.getElementById("rows").value = 6;
            document.getElementById("cellW").value = 150;
            document.getElementById("cellH").value = 150;
            document.getElementById("alpha").value = 1.3;
            document.getElementById("beta").value = 15;
            document.getElementById("targetMean").value = 0.5;
            document.getElementById("targetStd").value = 0.2;

            // Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï
            document.getElementById("refX").value = 0;
            document.getElementById("refY").value = 0;
            this.refGrid = { x: 0, y: 0 };

            this.updateProgress(
              100,
              "Test data loaded!",
              "Ready for patch extraction"
            );

            console.log("üöÄ Quick Test Mode: Complete!");
            console.log(`- TIFF: ${this.pages.length} pages loaded`);
            console.log(`- Coordinates: ${this.csvRows.length} chips loaded`);

            setTimeout(() => this.hideProgress(), 2000);

            alert(`üöÄ Quick Test Mode Complete!

üìä Data Loaded:
- TIFF: ${this.pages.length} pages
- Coordinates: ${this.csvRows.length} chips
- Grid: 6x6, Cell: 150x150px
- Range: x(0~5), y(0~5)

‚úÖ Ready for testing:
1. Click "Extract Patches" to generate patches
2. Use void marking tools in right panel
3. Test sync mode and export features

Happy testing! üéØ`);
          } catch (error) {
            console.error("Quick Test Mode failed:", error);
            alert(`Quick Test Mode failed: ${error.message}`);
            this.hideProgress();
          } finally {
            quickBtn.textContent = originalText;
            quickBtn.disabled = false;
          }
        }
      }

      // Ïï± Ï¥àÍ∏∞Ìôî
      const app = new WaferAppV2();
      window.waferApp = app;
    </script>
  </body>
</html>
