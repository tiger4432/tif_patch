<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Wafer Grid Tool - V2</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist/geotiff.bundle.js"></script>
    <script type="module">
      import { ProgressManager } from './js/progressManager.js';
      import { FileSaveManager } from './js/fileSaveManager.js';
      window.ProgressManager = ProgressManager;
      window.FileSaveManager = FileSaveManager;
    </script>
  </head>
  <body>
    <div id="left">
      <h3>Load Data</h3>
      <div class="highlight-box" style="margin: 8px 0">
        <button
          id="quickTestBtn"
          style="
            font-size: 12px;
            background: #28a745;
            border-color: #28a745;
            margin-bottom: 6px;
            width: 100%;
          "
        >
          ğŸš€ Quick Test Mode
        </button>
        <input
          id="localTiffPath"
          type="text"
          placeholder="ì˜ˆ: /large_wafer_500chip_14900x14900_11layers.tif"
          style="font-size: 12px; margin-bottom: 4px"
        />
        <button id="loadLocalTiff" style="font-size: 12px">Load TIFF</button>
        <div
          id="memoryStatus"
          style="font-size: 12px; color: #6c757d; margin-top: 4px"
        >
          Memory: Ready
        </div>
        <div id="progressContainer" style="margin-top: 4px; display: none">
          <div style="font-size: 10px; margin-bottom: 2px">
            <span id="progressText">Loading...</span>
          </div>
          <div
            style="
              background: #ddd;
              border-radius: 2px;
              height: 4px;
              overflow: hidden;
            "
          >
            <div
              id="progressBar"
              style="
                background: linear-gradient(to right, #4caf50, #2196f3);
                height: 100%;
                width: 0%;
                transition: width 0.3s ease;
              "
            ></div>
          </div>
          <div style="font-size: 11px; color: #6c757d; margin-top: 1px">
            <span id="progressDetails"></span>
          </div>
        </div>
      </div>
      <textarea
        id="csvPaste"
        placeholder="Bonding Map ê²©ì í˜•íƒœ ë¶™ì—¬ë„£ê¸° (ì˜ˆ: íƒ­ìœ¼ë¡œ êµ¬ë¶„ëœ x,y ì¢Œí‘œ í‘œ)"
        style="height: 60px; font-size: 11px"
      ></textarea>
      <div style="margin-top: 6px">
        <label style="font-size: 13px; color: #495057"
          >Page:
          <select id="pageSelect" style="font-size: 12px"></select
        ></label>
      </div>

      <h3>Compression Settings</h3>
      <div class="info-panel" style="margin-bottom: 12px; padding: 8px">
        <strong style="font-size: 14px">Max Size:</strong>
        <div
          style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 4px;
            font-size: 12px;
          "
        >
          <label
            ><input type="radio" name="compression" value="2048" checked />
            2K</label
          >
          <label
            ><input type="radio" name="compression" value="4096" /> 4K</label
          >
          <label
            ><input type="radio" name="compression" value="6144" /> 6K</label
          >
          <label
            ><input type="radio" name="compression" value="8192" /> 8K</label
          >
        </div>
      </div>

      <h3>Grid</h3>
      Cols <input id="cols" type="number" value="8" /><br />
      Rows <input id="rows" type="number" value="8" /><br />
      Cell W <input id="cellW" type="number" value="100" /><br />
      Cell H <input id="cellH" type="number" value="100" /><br />

      <div style="margin-top: 10px">
        <strong>Patch Alignment Preview:</strong><br />
        <canvas
          id="gridPreview"
          width="300"
          height="200"
          style="border: 1px solid #ccc; margin-top: 5px"
        ></canvas>
        <div
          id="previewStatus"
          style="font-size: 11px; color: #666; margin-top: 2px"
        >
          Load TIFF to see patch samples
        </div>
      </div>
      <br />

      <h3>Reference Point</h3>
      ë¹¨ê°„ì  ì¢Œí‘œ ì§€ì •:<br />
      X: <input id="refX" type="number" value="0" style="width: 60px" /> Y:
      <input id="refY" type="number" value="0" style="width: 60px" />
      <button id="setRefBtn">Apply</button><br />
      <small style="color: #666">ë¹¨ê°„ì ì´ í‘œì‹œë  ì¹© ì¢Œí‘œë¥¼ ì…ë ¥í•˜ì„¸ìš”</small
      ><br /><br />

      <h3>Enhance</h3>
      Contrast Î± <input id="alpha" type="number" step="0.1" value="1.2" /><br />
      Brightness Î² <input id="beta" type="number" value="10" /><br /><br />

      <h3>Enhance Target</h3>
      Target Mean
      <input id="targetMean" type="number" step="0.01" value="0.5" /><br />
      Target Std
      <input id="targetStd" type="number" step="0.01" value="0.2" /><br />
      Padding(px) <input id="padPx" type="number" value="10" /><br /><br />

      <button id="extractBtn">Extract Patches</button>
      <button id="downloadZipBtn">Download All Patches (ZIP)</button>
      <button id="downloadFolderBtn">Download as Folder Structure</button>
      <label for="zipFileName">Save as:</label>
      <input
        type="text"
        id="zipFileName"
        placeholder="patches.zip"
        style="margin-left: 5px; width: 200px"
      />
      <button id="debugBtn">Debug Check</button>

      <h3>Load Settings</h3>
      <div class="highlight-box">
        <textarea
          id="metadataPaste"
          placeholder="Metadata JSON ë¶™ì—¬ë„£ê¸°"
          style="
            height: 80px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
          "
        ></textarea>
        <button id="loadMetadata" style="font-size: 12px">
          Apply Settings
        </button>
        <div style="font-size: 11px; color: #666; margin-top: 2px">
          Paste metadata.json or void JSON to restore grid settings
        </div>
      </div>
    </div>

    <div id="center">
      <canvas id="wafer"></canvas>
    </div>

    <div id="right">
      <div id="topControls">
        <h3>Patches</h3>
        <div id="voidControls">
          <textarea id="voidJson"></textarea>
          <button id="toggleVoidMode">Mark Void</button>
          <button id="toggleDeleteMode">Delete Void</button>
          <select id="voidTypeSelect">
            <option value="void">void</option>
            <option value="crack">crack</option>
            <option value="particle">particle</option>
            <option value="bbox">bbox</option>
          </select>
          <button id="toggleSyncMode">Sync Layers</button>
          <button id="downloadVoids">Download Voids JSON</button>
          <button id="voidStats">Void Stats</button>
          <button id="showSummary">Show Type Summary</button>
        </div>
        <div id="patchNav" style="margin-bottom: 10px; text-align: center">
          <button id="prevPage">â—€ Prev</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next â–¶</button>
        </div>
      </div>
      <div id="patches"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script type="module">
      // UTIF ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„í¬íŠ¸
      import UTIF from "https://cdn.skypack.dev/utif";
      window.UTIF = UTIF;

      // ëª¨ë“ˆ ì„í¬íŠ¸
      import { VOID_COLORS, VOID_KEY_MAP, CONFIG } from "./js/constants.js";
      import {
        padCoord,
        parsePatchLabel,
        parseBondingMap,
        parseCSV,
      } from "./js/utils.js";
      import { VoidManagerV2 } from "./js/voidManager_v2.js";
      import { ImageProcessor } from "./js/imageProcessor.js";
      import { PatchManager } from "./js/patchManager.js";

      // ì „ì—­ ìƒíƒœ
      class WaferAppV2 {
        constructor() {
          this.pages = [];
          this.pageIndex = 0;
          this.currentScale = 1;
          this.origin = { x: 50, y: 50 };
          this.refGrid = { x: 0, y: 0 };
          this.csvRows = [];
          this.chipPoints = [];
          this.currentTiffFileName = null; // í˜„ì¬ ë¡œë“œëœ TIFF íŒŒì¼ëª…

          // ìƒˆë¡œìš´ ë³´ì´ë“œ ë§¤ë‹ˆì €
          this.voidManager = new VoidManagerV2();

          // íŒ¨ì¹˜ ë§¤ë‹ˆì € ì´ˆê¸°í™”
          this.patchManager = new PatchManager(this.voidManager, this);
          this.voidMarkMode = false;
          this.deleteVoidMode = false;
          this.selectedVoid = null;
          this.resizeMode = false;

          // ëª¨ë“ˆ ë§¤ë‹ˆì € ì´ˆê¸°í™”
          this.progressManager = new window.ProgressManager();
          this.fileSaveManager = new window.FileSaveManager(this, this.progressManager);

          // ê·¸ë¦¬ë“œ í”„ë¦¬ë·° ì´ˆê¸°í™”
          this.gridPreviewCanvas = document.getElementById("gridPreview");
          this.gridPreviewCtx = this.gridPreviewCanvas.getContext("2d");

          this.initializeUI();
          this.setupEventHandlers();
          this.setupVoidJsonSync();
        }

        // Progress Bar Methods - ë¸ë¦¬ê²Œì´íŠ¸ ë©”ì„œë“œë“¤ (ProgressManager ì‚¬ìš©)
        showProgress() {
          this.progressManager.showProgress();
        }

        hideProgress() {
          this.progressManager.hideProgress();
        }

        showFolderSaveProgress() {
          this.progressManager.showFolderSaveProgress();
        }

        hideFolderSaveProgress() {
          this.progressManager.hideFolderSaveProgress();
        }

        updateFolderSaveProgress(current, total, text = "", details = "") {
          this.progressManager.updateFolderSaveProgress(current, total, text, details);
        }

        updateProgress(percentage, text = "", details = "") {
          this.progressManager.updateProgress(percentage, text, details);
        }

        showSuccess(message, duration = 2000) {
          this.progressManager.showSuccess(message, duration);
        }

        showError(message, duration = 3000) {
          this.progressManager.showError(message, duration);
        }

        showWaiting(message) {
          this.progressManager.showWaiting(message);
        }

        downloadVoids() {
          const voidData = this.voidManager.exportVoids();
          if (!voidData.length) {
            alert("No voids recorded.");
            return;
          }

          // ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ void ë°ì´í„° êµ¬ì„±
          const voidExportData = {
            metadata: this.getGridMetadata(),
            voidRecords: voidData,
            statistics: this.voidManager.getStats(),
            exportInfo: {
              totalVoids: voidData.length,
              exportDate: new Date().toISOString(),
              syncModeEnabled: this.voidManager.syncMode,
            },
          };

          const blob = new Blob([JSON.stringify(voidExportData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;

          const fileName = this.generateFileName("voids", ".json");
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        }

        initializeUI() {
          this.waferCanvas = document.getElementById("wafer");
          this.waferCtx = this.waferCanvas.getContext("2d");
          this.pageSelect = document.getElementById("pageSelect");

          this.markBtn = document.getElementById("toggleVoidMode");
          this.deleteBtn = document.getElementById("toggleDeleteMode");
          this.syncBtn = document.getElementById("toggleSyncMode");

          this.syncBtn.classList.toggle("mode-on", this.voidManager.syncMode);
        }

        setupEventHandlers() {
          // Quick Test Mode ë²„íŠ¼
          document.getElementById("quickTestBtn").onclick = async () => {
            await this.loadQuickTestData();
          };

          // ë¡œì»¬ ì„œë²„ì—ì„œ TIFF ë¡œë“œ (Range ì„œë²„ ì‚¬ìš©)
          document.getElementById("loadLocalTiff").onclick = async () => {
            const filePath = document.getElementById("localTiffPath").value;
            if (!filePath) {
              alert("íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: /large_image.tif)");
              return;
            }

            const loadBtn = document.getElementById("loadLocalTiff");
            const originalText = loadBtn.textContent;

            try {
              loadBtn.textContent = "Loading...";
              loadBtn.disabled = true;

              // Range ì„œë²„ URL êµ¬ì„± (í¬íŠ¸ 8083 ì‚¬ìš©)
              const rangeServerUrl = `http://localhost:8083${
                filePath.startsWith("/") ? filePath : "/" + filePath
              }`;

              // íŒŒì¼ëª… ì¶”ì¶œ ë° ì €ì¥
              const fileName = filePath.split("/").pop() || filePath;
              this.currentTiffFileName = fileName.replace(/\.[^/.]+$/, ""); // í™•ì¥ì ì œê±°

              console.log("Loading from Range server:", rangeServerUrl);
              console.log("TIFF file name:", this.currentTiffFileName);

              // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ì‹œì‘
              const memoryStatus = document.getElementById("memoryStatus");
              let initialMemory = null;

              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  initialMemory = ImageProcessor.getMemoryUsage();
                  if (initialMemory) {
                    console.log("Initial memory usage:", initialMemory);
                    memoryStatus.textContent = `Memory: ${initialMemory.used}MB / ${initialMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Not supported";
                  }
                } else {
                  console.warn("getMemoryUsage method not available");
                  memoryStatus.textContent = "Memory: Method not available";
                }
              } catch (error) {
                console.error("Memory monitoring error:", error);
                memoryStatus.textContent = "Memory: Error";
              }

              console.log("loadtitff");

              // í”„ë¡œê·¸ë ˆìŠ¤ë°” í‘œì‹œ
              this.showProgress();

              try {
                // Range ì„œë²„ë¥¼ í†µí•œ ë©”ëª¨ë¦¬ ìµœì í™”ëœ TIFF ë¡œë”©
                this.updateProgress(
                  10,
                  "Connecting to Range server...",
                  rangeServerUrl
                );
                this.pages = await ImageProcessor.loadTiffFromServer(
                  rangeServerUrl,
                  (current, total, details) => {
                    const progress = 10 + (current / total) * 90; // 10-80%
                    this.updateProgress(
                      progress,
                      `Loading page ${current}/${total}`,
                      details
                    );
                  }
                );

                this.updateProgress(
                  85,
                  "Processing pages...",
                  "Updating page selector"
                );
                this.updatePageSelect();

                this.updateProgress(
                  90,
                  "Rendering image...",
                  "Drawing current page"
                );
                await this.drawPage();

                this.updateProgress(
                  95,
                  "Updating preview...",
                  "Grid preview generation"
                );
                this.updateGridPreview();

                this.updateProgress(
                  100,
                  "Loading complete!",
                  `${this.pages.length} pages loaded successfully`
                );

                // 2ì´ˆ í›„ í”„ë¡œê·¸ë ˆìŠ¤ë°” ìˆ¨ê¸°ê¸°
                setTimeout(() => this.hideProgress(), 2000);
              } catch (error) {
                this.updateProgress(0, "Loading failed", error.message);
                setTimeout(() => this.hideProgress(), 3000);
                throw error;
              }

              // ìµœì¢… ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
              try {
                if (typeof ImageProcessor.getMemoryUsage === "function") {
                  const finalMemory = ImageProcessor.getMemoryUsage();
                  if (finalMemory && initialMemory) {
                    console.log("Final memory usage:", finalMemory);
                    const memoryIncrease =
                      finalMemory.used - initialMemory.used;
                    console.log("Memory increase:", memoryIncrease, "MB");
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB (+${memoryIncrease}MB)`;
                  } else if (finalMemory) {
                    memoryStatus.textContent = `Memory: ${finalMemory.used}MB / ${finalMemory.limit}MB`;
                  } else {
                    memoryStatus.textContent = "Memory: Load Complete";
                  }
                } else {
                  memoryStatus.textContent = "Memory: Load Complete";
                }
              } catch (error) {
                console.error("Final memory check error:", error);
                memoryStatus.textContent = "Memory: Load Complete";
              }

              // ì„±ê³µ ë©”ì‹œì§€
              const finalMemoryText = memoryStatus.textContent.includes("MB")
                ? memoryStatus.textContent.split(" ")[1]
                : "N/A";
              alert(
                `ë¡œì»¬ ì„œë²„ì—ì„œ ë¡œë“œ ì™„ë£Œ!\ní˜ì´ì§€ ìˆ˜: ${this.pages.length}\në©”ëª¨ë¦¬ ìƒíƒœ: ${finalMemoryText}`
              );
            } catch (error) {
              alert(error.message);
              console.error("Local server loading error:", error);
            } finally {
              loadBtn.textContent = originalText;
              loadBtn.disabled = false;
            }
          };

          // CSV ë¶™ì—¬ë„£ê¸°
          document
            .getElementById("csvPaste")
            .addEventListener("paste", async (e) => {
              const text = e.clipboardData.getData("text");
              this.csvRows = parseBondingMap(text);
              this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));
              alert(`ë³µë¶™í•œ ${this.csvRows.length}ê°œì˜ chip ì¢Œí‘œ ë¡œë“œ ì™„ë£Œ`);
              await this.drawPage();
              this.updateGridPreview();
            });

          // í˜ì´ì§€ ì„ íƒ
          this.pageSelect.addEventListener("change", async (e) => {
            this.pageIndex = parseInt(e.target.value) || 0;
            await this.drawPage();
            this.updateGridPreview();
          });

          // ì••ì¶• ì„¤ì • ë³€ê²½
          document
            .querySelectorAll('input[name="compression"]')
            .forEach((radio) => {
              radio.addEventListener("change", (e) => {
                if (e.target.checked) {
                  ImageProcessor.updateCompressionSettings(e.target.value);
                  console.log(
                    "Compression setting changed to:",
                    e.target.value
                  );

                  // ë©”ëª¨ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸
                  this.updateMemoryStatus();
                }
              });
            });

          // ê·¸ë¦¬ë“œ ë³€ê²½
          ["cols", "rows", "cellW", "cellH"].forEach((id) => {
            document.getElementById(id).addEventListener("input", async () => {
              await this.drawPage();
              this.updateGridPreview();
            });
          });

          // Void ê´€ë ¨ ë²„íŠ¼ë“¤
          this.markBtn.onclick = () => {
            this.voidMarkMode = !this.voidMarkMode;
            this.markBtn.classList.toggle("mode-on", this.voidMarkMode);
          };

          this.deleteBtn.onclick = () => {
            this.deleteVoidMode = !this.deleteVoidMode;
            this.deleteBtn.classList.toggle("mode-on", this.deleteVoidMode);
          };

          this.syncBtn.onclick = () => {
            const newState = this.voidManager.toggleSyncMode();
            this.syncBtn.classList.toggle("mode-on", newState);
            this.patchManager.refreshCurrentPatches();
          };

          // ê¸°íƒ€ ë²„íŠ¼ë“¤
          document.getElementById("extractBtn").onclick = async () =>
            await this.patchManager.extractPatches();
          document.getElementById("downloadZipBtn").onclick = () =>
            this.fileSaveManager.downloadZip();
          document.getElementById("downloadFolderBtn").onclick = () =>
            this.fileSaveManager.downloadAsFolderStructure();
          document.getElementById("downloadVoids").onclick = () =>
            this.downloadVoids();
          document.getElementById("voidStats").onclick = () =>
            this.showVoidStats();
          document.getElementById("showSummary").onclick = () =>
            this.showTypeSummary();
          document.getElementById("debugBtn").onclick = () => this.debugCheck();

          // ë©”íƒ€ë°ì´í„° ë¡œë“œ (ë³µë¶™ ë°©ì‹)
          document.getElementById("loadMetadata").onclick = async () => {
            const textarea = document.getElementById("metadataPaste");
            const text = textarea.value.trim();

            if (!text) {
              alert("Please paste metadata JSON first.");
              return;
            }

            try {
              const jsonData = JSON.parse(text);
              const metadata = this.extractMetadataFromJson(jsonData);

              if (!metadata) {
                alert(
                  "Invalid metadata format. Please paste a valid metadata.json or void JSON content."
                );
                return;
              }

              const success = this.applyMetadata(metadata);
              if (success) {
                // ê·¸ë¦¬ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                await this.drawPage();
                this.updateGridPreview();

                alert(
                  `Settings loaded successfully!\nTIFF: ${
                    metadata.tiffFileName || "Unknown"
                  }\nGrid: ${metadata.gridSettings?.cols}x${
                    metadata.gridSettings?.rows
                  }\nCell: ${metadata.gridSettings?.cellW}x${
                    metadata.gridSettings?.cellH
                  }`
                );

                console.log("Loaded metadata:", metadata);

                // textarea ì´ˆê¸°í™”
                textarea.value = "";
              } else {
                alert("Failed to apply metadata settings.");
              }
            } catch (error) {
              console.error("Error loading metadata:", error);
              alert("Failed to parse JSON. Please check the format.");
            }
          };

          // ìº”ë²„ìŠ¤ ë“œë˜ê·¸
          this.setupCanvasDrag();

          // ê¸°ì¤€ì  ì„¤ì •
          this.setupReferenceMode();

          // íŒ¨ì¹˜ ë„¤ë¹„ê²Œì´ì…˜
          document.getElementById("prevPage").onclick = async () =>
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage - 1
            );
          document.getElementById("nextPage").onclick = async () =>
            await this.patchManager.showPatchPage(
              this.patchManager.currentPatchPage + 1
            );

          // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
          document.addEventListener("keydown", (e) => {
            if (!this.voidMarkMode) return;
            const newType = VOID_KEY_MAP[e.key];
            if (newType) {
              document.getElementById("voidTypeSelect").value = newType;
            }
          });

          // ì´ˆê¸° ê·¸ë¦¬ë“œ í”„ë¦¬ë·° ì—…ë°ì´íŠ¸
          this.updateGridPreview();

          // ì›¨ì´í¼ ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (íŒŒë€ì  í´ë¦­ìœ¼ë¡œ íŒ¨ì¹˜ ì´ë™)
          this.setupWaferCanvasClick();
        }

        /**
         * ì›¨ì´í¼ ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ ì„¤ì •
         */
        setupWaferCanvasClick() {
          this.waferCanvas.addEventListener("click", async (e) => {
            // ë“œë˜ê·¸ ì¤‘ì´ê±°ë‚˜ ë³´ì´ë“œ ë§ˆí‚¹ ëª¨ë“œì¼ ë•ŒëŠ” ë¬´ì‹œ
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = this.waferCanvas.getBoundingClientRect();
            const scaleX = this.waferCanvas.width / rect.width;
            const scaleY = this.waferCanvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // í´ë¦­í•œ ì¢Œí‘œë¥¼ ê·¸ë¦¬ë“œ ì¢Œí‘œë¡œ ë³€í™˜
            const cellW =
              +document.getElementById("cellW").value * this.currentScale;
            const cellH =
              +document.getElementById("cellH").value * this.currentScale;

            const gridX = Math.floor(
              (clickX - this.origin.x * this.currentScale) / cellW
            );
            const gridY = Math.floor(
              (clickY - this.origin.y * this.currentScale) / cellH
            );

            // ì‹¤ì œ ì¹© ì¢Œí‘œë¡œ ë³€í™˜ (ê¸°ì¤€ì  ê³ ë ¤)
            const chipX = gridX + this.refGrid.x;
            const chipY = gridY + this.refGrid.y;

            // Auto bbox detection ëª¨ë“œì¼ ë•Œ bbox íƒì§€ ìˆ˜í–‰
            if (this.voidManager.autoBboxDetection) {
              await this.detectBboxForChip(chipX, chipY);
              return;
            }

            // í•´ë‹¹ ì¢Œí‘œì˜ íŒ¨ì¹˜ë¥¼ ì°¾ì•„ì„œ ì´ë™
            await this.patchManager.navigateToChipPatch(chipX, chipY);
          });
        }

        /**
         * íŠ¹ì • ì¹©ì—ì„œ bbox íƒì§€ ìˆ˜í–‰
         */
        async detectBboxForChip(chipX, chipY) {
          console.log(`Detecting bbox for chip (${chipX}, ${chipY})`);

          // í•´ë‹¹ ì¹©ì˜ íŒ¨ì¹˜ ì°¾ê¸°
          const targetCoord = `(${chipX},${chipY})`;
          const targetPatch = this.allPatchPages.find(
            (patch) => patch.coord === targetCoord
          );

          if (!targetPatch) {
            console.log(`No patch found for chip (${chipX}, ${chipY})`);
            return;
          }

          // ê° ë ˆì´ì–´ì—ì„œ bbox íƒì§€ ìˆ˜í–‰
          for (const layerData of targetPatch.layers) {
            if (layerData.canvas) {
              const detectedBboxes = this.voidManager.detectBboxFromImage(
                layerData.canvas,
                chipX,
                chipY,
                300
              );

              console.log(
                `Detected ${detectedBboxes.length} bboxes for chip (${chipX}, ${chipY}) layer ${layerData.layer}`
              );
            }
          }

          // í™”ë©´ ì—…ë°ì´íŠ¸
          this.refreshCurrentPatches();
        }

        /**
         * íŠ¹ì • ì¹© ì¢Œí‘œì˜ íŒ¨ì¹˜ë¡œ ì´ë™
         */
        async navigateToChipPatch(chipX, chipY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          // í•´ë‹¹ ì¢Œí‘œì˜ íŒ¨ì¹˜ ì°¾ê¸°
          const targetCoord = `(${chipX},${chipY})`;
          const patchIndex = this.patchManager.allPatchPages.findIndex(
            (patch) => patch.coord === targetCoord
          );

          if (patchIndex !== -1) {
            this.patchManager.currentPatchPage = patchIndex;
            await this.patchManager.showPatchPage(patchIndex);
            await this.drawPage(); // ì´ˆë¡ì  ì—…ë°ì´íŠ¸

            console.log(
              `Navigated to patch: ${targetCoord} (index: ${patchIndex})`
            );
          } else {
            console.log(`No patch found for coordinates: ${targetCoord}`);
          }
        }

        updatePageSelect() {
          this.pageSelect.innerHTML = this.pages
            .map((_, i) => `<option value="${i}">Page ${i + 1}</option>`)
            .join("");
          this.pageIndex = 0;
        }

        async drawPage() {
          if (!this.pages.length) return;

          const src = this.pages[this.pageIndex];

          // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
          const memory = ImageProcessor.getMemoryUsage();
          if (memory) {
            console.log(
              `Current memory usage: ${memory.used}MB / ${memory.limit}MB`
            );

            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ìœ¼ë©´ ê²½ê³ 
            if (memory.used / memory.limit > 0.8) {
              console.warn("High memory usage detected");
            }
          }

          this.currentScale = ImageProcessor.drawPage(src, this.waferCanvas);
          this.drawGrid();
        }

        drawGrid() {
          if (!this.pages.length) return;

          const cols = +document.getElementById("cols").value;
          const rows = +document.getElementById("rows").value;
          const cellW =
            +document.getElementById("cellW").value * this.currentScale;
          const cellH =
            +document.getElementById("cellH").value * this.currentScale;

          // ê¸°ì¤€ì ë„ ìŠ¤ì¼€ì¼ ì ìš©
          const scaledOriginX = this.origin.x * this.currentScale;
          const scaledOriginY = this.origin.y * this.currentScale;

          this.waferCtx.strokeStyle = "lime";
          this.waferCtx.lineWidth = 1;

          // ìˆ˜ì§ì„  ê·¸ë¦¬ê¸°
          for (let i = 0; i <= cols; i++) {
            const x = scaledOriginX + i * cellW;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(x, scaledOriginY);
            this.waferCtx.lineTo(x, scaledOriginY + rows * cellH);
            this.waferCtx.stroke();
          }

          // ìˆ˜í‰ì„  ê·¸ë¦¬ê¸°
          for (let j = 0; j <= rows; j++) {
            const y = scaledOriginY + j * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.moveTo(scaledOriginX, y);
            this.waferCtx.lineTo(scaledOriginX + cols * cellW, y);
            this.waferCtx.stroke();
          }

          // ì¹© í¬ì¸íŠ¸ (íŒŒë€ ì ) - ìŠ¤ì¼€ì¼ ì ìš©
          this.waferCtx.fillStyle = "deepskyblue";
          this.chipPoints.forEach((pt) => {
            const px = scaledOriginX + (pt.x - this.refGrid.x + 0.5) * cellW;
            const py = scaledOriginY + (pt.y - this.refGrid.y + 0.5) * cellH;
            this.waferCtx.beginPath();
            this.waferCtx.arc(
              px,
              py,
              Math.max(3, cellW * 0.05),
              0,
              2 * Math.PI
            );
            this.waferCtx.fill();
          });

          // ê¸°ì¤€ì  (ë¹¨ê°„ ì ) - ìŠ¤ì¼€ì¼ ì ìš©
          this.waferCtx.fillStyle = "red";
          const refPixelX = scaledOriginX + 0.5 * cellW;
          const refPixelY = scaledOriginY + 0.5 * cellH;
          this.waferCtx.beginPath();
          this.waferCtx.arc(refPixelX, refPixelY, 6, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // í˜„ì¬ íŒ¨ì¹˜ (ì´ˆë¡ ì ) - ìŠ¤ì¼€ì¼ ì ìš©
          this.drawCurrentPatchIndicator(
            cellW,
            cellH,
            scaledOriginX,
            scaledOriginY
          );
        }

        /**
         * í˜„ì¬ ë³´ê³  ìˆëŠ” íŒ¨ì¹˜ë¥¼ ì´ˆë¡ì ìœ¼ë¡œ í‘œì‹œ (ìŠ¤ì¼€ì¼ ì ìš©)
         */
        drawCurrentPatchIndicator(cellW, cellH, scaledOriginX, scaledOriginY) {
          if (this.patchManager.allPatchPages.length === 0) return;

          const currentPatch =
            this.patchManager.allPatchPages[this.patchManager.currentPatchPage];
          if (!currentPatch) return;

          // í˜„ì¬ íŒ¨ì¹˜ì˜ ì¢Œí‘œ íŒŒì‹±
          const match = currentPatch.coord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) {
            console.log(
              "Failed to parse patch coordinates:",
              currentPatch.coord
            );
            return;
          }

          const patchX = parseInt(match[1], 10);
          const patchY = parseInt(match[2], 10);

          // í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜ (ìŠ¤ì¼€ì¼ ì ìš©)
          const px = scaledOriginX + (patchX - this.refGrid.x + 0.5) * cellW;
          const py = scaledOriginY + (patchY - this.refGrid.y + 0.5) * cellH;

          console.log(
            `Drawing green dot for patch (${patchX},${patchY}) at screen (${px},${py})`
          );

          // ì´ˆë¡ì  ê·¸ë¦¬ê¸° (ë¹¨ê°„ì ë³´ë‹¤ ì•½ê°„ í¬ê²Œ)
          this.waferCtx.fillStyle = "lime";
          this.waferCtx.beginPath();
          this.waferCtx.arc(px, py, 8, 0, 2 * Math.PI);
          this.waferCtx.fill();

          // í…Œë‘ë¦¬ ì¶”ê°€ (ê°€ë…ì„± í–¥ìƒ)
          this.waferCtx.strokeStyle = "darkgreen";
          this.waferCtx.lineWidth = 2;
          this.waferCtx.stroke();
        }

        setupCanvasDrag() {
          let dragging = false;
          let start = { x: 0, y: 0 };
          let previewUpdateTimeout = null;

          this.waferCanvas.addEventListener("mousedown", (e) => {
            dragging = true;
            this.waferCanvas.classList.add("dragging");
            start.x = e.clientX;
            start.y = e.clientY;
          });

          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              this.waferCanvas.classList.remove("dragging");
              // ë“œë˜ê·¸ ì™„ë£Œ ì‹œ ì¦‰ì‹œ í”„ë¦¬ë·° ì—…ë°ì´íŠ¸
              this.updateGridPreview();
            }
          });

          window.addEventListener("mousemove", async (e) => {
            if (!dragging) return;
            const deltaX = e.clientX - start.x;
            const deltaY = e.clientY - start.y;

            // ìŠ¤ì¼€ì¼ì„ ê³ ë ¤í•œ ë“œë˜ê·¸
            this.origin.x += deltaX / this.currentScale;
            this.origin.y += deltaY / this.currentScale;

            start.x = e.clientX;
            start.y = e.clientY;
            await this.drawPage();

            // ë“œë˜ê·¸ ì¤‘ í”„ë¦¬ë·° ì—…ë°ì´íŠ¸ (throttling ì ìš©)
            if (previewUpdateTimeout) {
              clearTimeout(previewUpdateTimeout);
            }
            previewUpdateTimeout = setTimeout(() => {
              this.updateGridPreview();
            }, 100); // 100ms ë”œë ˆì´
          });
        }

        setupReferenceMode() {
          const setRefBtn = document.getElementById("setRefBtn");
          const refXInput = document.getElementById("refX");
          const refYInput = document.getElementById("refY");

          // ì¢Œí‘œ ì…ë ¥ê°’ì´ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
          const updateReference = async () => {
            const refX = parseInt(refXInput.value) || 0;
            const refY = parseInt(refYInput.value) || 0;

            this.refGrid = { x: refX, y: refY };
            await this.drawPage();
            this.updateGridPreview();

            console.log(`Reference point set to: (${refX}, ${refY})`);
          };

          // Apply Reference ë²„íŠ¼ í´ë¦­
          setRefBtn.onclick = updateReference;

          // Enter í‚¤ ì²˜ë¦¬
          refXInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          refYInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") updateReference();
          });

          // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (ì„ íƒì‚¬í•­)
          refXInput.addEventListener("input", updateReference);
          refYInput.addEventListener("input", updateReference);
        }

        async extractPatches() {
          if (!this.pages.length) {
            alert("TIFF íŒŒì¼ì„ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”!");
            return;
          }
          if (!this.csvRows.length) {
            alert("CSV ë°ì´í„°ë¥¼ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”!");
            return;
          }

          // ê¸°ì¡´ ë³´ì´ë“œ ë°ì´í„° ì´ˆê¸°í™”
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();
          console.log("Void data cleared for new patch extraction");

          this.allPatchPages = [];
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;
          const tMean = parseFloat(document.getElementById("targetMean").value);
          const tStd = parseFloat(document.getElementById("targetStd").value);
          const pad = parseInt(document.getElementById("padPx").value, 10);
          window.allPatchCanvases = [];

          this.csvRows.forEach((r) => {
            const pageData = {
              coord: `(${r.x},${r.y})`,
              layers: [],
              type: r.type,
            };

            this.pages.forEach((src, pageIdx) => {
              const gx = this.origin.x + (r.x - this.refGrid.x) * cellW;
              const gy = this.origin.y + (r.y - this.refGrid.y) * cellH;

              console.log(gx, gy, cellW, cellH);

              const titleH = 40;
              const patchSize = 300; // ê³ ì • íŒ¨ì¹˜ í¬ê¸°
              const c = document.createElement("canvas");
              c.width = patchSize;
              c.height = (patchSize * cellH) / cellW + titleH;
              const ctx = c.getContext("2d");

              const label = `X${padCoord(r.x)}_Y${padCoord(r.y)}_L${String(
                pageIdx + 1
              ).padStart(2, "0")}_LEG:${r.type || "NA"}`;
              ctx.fillStyle = "#000";
              ctx.fillRect(0, 0, patchSize, titleH);
              ctx.fillStyle = "#fff";
              ctx.font = "20px sans-serif";
              ctx.textBaseline = "middle";
              ctx.fillText(label, 6, titleH / 2);

              ctx.drawImage(
                src,
                gx,
                gy,
                cellW,
                cellH,
                0,
                titleH,
                patchSize,
                (patchSize * cellH) / cellW
              );

              // ì´ë¯¸ì§€ í–¥ìƒ ë¨¼ì € ìˆ˜í–‰
              const subImg = ctx.getImageData(0, titleH, c.width, c.height);
              const tmp = document.createElement("canvas");
              tmp.width = c.width;
              tmp.height = c.height;
              tmp.getContext("2d").putImageData(subImg, 0, 0);
              ImageProcessor.enhanceToTarget(
                tmp.getContext("2d"),
                tMean,
                tStd,
                pad
              );
              ctx.putImageData(
                tmp.getContext("2d").getImageData(0, 0, c.width, c.height),
                0,
                titleH
              );

              // ë³´ì • ì™„ë£Œëœ ì´ë¯¸ì§€ ë°ì´í„° ì €ì¥
              const enhancedImageData = ctx.getImageData(
                0,
                0,
                c.width,
                c.height
              );

              this.attachVoidEvents(c, label, enhancedImageData);

              pageData.layers.push({
                canvas: c,
                label,
                type: r.type || "NA",
                layer: pageIdx + 1,
                imageData: enhancedImageData,
              });

              const typeFolder = r.type
                ? r.type.replace(/[^a-zA-Z0-9_-]/g, "_")
                : "NA";
              window.allPatchCanvases.push({
                canvas: c,
                layer: pageIdx + 1,
                label,
                type: typeFolder,
              });
            });

            this.allPatchPages.push(pageData);
          });

          this.currentPatchPage = 0;
          await this.showPatchPage(0);

          // ë³´ì´ë“œ ë°ì´í„° ì´ˆê¸°í™” í›„ íŒ¨ì¹˜ ë·°ì–´ ê°±ì‹ 
          this.refreshCurrentPatches();

          console.log(
            `íŒ¨ì¹˜ ì¶”ì¶œ ì™„ë£Œ: ${this.allPatchPages.length}ê°œ ì¢Œí‘œ, ì´ ${
              this.allPatchPages.length * this.pages.length
            }ê°œ íŒ¨ì¹˜`
          );
        }

        attachVoidEvents(canvas, patchLabel, imageData) {
          const ctx = canvas.getContext("2d");
          const { chipCoord, layer } = parsePatchLabel(patchLabel);
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return;

          const x = parseInt(match[1], 10);
          const y = parseInt(match[2], 10);

          const repaint = () => {
            ctx.putImageData(imageData, 0, 0);
            this.voidManager.drawVoids(ctx, patchLabel);
          };

          // ë³´ì´ë“œ ë§ˆí‚¹
          canvas.addEventListener("mousedown", (e) => {
            if (!this.voidMarkMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const sx = (e.clientX - rect.left) * scaleX;
            const sy = (e.clientY - rect.top) * scaleY;

            const drag = (me) => {
              const cx = (me.clientX - rect.left) * scaleX;
              const cy = (me.clientY - rect.top) * scaleY;
              repaint();
              const selType =
                document.getElementById("voidTypeSelect").value || "default";
              ctx.strokeStyle = VOID_COLORS[selType] || VOID_COLORS.default;
              ctx.lineWidth = 2;
              ctx.beginPath();

              if (selType === "bbox") {
                // bbox íƒ€ì…ì´ë©´ ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
                ctx.strokeRect(
                  Math.min(sx, cx),
                  Math.min(sy, cy),
                  Math.abs(cx - sx),
                  Math.abs(cy - sy)
                );
              } else {
                // ì¼ë°˜ void íƒ€ì…ì´ë©´ íƒ€ì› ê·¸ë¦¬ê¸°
                ctx.ellipse(
                  (sx + cx) / 2,
                  (sy + cy) / 2,
                  Math.abs(cx - sx) / 2,
                  Math.abs(cy - sy) / 2,
                  0,
                  0,
                  2 * Math.PI
                );
                ctx.stroke();
              }
            };

            const up = (ue) => {
              document.removeEventListener("mousemove", drag);
              document.removeEventListener("mouseup", up);
              const ex = (ue.clientX - rect.left) * scaleX;
              const ey = (ue.clientY - rect.top) * scaleY;
              const type =
                document.getElementById("voidTypeSelect").value || "void";

              let newVoid;

              if (type === "bbox") {
                // bbox íƒ€ì…ì´ë©´ ì‚¬ê°í˜•ìœ¼ë¡œ ì €ì¥
                const rectX = Math.min(sx, ex);
                const rectY = Math.min(sy, ey);
                const rectW = Math.abs(ex - sx);
                const rectH = Math.abs(ey - sy);

                // bboxëŠ” centerX, centerYì— ì¢Œìƒë‹¨ ì¢Œí‘œë¥¼ ì €ì¥í•˜ê³  radiusX, radiusYì— ë„ˆë¹„, ë†’ì´ë¥¼ ì €ì¥
                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  rectX, // centerXì— x ì¢Œí‘œ
                  rectY, // centerYì— y ì¢Œí‘œ
                  rectW, // radiusXì— width
                  rectH // radiusYì— height
                );
              } else {
                // ì¼ë°˜ void íƒ€ì…ì´ë©´ íƒ€ì›ìœ¼ë¡œ ì €ì¥
                const centerX = (sx + ex) / 2;
                const centerY = (sy + ey) / 2;
                const radiusX = Math.abs(ex - sx) / 2;
                const radiusY = Math.abs(ey - sy) / 2;

                newVoid = this.voidManager.createVoid(
                  patchLabel,
                  type,
                  centerX,
                  centerY,
                  radiusX,
                  radiusY
                );
              }

              if (newVoid) {
                this.patchManager.refreshCurrentPatches();
                this.updateVoidJsonDisplay(); // JSON ì—…ë°ì´íŠ¸ ì¶”ê°€
              } else {
                repaint();
              }
            };

            // void ë§ˆí‚¹ ëª¨ë“œì¼ ë•Œë§Œ void ì´ë²¤íŠ¸ ì—°ê²°
            if (this.voidMarkMode) {
              document.addEventListener("mousemove", drag);
              document.addEventListener("mouseup", up);
            }
          });

          // ë³´ì´ë“œ ì‚­ì œ (í•´ë‹¹ ë ˆì´ì–´ì—ì„œë§Œ)
          canvas.addEventListener("click", (e) => {
            if (!this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            console.log(
              `Attempting to delete void at (${x},${y},${layer}) click:(${clickX},${clickY})`
            );

            const deleted = this.voidManager.deleteVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );

            console.log(`Delete result: ${deleted}`);

            if (deleted) {
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ì—…ë°ì´íŠ¸ ì¶”ê°€
            }
          });

          // ë³´ì´ë“œ í¸ì§‘ (í•´ë‹¹ ë ˆì´ì–´ì—ì„œë§Œ)
          canvas.addEventListener("mousedown", (e) => {
            if (this.voidMarkMode || this.deleteVoidMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            const editableVoid = this.voidManager.findEditableVoid(
              x,
              y,
              layer,
              clickX,
              clickY
            );
            if (!editableVoid) return;

            this.selectedVoid = editableVoid;
            const originalCenterX = editableVoid.centerX;
            const originalCenterY = editableVoid.centerY;

            // ì´ë™ vs í¬ê¸°ì¡°ì ˆ íŒë‹¨
            const dx = clickX - editableVoid.centerX;
            const dy = clickY - editableVoid.centerY;
            const angle = Math.atan2(dy, dx);
            const rB =
              (editableVoid.radiusX * editableVoid.radiusY) /
              Math.sqrt(
                (editableVoid.radiusY * Math.cos(angle)) ** 2 +
                  (editableVoid.radiusX * Math.sin(angle)) ** 2
              );
            const dist = Math.hypot(dx, dy);

            this.resizeMode = Math.abs(dist - rB) <= CONFIG.TOLERANCE;
            const offsetX = clickX - editableVoid.centerX;
            const offsetY = clickY - editableVoid.centerY;

            const moveHandler = (me) => {
              const mx = (me.clientX - rect.left) * scaleX;
              const my = (me.clientY - rect.top) * scaleY;

              if (this.resizeMode) {
                const newRadiusX = Math.abs(mx - editableVoid.centerX);
                const newRadiusY = Math.abs(my - editableVoid.centerY);

                if (me.shiftKey) {
                  const r = Math.max(newRadiusX, newRadiusY);
                  editableVoid.radiusX = editableVoid.radiusY = r;
                } else {
                  editableVoid.radiusX = newRadiusX;
                  editableVoid.radiusY = newRadiusY;
                }
              } else {
                editableVoid.centerX = mx - offsetX;
                editableVoid.centerY = my - offsetY;
              }

              repaint();
            };

            const upHandler = () => {
              document.removeEventListener("mousemove", moveHandler);
              document.removeEventListener("mouseup", upHandler);

              // ë³€ê²½ì‚¬í•­ ì €ì¥ (ì‹¤ì œë¡œëŠ” ì´ë¯¸ editableVoid ê°ì²´ê°€ ìˆ˜ì •ë˜ì—ˆìŒ)
              this.patchManager.refreshCurrentPatches();
              this.updateVoidJsonDisplay(); // JSON ì—…ë°ì´íŠ¸ ì¶”ê°€
              this.selectedVoid = null;
            };

            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
          });
        }

        refreshCurrentPatches() {
          if (
            !this.allPatchPages.length ||
            this.currentPatchPage >= this.allPatchPages.length
          )
            return;

          const currentPage = this.allPatchPages[this.currentPatchPage];
          currentPage.layers.forEach((layerInfo) => {
            const ctx = layerInfo.canvas.getContext("2d");
            ctx.putImageData(layerInfo.imageData, 0, 0);
            this.voidManager.drawVoids(ctx, layerInfo.label);
          });

          // void JSON ì—…ë°ì´íŠ¸
          this.updateVoidJsonDisplay();

          // íŒ¨ì¹˜ ë·°ì–´ ì „ì²´ ìƒˆë¡œê³ ì¹¨ (void ë§ˆìŠ¤í¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
          this.showPatchPage(this.currentPatchPage);
        }

        async showPatchPage(idx) {
          if (!this.allPatchPages.length) return;
          if (idx < 0) idx = 0;
          if (idx >= this.allPatchPages.length)
            idx = this.allPatchPages.length - 1;
          this.currentPatchPage = idx;

          const page = this.allPatchPages[idx];
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3 >Chip ${page.coord}</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          // void ë§ˆìŠ¤í¬ ë¨¼ì € ì¶”ê°€ (ê°€ì¥ ë§¨ ìœ„, í•­ìƒ í‘œì‹œ)
          const voidMaskCanvas = this.createVoidMaskCanvas(
            page.coord,
            page.type,
            true
          ); // í•­ìƒ ìƒì„±
          const voidItem = document.createElement("div");
          voidItem.className = "layer-item";
          voidItem.innerHTML = `<div class="layer-label" style="color: #e74c3c">VOID MASK (ALL LAYERS)</div>`;
          voidItem.appendChild(voidMaskCanvas);
          layersWrap.appendChild(voidItem);

          // ê¸°ì¡´ ë ˆì´ì–´ë“¤ ì¶”ê°€
          page.layers.forEach((l) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label">${l.label}</div>`;
            item.appendChild(l.canvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById("pageInfo").textContent = `Page ${
            this.currentPatchPage + 1
          } / ${this.allPatchPages.length}`;

          // í˜„ì¬ íŒ¨ì¹˜ ë³€ê²½ ì‹œ ê·¸ë¦¬ë“œì˜ ì´ˆë¡ì  ì—…ë°ì´íŠ¸
          await this.drawPage();
        }




        /**
         * íŒŒì¼/í´ë”ëª…ì—ì„œ í—ˆìš©ë˜ì§€ ì•ŠëŠ” ë¬¸ì ì œê±°
         */
        sanitizeFileName(fileName) {
          // Windows/Mac/Linuxì—ì„œ í—ˆìš©ë˜ì§€ ì•ŠëŠ” ë¬¸ìë“¤ ì œê±°
          return fileName
            .replace(/[<>:"\/\\|?*\x00-\x1f]/g, '_')  // íŠ¹ìˆ˜ë¬¸ìë¥¼ '_'ë¡œ ëŒ€ì²´
            .replace(/\.$/, '_')  // ë§ˆì§€ë§‰ ì  ì œê±°
            .replace(/\s+/g, '_')  // ê³µë°±ì„ '_'ë¡œ ëŒ€ì²´
            .substring(0, 255);  // ê¸¸ì´ ì œí•œ
        }


        /**
         * README ë‚´ìš© ìƒì„±
         */
        generateReadmeContent(metadata) {
          return `# Wafer Patch Extraction Data

TIFF File: ${metadata.tiffFileName || "Unknown"}
Extraction Date: ${metadata.timestamp}
Version: ${metadata.version}

## Grid Settings
- Columns: ${metadata.gridSettings.cols}
- Rows: ${metadata.gridSettings.rows}
- Cell Width: ${metadata.gridSettings.cellW}px
- Cell Height: ${metadata.gridSettings.cellH}px

## Alignment
- Origin: (${metadata.origin.x}, ${metadata.origin.y})
- Reference Grid: (${metadata.referenceGrid.x}, ${metadata.referenceGrid.y})

## Enhancement Settings
- Alpha (Contrast): ${metadata.enhanceSettings.alpha}
- Beta (Brightness): ${metadata.enhanceSettings.beta}
- Target Mean: ${metadata.enhanceSettings.targetMean}
- Target Std: ${metadata.enhanceSettings.targetStd}
- Padding: ${metadata.enhanceSettings.padPx}px

## Extraction Info
- Total Pages: ${metadata.extractionInfo.totalPages}
- Total Coordinates: ${metadata.extractionInfo.totalCoordinates}
- Total Patches: ${metadata.extractionInfo.totalPatches}
- Patch Size: ${metadata.extractionInfo.patchSize}px

## Folder Structure
- no_voids/[type]/layer_[XX]/[patch_name].png (patches without voids)
- split/[type]/layer_[XX]/[patch_name].png (patches with void markings)
- merge/[type]/[patch_name]_merge.png (merged mask layers)
- summary/[type]_summary.png (type-based void pattern summaries)
- metadata.json: Grid and extraction settings
- coordinates.json: Chip coordinate data
- voids.json: Void detection data
`;
        }


        showTypeSummary() {
          if (!this.patchManager.allPatchPages.length) {
            alert("ë¨¼ì € Extract Patchesë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.");
            return;
          }

          // ëª¨ë“  íƒ€ì…ì˜ summary ë§ˆìŠ¤í¬ ìƒì„±
          const summaryMasks = this.patchManager.createAllTypeSummaryMasks();

          if (summaryMasks.size === 0) {
            alert(
              "ìƒì„±í•  summaryê°€ ì—†ìŠµë‹ˆë‹¤. voidë¥¼ ë§ˆí‚¹í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”."
            );
            return;
          }

          // íŒ¨ì¹˜ ë·°ì–´ì— summary ë§ˆìŠ¤í¬ë“¤ í‘œì‹œ
          const patchesDiv = document.getElementById("patches");
          patchesDiv.innerHTML = "";

          const wrap = document.createElement("div");
          wrap.className = "coord-card";
          wrap.innerHTML = `<h3>Type Summary - All Void Patterns</h3>`;

          const layersWrap = document.createElement("div");
          layersWrap.className = "layers-wrap";

          summaryMasks.forEach((summaryCanvas, chipType) => {
            const item = document.createElement("div");
            item.className = "layer-item";
            item.innerHTML = `<div class="layer-label" style="color: #e74c3c">${chipType.toUpperCase()} - ALL VOIDS</div>`;
            item.appendChild(summaryCanvas);
            layersWrap.appendChild(item);
          });

          wrap.appendChild(layersWrap);
          patchesDiv.appendChild(wrap);

          document.getElementById(
            "pageInfo"
          ).textContent = `Type Summary (${summaryMasks.size} types)`;

          console.log(
            `Displayed summary for types: ${Array.from(
              summaryMasks.keys()
            ).join(", ")}`
          );
        }


        showVoidStats() {
          const stats = this.voidManager.getStats();
          alert(`Void Statistics:
Total Voids: ${stats.totalVoids}

By Type:
${Object.entries(stats.byType)
  .map(([type, count]) => `${type}: ${count}`)
  .join("\n")}

By Layer:
${Object.entries(stats.byLayer)
  .map(([layer, count]) => `Layer ${layer}: ${count}`)
  .join("\n")}

Check console for detailed info.`);
          console.log("Detailed void statistics:", stats);
        }

        debugCheck() {
          console.log("=== WAFER APP V2 DEBUG ===");
          console.log("Pages loaded:", this.pages.length);
          console.log("CSV rows:", this.csvRows.length);
          console.log("Patch pages:", this.allPatchPages.length);

          this.voidManager.debug();

          alert(`Debug Info:
Pages: ${this.pages.length}
CSV Rows: ${this.csvRows.length}
Void Records: ${this.voidManager.voids.size}
Check console for details.`);
        }

        /**
         * íŒ¨ì¹˜ ì •ë ¬ í”„ë¦¬ë·° ì—…ë°ì´íŠ¸
         */
        updateGridPreview() {
          const canvas = this.gridPreviewCanvas;
          const ctx = this.gridPreviewCtx;
          const statusDiv = document.getElementById("previewStatus");

          // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f8f8f8";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš°
          if (!this.pages.length) {
            ctx.fillStyle = "#999";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
              "Load TIFF file to see patch samples",
              canvas.width / 2,
              canvas.height / 2
            );
            statusDiv.textContent = "Load TIFF to see patch samples";
            return;
          }

          // í˜„ì¬ í˜ì´ì§€ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
          const currentPage = this.pages[this.pageIndex] || this.pages[0];

          // ê·¸ë¦¬ë“œ íŒŒë¼ë¯¸í„°
          const cellW = +document.getElementById("cellW").value || 100;
          const cellH = +document.getElementById("cellH").value || 100;

          // ìƒ˜í”Œ ì¢Œí‘œ ê²°ì •
          const sampleCoords = this.getSampleCoordsForPreview();

          if (sampleCoords.length === 0) {
            // ë³¸ë”© ì¢Œí‘œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒ˜í”Œ ìœ„ì¹˜ ì‚¬ìš©
            sampleCoords.push(
              { x: 0, y: 0, label: "Center sample" },
              { x: 2, y: 1, label: "Sample 2" },
              { x: -1, y: -1, label: "Sample 3" }
            );
          }

          // ìƒ˜í”Œ íŒ¨ì¹˜ë“¤ì„ í”„ë¦¬ë·°ì— ê·¸ë¦¬ê¸°
          this.drawPatchSamples(ctx, currentPage, sampleCoords, cellW, cellH);

          // ìƒíƒœ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
          statusDiv.textContent = `Showing ${sampleCoords.length} patch samples (Cell: ${cellW}Ã—${cellH})`;
        }

        /**
         * í”„ë¦¬ë·°ìš© ìƒ˜í”Œ ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
         */
        getSampleCoordsForPreview() {
          if (this.csvRows.length === 0) return [];

          const samples = [];
          const maxSamples = 4; // í”„ë¦¬ë·°ì—ì„œ ë³´ì—¬ì¤„ ìµœëŒ€ ìƒ˜í”Œ ìˆ˜

          if (this.csvRows.length <= maxSamples) {
            // ì „ì²´ ì¢Œí‘œê°€ ì ìœ¼ë©´ ëª¨ë‘ í‘œì‹œ
            return this.csvRows.map((coord, i) => ({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            }));
          }

          // ê· ë“±í•˜ê²Œ ë¶„ì‚°ëœ ìƒ˜í”Œ ì„ íƒ
          const step = Math.floor(this.csvRows.length / maxSamples);
          for (let i = 0; i < maxSamples; i++) {
            const coord = this.csvRows[i * step];
            samples.push({
              ...coord,
              label: `(${coord.x},${coord.y})`,
            });
          }

          return samples;
        }

        /**
         * íŒ¨ì¹˜ ìƒ˜í”Œë“¤ì„ í”„ë¦¬ë·° ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
         */
        drawPatchSamples(ctx, sourcePage, sampleCoords, cellW, cellH) {
          const canvas = ctx.canvas;
          const padding = 5;
          const cols = 2; // 2ì—´ë¡œ ë°°ì¹˜
          const rows = Math.ceil(sampleCoords.length / cols);

          const availableWidth = canvas.width - padding * 2;
          const availableHeight = canvas.height - padding * 2 - 20; // í…ìŠ¤íŠ¸ ê³µê°„

          const patchW = Math.floor(availableWidth / cols) - padding;
          const patchH = Math.floor(availableHeight / rows) - padding;

          // íŒ¨ì¹˜ í¬ê¸°ë¥¼ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë§ì¶”ê¸°
          const patchSize = Math.min(patchW, patchH);

          sampleCoords.forEach((coord, index) => {
            const col = index % cols;
            const row = Math.floor(index / cols);

            const drawX = padding + col * (patchSize + padding);
            const drawY = padding + row * (patchSize + padding) + 15; // í…ìŠ¤íŠ¸ ê³µê°„

            // ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ íŒ¨ì¹˜ ì˜ì—­ ê³„ì‚°
            const sourceX = this.origin.x + (coord.x - this.refGrid.x) * cellW;
            const sourceY = this.origin.y + (coord.y - this.refGrid.y) * cellH;

            console.log(sourceX, sourceY, cellW, cellH);

            // íŒ¨ì¹˜ ê·¸ë¦¬ê¸°
            try {
              ctx.drawImage(
                sourcePage,
                sourceX,
                sourceY,
                cellW,
                cellH,
                drawX,
                drawY,
                patchSize,
                patchSize
              );

              // íŒ¨ì¹˜ ê²½ê³„ì„ 
              ctx.strokeStyle = "#333";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              // ì¢Œí‘œ ë¼ë²¨
              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            } catch (error) {
              // ì´ë¯¸ì§€ ì˜ì—­ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ê²½ìš°
              ctx.fillStyle = "#ffeeee";
              ctx.fillRect(drawX, drawY, patchSize, patchSize);
              ctx.strokeStyle = "#ff0000";
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX, drawY, patchSize, patchSize);

              ctx.fillStyle = "#ff0000";
              ctx.font = "9px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(
                "Out of",
                drawX + patchSize / 2,
                drawY + patchSize / 2 - 5
              );
              ctx.fillText(
                "bounds",
                drawX + patchSize / 2,
                drawY + patchSize / 2 + 5
              );

              ctx.fillStyle = "#000";
              ctx.font = "10px sans-serif";
              ctx.fillText(coord.label, drawX + patchSize / 2, drawY - 3);
            }

            // ê° íŒ¨ì¹˜ì— ë¹¨ê°„ì  í‘œì‹œ (ê¸°ì¤€ì ì´ ì´ íŒ¨ì¹˜ì˜ ì–´ëŠ ìœ„ì¹˜ì¸ì§€)
            this.drawRedPointOnPatch(
              ctx,
              coord,
              drawX,
              drawY,
              patchSize,
              cellW,
              cellH
            );
          });
        }

        /**
         * ì‹¤ì‹œê°„ void ë§ˆìŠ¤í¬ ìº”ë²„ìŠ¤ ìƒì„±
         */
        createVoidMaskCanvas(chipCoord, type, forceCreate = false) {
          const match = chipCoord.match(/\((-?\d+),(-?\d+)\)/);
          if (!match) return null;

          const chipX = parseInt(match[1], 10);
          const chipY = parseInt(match[2], 10);
          const cellW = +document.getElementById("cellW").value;
          const cellH = +document.getElementById("cellH").value;

          // í•´ë‹¹ ì¹©ì— voidê°€ ìˆëŠ”ì§€ í™•ì¸
          const chipVoids = [];
          for (const [voidKey, voidData] of this.voidManager.voids.entries()) {
            if (voidData.x === chipX && voidData.y === chipY) {
              chipVoids.push(voidData);
            }
          }

          // forceCreateê°€ falseì´ê³  voidê°€ ì—†ìœ¼ë©´ null ë°˜í™˜ (ì´ì „ ë™ì‘)
          if (!forceCreate && chipVoids.length === 0) {
            return null;
          }

          // íˆ¬ëª… ë§ˆìŠ¤í¬ ìº”ë²„ìŠ¤ ìƒì„± (voidê°€ ì—†ì–´ë„ ë¹ˆ ìº”ë²„ìŠ¤ ìƒì„±)
          const patchSize = 300;
          const titleH = 40;
          const maskCanvas = document.createElement("canvas");
          maskCanvas.width = patchSize;
          maskCanvas.height = (patchSize * cellH) / cellW + titleH;
          const maskCtx = maskCanvas.getContext("2d");

          // ë°°ê²½ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì •
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

          // íƒ€ì´í‹€ ì˜ì—­ (ê²€ì€ ë°°ê²½)
          const label = `X${padCoord(chipX)}_Y${padCoord(
            chipY
          )}_L00_LEG:${type}`;
          maskCtx.fillStyle = "#000";
          maskCtx.fillRect(0, 0, patchSize, titleH);
          maskCtx.fillStyle = "#fff";
          maskCtx.font = "20px sans-serif";
          maskCtx.textBaseline = "middle";
          maskCtx.fillText(label, 6, titleH / 2);

          // void ë§ˆìŠ¤í¬ ê·¸ë¦¬ê¸° (voidê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ)
          if (chipVoids.length > 0) {
            // ì˜¬ë°”ë¥¸ patchLabel í˜•íƒœë¡œ ìƒì„±: X05_Y07_L01_LEG:type
            const properPatchLabel = `X${padCoord(chipX)}_Y${padCoord(
              chipY
            )}_L01_LEG:${type}`;
            // mergeMode = true, titleOffset = titleH ì‚¬ìš©
            this.voidManager.drawVoids(maskCtx, properPatchLabel, true, titleH);
          }
          // voidê°€ ì—†ìœ¼ë©´ íƒ€ì´í‹€ë§Œ ìˆëŠ” ë¹ˆ ìº”ë²„ìŠ¤

          return maskCanvas;
        }

        /**
         * ë©”íƒ€ë°ì´í„°ì—ì„œ ì„¤ì • ì •ë³´ ì ìš©
         */
        applyMetadata(metadata) {
          try {
            // ê·¸ë¦¬ë“œ ì„¤ì • ì ìš©
            if (metadata.gridSettings) {
              document.getElementById("cols").value =
                metadata.gridSettings.cols || 8;
              document.getElementById("rows").value =
                metadata.gridSettings.rows || 8;
              document.getElementById("cellW").value =
                metadata.gridSettings.cellW || 100;
              document.getElementById("cellH").value =
                metadata.gridSettings.cellH || 100;
            }

            // Originê³¼ ì°¸ì¡° ê·¸ë¦¬ë“œ ì ìš©
            if (metadata.origin) {
              this.origin = { ...metadata.origin };
            }
            if (metadata.referenceGrid) {
              this.refGrid = { ...metadata.referenceGrid };
              document.getElementById("refX").value =
                metadata.referenceGrid.x || 0;
              document.getElementById("refY").value =
                metadata.referenceGrid.y || 0;
            }

            // í–¥ìƒ ì„¤ì • ì ìš©
            if (metadata.enhanceSettings) {
              const settings = metadata.enhanceSettings;
              document.getElementById("alpha").value = settings.alpha || 1.2;
              document.getElementById("beta").value = settings.beta || 10;
              document.getElementById("targetMean").value =
                settings.targetMean || 0.5;
              document.getElementById("targetStd").value =
                settings.targetStd || 0.2;
              document.getElementById("padPx").value = settings.padPx || 10;
            }

            // TIFF íŒŒì¼ëª… ì„¤ì • (ìˆëŠ” ê²½ìš°)
            if (metadata.tiffFileName) {
              this.currentTiffFileName = metadata.tiffFileName;
              document.getElementById(
                "localTiffPath"
              ).value = `/${metadata.tiffFileName}.tif`;
            }

            return true;
          } catch (error) {
            console.error("Error applying metadata:", error);
            return false;
          }
        }

        /**
         * JSON íŒŒì¼ì—ì„œ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
         */
        extractMetadataFromJson(jsonData) {
          // ì§ì ‘ metadata ê°ì²´ì¸ ê²½ìš°
          if (jsonData.gridSettings && jsonData.origin) {
            return jsonData;
          }

          // void JSON íŒŒì¼ì¸ ê²½ìš° (metadata í•„ë“œ ì•ˆì— ìˆìŒ)
          if (jsonData.metadata) {
            return jsonData.metadata;
          }

          // ë‹¤ë¥¸ êµ¬ì¡°ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ null ë°˜í™˜
          return null;
        }

        /**
         * í˜„ì¬ ê·¸ë¦¬ë“œ ì„¤ì • ì •ë³´ ìˆ˜ì§‘
         */
        getGridMetadata() {
          return {
            tiffFileName: this.currentTiffFileName,
            gridSettings: {
              cols: +document.getElementById("cols").value,
              rows: +document.getElementById("rows").value,
              cellW: +document.getElementById("cellW").value,
              cellH: +document.getElementById("cellH").value,
            },
            origin: { ...this.origin },
            referenceGrid: { ...this.refGrid },
            enhanceSettings: {
              alpha: parseFloat(document.getElementById("alpha").value),
              beta: parseFloat(document.getElementById("beta").value),
              targetMean: parseFloat(
                document.getElementById("targetMean").value
              ),
              targetStd: parseFloat(document.getElementById("targetStd").value),
              padPx: parseInt(document.getElementById("padPx").value, 10),
            },
            extractionInfo: {
              totalPages: this.pages.length,
              totalCoordinates: this.csvRows.length,
              totalPatches:
                this.patchManager.allPatchPages.length * this.pages.length,
              patchSize: 300, // ê³ ì • íŒ¨ì¹˜ í¬ê¸°
            },
            timestamp: new Date().toISOString(),
            version: "v2",
          };
        }

        /**
         * íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ í¬í•¨í•œ íŒŒì¼ëª… ìƒì„±
         */
        generateFileName(suffix = "", extension = "") {
          const now = new Date();
          const timestamp =
            now.getFullYear() +
            String(now.getMonth() + 1).padStart(2, "0") +
            String(now.getDate()).padStart(2, "0") +
            "_" +
            String(now.getHours()).padStart(2, "0") +
            String(now.getMinutes()).padStart(2, "0") +
            String(now.getSeconds()).padStart(2, "0");

          const baseName = this.currentTiffFileName || "wafer_data";
          return `${baseName}_${suffix}_${timestamp}${extension}`;
        }

        /**
         * void JSON ë™ê¸°í™” ì„¤ì •
         */
        setupVoidJsonSync() {
          const voidJsonTextarea = document.getElementById("voidJson");

          // textarea ë³€ê²½ ì‹œ void ë°ì´í„° ì—…ë°ì´íŠ¸
          voidJsonTextarea.addEventListener("input", () => {
            try {
              const jsonData = JSON.parse(voidJsonTextarea.value);
              this.loadVoidDataFromJson(jsonData);
              this.patchManager.refreshCurrentPatches();
            } catch (error) {
              // JSON íŒŒì‹± ì˜¤ë¥˜ ì‹œ ë¬´ì‹œ (ì‚¬ìš©ìê°€ íƒ€ì´í•‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
            }
          });

          // ì´ˆê¸° í‘œì‹œ
          this.updateVoidJsonDisplay();
        }

        /**
         * void ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ í‘œì‹œ ì—…ë°ì´íŠ¸
         */
        updateVoidJsonDisplay() {
          const voidJsonTextarea = document.getElementById("voidJson");
          const voidData = this.voidManager.exportVoids();
          voidJsonTextarea.value = JSON.stringify(voidData, null, 2);
        }

        /**
         * JSON ë°ì´í„°ì—ì„œ void ë°ì´í„° ë¡œë“œ
         */
        loadVoidDataFromJson(jsonData) {
          // ê¸°ì¡´ void ë°ì´í„° í´ë¦¬ì–´
          this.voidManager.voids.clear();
          this.voidManager.voidIndexCounters.clear();

          // JSON ë°ì´í„°ì—ì„œ void ë³µì›
          jsonData.forEach((voidItem) => {
            const voidKey = voidItem.key;
            delete voidItem.key; // keyëŠ” ë³„ë„ë¡œ ì²˜ë¦¬
            this.voidManager.voids.set(voidKey, voidItem);

            // ì¸ë±ìŠ¤ ì¹´ìš´í„°ë„ ì—…ë°ì´íŠ¸
            const locationKey = this.voidManager.createLocationKey(
              voidItem.x,
              voidItem.y,
              voidItem.layer
            );
            const currentMax =
              this.voidManager.voidIndexCounters.get(locationKey) || 0;
            this.voidManager.voidIndexCounters.set(
              locationKey,
              Math.max(currentMax, voidItem.voidIndex + 1)
            );
          });
        }

        /**
         * íŒ¨ì¹˜ì— ë¹¨ê°„ì (ê¸°ì¤€ì ) í‘œì‹œ
         */
        drawRedPointOnPatch(
          ctx,
          coord,
          patchX,
          patchY,
          patchSize,
          cellW,
          cellH
        ) {
          // ê¸°ì¤€ì ì´ ì´ íŒ¨ì¹˜ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
          const refRelativeX = this.refGrid.x - coord.x; // ê¸°ì¤€ì ì˜ ìƒëŒ€ì  X ìœ„ì¹˜
          const refRelativeY = this.refGrid.y - coord.y; // ê¸°ì¤€ì ì˜ ìƒëŒ€ì  Y ìœ„ì¹˜

          // íŒ¨ì¹˜ ë‚´ë¶€ ì¢Œí‘œë¡œ ë³€í™˜ (0~1 ë²”ìœ„)
          const refNormalizedX = refRelativeX + 0.5; // íŒ¨ì¹˜ ì¤‘ì‹¬ì´ 0.5
          const refNormalizedY = refRelativeY + 0.5;

          // íŒ¨ì¹˜ ë‚´ë¶€ì— ìˆëŠ” ê²½ìš°ì—ë§Œ ë¹¨ê°„ì  í‘œì‹œ
          if (
            refNormalizedX >= 0 &&
            refNormalizedX <= 1 &&
            refNormalizedY >= 0 &&
            refNormalizedY <= 1
          ) {
            const redPointX = patchX + refNormalizedX * patchSize;
            const redPointY = patchY + refNormalizedY * patchSize;

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(redPointX, redPointY, 4, 0, 2 * Math.PI);
            ctx.fill();

            // ë¹¨ê°„ì  ì£¼ìœ„ì— í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€ (ê°€ë…ì„± í–¥ìƒ)
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        /**
         * Quick Test Mode - í…ŒìŠ¤íŠ¸ ë°ì´í„° ìë™ ë¡œë“œ
         */
        async loadQuickTestData() {
          const quickBtn = document.getElementById("quickTestBtn");
          const originalText = quickBtn.textContent;

          try {
            quickBtn.textContent = "Loading Test Data...";
            quickBtn.disabled = true;

            // 1. í…ŒìŠ¤íŠ¸ìš© TIFF íŒŒì¼ ì„¤ì • ë° ë¡œë“œ
            const testTiffPath = "/realistic_wafer_sample_fast_1000.tif";
            document.getElementById("localTiffPath").value = testTiffPath;

            console.log("ğŸš€ Quick Test Mode: Loading TIFF file...");

            // TIFF ë¡œë“œ
            const rangeServerUrl = `http://localhost:8083${testTiffPath}`;
            this.currentTiffFileName = "realistic_wafer_sample_fast";

            this.showProgress();
            this.updateProgress(10, "Loading test TIFF...", rangeServerUrl);

            this.pages = await ImageProcessor.loadTiffFromServer(
              rangeServerUrl,
              (current, total, details) => {
                const progress = 10 + (current / total) * 40; // 10-50%
                this.updateProgress(
                  progress,
                  `Loading page ${current}/${total}`,
                  details
                );
              }
            );

            this.updateProgress(55, "Loading test coordinates...", "");

            // 2. í…ŒìŠ¤íŠ¸ìš© Bonding Map ê²©ì ë°ì´í„° ë¡œë“œ
            const testBondingMap = `	0	1	2	3	4	5
0	good	dummy	test	edge	good	test
1	dummy	good	good	good	edge	good
2	test	good	good	good	good	good
3	edge	good	good	good	good	good
4	good	edge	good	good	good	good
5	test	good	good	good	good	good`;

            console.log(
              "ğŸš€ Quick Test Mode: Loading Bonding Map coordinates..."
            );
            this.csvRows = parseBondingMap(testBondingMap);
            this.chipPoints = this.csvRows.map((r) => ({ x: r.x, y: r.y }));

            // Bonding Map textareaì— ë°ì´í„° í‘œì‹œ
            document.getElementById("csvPaste").value = testBondingMap;

            this.updateProgress(
              70,
              "Updating UI...",
              "Page selector and preview"
            );

            // 3. UI ì—…ë°ì´íŠ¸
            this.updatePageSelect();
            await this.drawPage();
            this.updateGridPreview();

            this.updateProgress(
              90,
              "Setting optimal settings...",
              "Grid and enhancement"
            );

            // 4. ìµœì  ì„¤ì • ì ìš©
            document.getElementById("cols").value = 6;
            document.getElementById("rows").value = 6;
            document.getElementById("cellW").value = 150;
            document.getElementById("cellH").value = 150;
            document.getElementById("alpha").value = 1.3;
            document.getElementById("beta").value = 15;
            document.getElementById("targetMean").value = 0.5;
            document.getElementById("targetStd").value = 0.2;

            // ê¸°ì¤€ì  ì„¤ì •
            document.getElementById("refX").value = 0;
            document.getElementById("refY").value = 0;
            this.refGrid = { x: 0, y: 0 };

            this.updateProgress(
              100,
              "Test data loaded!",
              "Ready for patch extraction"
            );

            console.log("ğŸš€ Quick Test Mode: Complete!");
            console.log(`- TIFF: ${this.pages.length} pages loaded`);
            console.log(`- Coordinates: ${this.csvRows.length} chips loaded`);

            setTimeout(() => this.hideProgress(), 2000);

            alert(`ğŸš€ Quick Test Mode Complete!

ğŸ“Š Data Loaded:
- TIFF: ${this.pages.length} pages
- Coordinates: ${this.csvRows.length} chips
- Grid: 6x6, Cell: 150x150px
- Range: x(0~5), y(0~5)

âœ… Ready for testing:
1. Click "Extract Patches" to generate patches
2. Use void marking tools in right panel
3. Test sync mode and export features

Happy testing! ğŸ¯`);
          } catch (error) {
            console.error("Quick Test Mode failed:", error);
            alert(`Quick Test Mode failed: ${error.message}`);
            this.hideProgress();
          } finally {
            quickBtn.textContent = originalText;
            quickBtn.disabled = false;
          }
        }
      }

      // ì•± ì´ˆê¸°í™”
      const app = new WaferAppV2();
      window.waferApp = app;
    </script>
  </body>
</html>
